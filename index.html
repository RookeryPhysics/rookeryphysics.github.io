<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Play 0.23a</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: sans-serif; 
            background-color: #000; 
            cursor: none;
        }
        
        @media (pointer: fine) {
            body {
                cursor: crosshair;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
            }
        }

        canvas { display: block; }
        
        
        #developer-options {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1200;
        }
        #developer-options button {
            background-color: rgba(40,40,40,0.85);
            color: #fff;
            border: 1px solid #666;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        #developer-options button:hover {
            background-color: rgba(74,74,74,0.9);
        }
        #developer-options button:focus {
            outline: none;
        }
        #developer-options .menu {
            display: none;
            flex-direction: column;
            gap: 6px;
            padding: 10px;
            background-color: rgba(30,30,30,0.92);
            border: 1px solid #555;
            border-radius: 6px;
            min-width: 160px;
        }
        #developer-options.open .menu {
            display: flex;
        }
        #developer-options label {
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
        }
        #developer-options input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .ui-note { color: #aaa; font-size: 11px; line-height: 1.2; }

        
        /* Default mode selector for mobile */
        #mode-selector { 
            position: absolute; 
            bottom: 10px; 
            left: 10px; 
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
            padding: 12px; 
            background-color: rgba(40,40,40,0.85); 
            border-radius: 8px; 
            z-index: 100; 
        }
        #mode-selector button { 
            background-color: #4f4f4f; 
            color: white; 
            border: 1px solid #666; 
            padding: 8px 16px; 
            border-radius: 6px; 
            cursor: pointer; 
            transition: background-color 0.2s; 
        }
        #mode-selector button:hover { background-color: #6a6a6a; }
        #mode-selector button.active { background-color: #6a6a6a; }
        
        /* Enhanced mode selector for desktop */
        @media (pointer: fine) {
            #mode-selector {
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                max-width: 900px;
                padding: 16px 20px;
                background: linear-gradient(135deg, rgba(30,30,35,0.95), rgba(45,45,55,0.95));
                border: 1px solid rgba(100,100,120,0.4);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.6);
                backdrop-filter: blur(10px);
            }
            
            #mode-selector button {
                background: linear-gradient(145deg, #4a4a5c, #3a3a48);
                color: #e8e8f0;
                border: 1px solid rgba(120,120,150,0.5);
                padding: 10px 18px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 600;
                letter-spacing: 0.5px;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 2px 8px rgba(0,0,0,0.3), 
                            inset 0 1px 1px rgba(255,255,255,0.1);
                position: relative;
                overflow: hidden;
            }
            
            #mode-selector button::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
                transition: left 0.5s;
            }
            
            #mode-selector button:hover {
                background: linear-gradient(145deg, #5a5a6c, #4a4a58);
                border-color: rgba(150,150,180,0.7);
                transform: translateY(-2px);
                box-shadow: 0 4px 16px rgba(0,0,0,0.5),
                            0 0 20px rgba(100,150,255,0.3),
                            inset 0 1px 1px rgba(255,255,255,0.15);
            }
            
            #mode-selector button:hover::before {
                left: 100%;
            }
            
            #mode-selector button:active {
                transform: translateY(0);
                box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                            inset 0 2px 4px rgba(0,0,0,0.3);
            }
            
            #mode-selector button.active {
                background: linear-gradient(145deg, #5080d0, #4060b0);
                border-color: rgba(80,150,255,0.8);
                color: #fff;
                box-shadow: 0 4px 16px rgba(80,130,255,0.5),
                            0 0 25px rgba(80,130,255,0.4),
                            inset 0 1px 1px rgba(255,255,255,0.2);
            }
            
            #mode-selector button.active:hover {
                background: linear-gradient(145deg, #5590e0, #4570c0);
                box-shadow: 0 6px 20px rgba(80,130,255,0.6),
                            0 0 30px rgba(80,130,255,0.5),
                            inset 0 1px 1px rgba(255,255,255,0.25);
            }
        }
        
        /* Developer modes bar - vertical on right side (desktop only) */
        #developer-modes-bar {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 16px 14px;
            background: linear-gradient(135deg, rgba(30,30,35,0.95), rgba(45,45,55,0.95));
            border: 1px solid rgba(100,100,120,0.4);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #developer-modes-bar button {
            background: linear-gradient(145deg, #4a4a5c, #3a3a48);
            color: #e8e8f0;
            border: 1px solid rgba(120,120,150,0.5);
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 
                        inset 0 1px 1px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }
        
        #developer-modes-bar button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        #developer-modes-bar button:hover {
            background: linear-gradient(145deg, #5a5a6c, #4a4a58);
            border-color: rgba(150,150,180,0.7);
            transform: translateX(-3px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.5),
                        0 0 20px rgba(255,150,100,0.3),
                        inset 0 1px 1px rgba(255,255,255,0.15);
        }
        
        #developer-modes-bar button:hover::before {
            left: 100%;
        }
        
        #developer-modes-bar button:active {
            transform: translateX(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                        inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        #developer-modes-bar button.active {
            background: linear-gradient(145deg, #d08050, #b06040);
            border-color: rgba(255,150,80,0.8);
            color: #fff;
            box-shadow: 0 4px 16px rgba(255,130,80,0.5),
                        0 0 25px rgba(255,130,80,0.4),
                        inset 0 1px 1px rgba(255,255,255,0.2);
        }
        
        #developer-modes-bar button.active:hover {
            background: linear-gradient(145deg, #e09050, #c07040);
            box-shadow: 0 6px 20px rgba(255,130,80,0.6),
                        0 0 30px rgba(255,130,80,0.5),
                        inset 0 1px 1px rgba(255,255,255,0.25);
        }
        
        /* World actions bar - bottom right (desktop only) */
        #world-actions-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: row;
            gap: 10px;
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(30,30,35,0.95), rgba(45,45,55,0.95));
            border: 1px solid rgba(100,100,120,0.4);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #world-actions-bar button {
            background: linear-gradient(145deg, #4a5c4a, #3a483a);
            color: #e8f0e8;
            border: 1px solid rgba(120,150,120,0.5);
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), 
                        inset 0 1px 1px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        
        #world-actions-bar button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        #world-actions-bar button:hover {
            background: linear-gradient(145deg, #5a6c5a, #4a584a);
            border-color: rgba(150,180,150,0.7);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.5),
                        0 0 20px rgba(100,255,150,0.3),
                        inset 0 1px 1px rgba(255,255,255,0.15);
        }
        
        #world-actions-bar button:hover::before {
            left: 100%;
        }
        
        #world-actions-bar button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                        inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* Hide new bars on mobile */
        @media (pointer: coarse) {
            #developer-modes-bar,
            #world-actions-bar {
                display: none;
            }
        }
        
        /* --- Modified Color Selector CSS --- */
        #color-selector { 
            position: absolute; 
            display: none; 
            flex-direction: column; 
            gap: 8px; 
            padding: 12px; 
            background-color: rgba(40,40,40,0.85); 
            border-radius: 8px; 
            align-items: center; 
            z-index: 100; 
        }
        #color-selector label { font-size: 14px; margin-bottom: 4px; color: #fff; }
        #color-selector input[type="color"] { width: 50px; height: 30px; border: 1px solid #666; border-radius: 6px; cursor: pointer; }
        
        @media (pointer: fine) {
            #color-selector {
                bottom: 20px; 
                left: 20px; 
                background: linear-gradient(135deg, rgba(30,30,35,0.95), rgba(45,45,55,0.95));
                border: 1px solid rgba(100,100,120,0.4);
                border-radius: 10px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.6);
                backdrop-filter: blur(10px);
                padding: 14px 18px;
            }
            #color-selector label {
                font-weight: 600;
                letter-spacing: 0.5px;
                color: #e8e8f0;
            }
            #color-selector input[type="color"] {
                width: 60px;
                height: 35px;
                border: 2px solid rgba(120,120,150,0.5);
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            #color-selector input[type="color"]:hover {
                border-color: rgba(150,150,180,0.8);
                box-shadow: 0 0 15px rgba(100,150,255,0.3);
            }
        }
        
        @media (pointer: coarse) {
            #color-selector {
                bottom: 135px; /* Above the action buttons grid */
                right: 30px;
                z-index: 1001; /* Above other mobile UI */
            }
            #color-selector input[type="color"] {
                width: 60px; /* Bigger for touch */
                height: 40px;
            }
        }
        /* --- End of Modified CSS --- */
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 200;
        }

        #seed-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        #seed-box {
            background: #2a2a2a;
            padding: 25px 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            max-width: 90%;
        }
        #seed-box h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 300;
        }
        #seed-box p {
            margin-bottom: 20px;
            font-size: 14px;
            color: #ccc;
        }
        #seed-input {
            padding: 12px;
            width: 250px;
            max-width: calc(100% - 24px);
            border: 1px solid #555;
            background: #333;
            color: white;
            border-radius: 6px;
            font-size: 16px;
        }
        #start-game-btn {
            padding: 12px 24px;
            margin-top: 20px;
            background-color: #4f4f4f;
            color: white;
            border: 1px solid #666;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 16px;
            width: 100%;
        }
        #start-game-btn:hover {
            background-color: #6a6a6a;
        }
        #load-world-btn {
            padding: 12px 24px;
            margin-top: 10px;
            background-color: #4f4f4f;
            color: white;
            border: 1px solid #666;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 16px;
            width: 100%;
        }
        #load-world-btn:hover {
            background-color: #6a6a6a;
        }

        #mobile-controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }

        #mobile-controls-container.active {
            display: block;
        }

        #joystick-container {
            position: absolute;
            bottom: 50px;
            left: 10px;
            width: 120px;
            height: 120px;
            background-color: rgba(80, 80, 80, 0.4);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background-color: rgba(180, 180, 180, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        #action-buttons-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-areas:
                ". mode save"
                "switch action jump";
            gap: 15px;
            pointer-events: auto;
            color: white;
            text-align: center;
        }

        #mobile-mode-display {
            grid-area: mode;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            /* Allow taps to trigger color picker */
            pointer-events: auto; 
            cursor: pointer;
        }

        .action-btn {
            width: 65px;
            height: 65px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            background-color: rgba(80, 80, 80, 0.5);
            color: white;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
        }

    #mobile-jump-btn { grid-area: jump; }
    #mobile-action-btn { grid-area: action; }
    #mobile-switch-mode-btn { grid-area: switch; }
    #mobile-save-world-btn { grid-area: save; }

        .action-btn:active {
            background-color: rgba(120, 120, 120, 0.7);
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 40px;
            z-index: 3000;
            perspective: 600px;
        }

        #loading-cube {
            position: relative;
            width: 60px;
            height: 60px;
            transform-style: preserve-3d;
            animation: spinCube 1.6s linear infinite;
        }

        #loading-cube .cube-face {
            position: absolute;
            width: 60px;
            height: 60px;
            background: #ffffff;
            opacity: 0.92;
            border: 2px solid rgba(255, 255, 255, 0.6);
            box-sizing: border-box;
        }

        #loading-cube .front { transform: translateZ(30px); }
        #loading-cube .back { transform: rotateY(180deg) translateZ(30px); }
        #loading-cube .right { transform: rotateY(90deg) translateZ(30px); }
        #loading-cube .left { transform: rotateY(-90deg) translateZ(30px); }
        #loading-cube .top { transform: rotateX(90deg) translateZ(30px); }
        #loading-cube .bottom { transform: rotateX(-90deg) translateZ(30px); }

        #loading-message {
            display: flex;
            align-items: center;
            gap: 1px;
            color: #ffffff;
            font-size: 28px;
            letter-spacing: 1px;
            font-weight: 600;
        }

        #loading-message .dot {
            animation: dotPulse 1.4s ease-in-out infinite;
            animation-delay: var(--delay, 0s);
            opacity: 0.25;
        }

        @keyframes spinCube {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            100% { transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg); }
        }

        @keyframes dotPulse {
            0%, 20% { opacity: 0.25; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.25; transform: scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="seed-overlay">
        <div id="seed-box">
            <h2>Enter World Seed</h2>
            <p>Leave blank for a random world.</p>
            <input type="text" id="seed-input" placeholder="e.g., 'mountainview' or '12345'">
            <button id="start-game-btn">Generate World</button>
            <button id="load-world-btn">Load World</button>
        </div>
    </div>
    
    <input type="file" id="load-file-input" accept=".json" style="display: none;">

    <div id="developer-options">
        <button id="developer-options-toggle">Developer ▾</button>
        <div class="menu">
            <label>
                <input type="checkbox" id="bedrock-mode-toggle">
                Bedrock
            </label>
            <label>
                <input type="checkbox" id="map-tools-toggle">
                Map Tools
            </label>
            <label>
                <input type="checkbox" id="jump-pads-toggle">
                Jump Pads
            </label>
            <div class="ui-note">Enable to spawn green launch pads</div>
            <hr style="border: none; border-top: 1px solid #555; margin: 8px 0;">
            <label>
                <input type="checkbox" id="noclip-toggle">
                Noclip
            </label>
        </div>
    </div>

    <div id="loading-screen">
        <div id="loading-cube">
            <div class="cube-face front"></div>
            <div class="cube-face back"></div>
            <div class="cube-face right"></div>
            <div class="cube-face left"></div>
            <div class="cube-face top"></div>
            <div class="cube-face bottom"></div>
        </div>
        <div id="loading-message">
            <span class="dot" style="--delay: 0s;">.</span>
            <span class="dot" style="--delay: 0.15s;">.</span>
            <span class="dot" style="--delay: 0.3s;">.</span>
            <span class="loading-word">Loading</span>
            <span class="dot" style="--delay: 0.45s;">.</span>
            <span class="dot" style="--delay: 0.6s;">.</span>
            <span class="dot" style="--delay: 0.75s;">.</span>
        </div>
    </div>

    

    <div id="mode-selector">
        <button id="shoot-mode-btn">Shoot(1)</button>
        <button id="missile-mode-btn">Missile(2)</button>
        <button id="toolgun-mode-btn">Tool Gun(3)</button>
        <button id="add-mode-btn">Create(4)</button>
    </div>
    
    <div id="developer-modes-bar">
        <button id="bedrock-mode-btn" style="display: none;">Bedrock(5)</button>
        <button id="fill-mode-btn" style="display: none;">Fill(6)</button>
        <button id="sphere-mode-btn" style="display: none;">Sphere(7)</button>
        <button id="jumppad-mode-btn" style="display: none;">Jump Pad(8)</button>
    </div>
    
    <div id="world-actions-bar">
        <button id="save-world-btn">Save World</button>
        <button id="ingame-load-world-btn">Load World</button>
    </div>
    <div id="color-selector">
        <label for="cube-color-picker">Color</label>
        <input type="color" id="cube-color-picker" value="#999999">
    </div>
    <div id="crosshair"></div>

    <div id="mobile-controls-container">
        <div id="joystick-container">
            <div id="joystick-thumb"></div>
        </div>
        <div id="action-buttons-container">
            <div id="mobile-mode-display">Create</div>
            <button id="mobile-save-world-btn" class="action-btn">Save</button>
            <button id="mobile-jump-btn" class="action-btn">▲</button>
            <button id="mobile-action-btn" class="action-btn">⦿</button>
            <button id="mobile-switch-mode-btn" class="action-btn">⇄</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

let animationFrameId;
let scene, camera, renderer;
let raycaster;
let projectileRaycaster;
let noise;
let worldSeedString = ""; 
let worldSeedValue = 0;
let worldSeedSource = 'manual';
let isMobileDevice = false;

let playerCube;
let rifle; 
// Gun ownership and pickup state
let hasGun = false;
let gunPickup = null; // THREE.Group placed in world
const GUN_PICKUP_DISTANCE = 2.0;
const GUN_SPIN_SPEED = 2.5; // rad/sec
let gunPickupBobTime = 0;
let playerSpawnPoint = new THREE.Vector3();
const playerHeight = 1.6; 
const playerWidth = 0.8;  
const v = 6.0;
const playerJumpHeight = 10.0;
const gravity = -25;
let playerVelocity = new THREE.Vector3();
let playerOnGround = false;
let playerJumpCount = 0;
let isFlying = false;
const flyingSpeed = 25.0;
const keys = {};
let spaceWasPressedLastFrame = false;
const clock = new THREE.Clock();
let isAiming = false;
const hipRiflePosition = new THREE.Vector3(0.4, -0.25, -0.7);
const mobileHipRiflePosition = new THREE.Vector3(0.22, -0.32, -0.5);
const adsRiflePosition = new THREE.Vector3(0, -0.2, -0.5); 

const DEFAULT_MODES = ['shoot', 'missile', 'toolgun', 'add'];
const BEDROCK_PLACE_MODE = 'bedrock-add';
const MAP_TOOLS_MODES = ['fill', 'sphere'];
const JUMP_PAD_MODE = 'jump-pad';
let modes = [...DEFAULT_MODES];
let currentModeIndex = 0;
let currentMode = 'shoot';
let bedrockModesEnabled = false;
let bedrockPlacementToggle = false;
let noclipEnabled = false;
let mapToolsEnabled = false;
let jumpPadsEnabled = false;
let currentColor = 0x999999;
const modifiedBlocks = new Map();

// Map Tools state
let wallCorner1 = null;
let wallCorner2 = null;
const SPHERE_RADIUS = 3;
 
let heldBlock = null;
let toolgunLaser = null;
let isToolgunActive = false; 

let projectiles = [];
const PROJECTILE_SPEED = 160.0;
let missiles = [];
const MISSILE_SPEED = 40.0;
const MISSILE_EXPLOSION_RADIUS = 3;
const MISSILE_EXPLOSION_DURATION = 0.5;
const MISSILE_KNOCKBACK_FORCE = 15.0;
let explosions = [];
let laserFlashes = [];
const LASER_FLASH_DURATION = 0.05;
let blockRemovalParticles = [];
const MAX_BLOCK_REMOVAL_PARTICLES = 220;
let lastPlayerPos = new THREE.Vector3(); 

// Jump pad data
let jumpPads = [];
const JUMP_PAD_SIZE = 1.3; // width/depth of the pressure plate
const JUMP_PAD_HEIGHT = 0.15; // thin plate
const JUMP_PAD_COLOR = 0x2ecc71; // green
const JUMP_PAD_EMISSIVE = 0x2ecc71;
const JUMP_PAD_BOOST = 40.0; // launch strength
const JUMP_PAD_LAND_COOLDOWN = 0.35; // seconds before a pad can relaunch same player

const CHUNK_SIZE = 16;
const RENDER_DISTANCE = 5;
const TERRAIN_SCALE = 50;
const TERRAIN_AMPLITUDE = 30;
const loadedChunks = new Map();
const chunkGenerationQueue = new Set();
let currentPlayerChunkX, currentPlayerChunkZ;
const BEDROCK_LEVEL = -30;

const DIRT_COLOR_1 = new THREE.Color(0x8B4513);
const DIRT_COLOR_2 = new THREE.Color(0x654321);
const STONE_COLOR_1 = new THREE.Color(0x808080);
const STONE_COLOR_2 = new THREE.Color(0x696969);
const SNOW_COLOR = new THREE.Color(0xFFFFFF);
const BEDROCK_COLOR_1 = new THREE.Color(0x303030);
const BEDROCK_COLOR_2 = new THREE.Color(0x3a3a3a);

const chunkGenerationJobs = new Map();
const MAX_CHUNK_STEPS_PER_SLICE = 4996;
const BOOSTED_CHUNK_STEPS_PER_SLICE = MAX_CHUNK_STEPS_PER_SLICE * 6;
const CHUNK_SPEED_BOOST_DURATION_MS = 6000;
let chunkSpeedBoostEndTime = 0;

let loadingScreenTimer = null;

function updateAvailableModes() {
    let newModes = [...DEFAULT_MODES];
    
    if (mapToolsEnabled && hasGun) {
        newModes = [...newModes, ...MAP_TOOLS_MODES];
    }
    
    if (bedrockModesEnabled && hasGun) {
        newModes = [...newModes, BEDROCK_PLACE_MODE];
    }
    if (jumpPadsEnabled && hasGun) {
        newModes = [...newModes, JUMP_PAD_MODE];
    }
    
    modes = newModes;
}

function setCurrentMode(mode) {
    if (!hasGun) return; // No mode switching before picking up the gun
    if (!modes.includes(mode)) return;
    currentMode = mode;
    currentModeIndex = modes.indexOf(mode);
    updateModeButtons();
}

function setBedrockModesEnabled(enabled) {
    bedrockModesEnabled = !!enabled;
    updateAvailableModes();

    const toggleEl = document.getElementById('bedrock-mode-toggle');
    if (toggleEl) {
        toggleEl.checked = bedrockModesEnabled;
    }

    if (!bedrockModesEnabled) {
        bedrockPlacementToggle = false;
    }

    if (!bedrockModesEnabled && currentMode === BEDROCK_PLACE_MODE) {
        setCurrentMode('shoot');
    } else {
        const nextIndex = modes.indexOf(currentMode);
        if (nextIndex !== -1) {
            currentModeIndex = nextIndex;
            updateModeButtons();
        } else {
            setCurrentMode('shoot');
        }
    }
}

function setNoclipEnabled(enabled) {
    noclipEnabled = !!enabled;
    const toggleEl = document.getElementById('noclip-toggle');
    if (toggleEl) {
        toggleEl.checked = noclipEnabled;
    }

    if (!noclipEnabled && isFlying) {
        isFlying = false;
        playerVelocity.y = 0;
        playerJumpCount = 0;
    }
}

function setMapToolsEnabled(enabled) {
    mapToolsEnabled = !!enabled;
    updateAvailableModes();
    
    const toggleEl = document.getElementById('map-tools-toggle');
    if (toggleEl) {
        toggleEl.checked = mapToolsEnabled;
    }
    
    // Reset stored corners when disabling
    if (!mapToolsEnabled) {
        wallCorner1 = null;
        wallCorner2 = null;
    }
    
    // If currently in a map tools mode and it's being disabled, switch to shoot
    if (!mapToolsEnabled && MAP_TOOLS_MODES.includes(currentMode)) {
        setCurrentMode('shoot');
    } else {
        const nextIndex = modes.indexOf(currentMode);
        if (nextIndex !== -1) {
            currentModeIndex = nextIndex;
            updateModeButtons();
        } else {
            setCurrentMode('shoot');
        }
    }
}

function setJumpPadsEnabled(enabled) {
    jumpPadsEnabled = !!enabled;
    updateAvailableModes();

    const toggleEl = document.getElementById('jump-pads-toggle');
    if (toggleEl) {
        toggleEl.checked = jumpPadsEnabled;
    }

    // If currently in this mode and disabling, switch to shoot
    if (!jumpPadsEnabled && currentMode === JUMP_PAD_MODE) {
        setCurrentMode('shoot');
    } else {
        const nextIndex = modes.indexOf(currentMode);
        if (nextIndex !== -1) {
            currentModeIndex = nextIndex;
            updateModeButtons();
        } else {
            setCurrentMode('shoot');
        }
    }
}


function isMobile() {
    const regex = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
    return regex.test(navigator.userAgent);
}

// Set the runtime flag and hide developer options on mobile devices
// Uses the same detection function already present in the file.
try {
    isMobileDevice = isMobile();
    const devOptionsEl = document.getElementById('developer-options');
    if (devOptionsEl) {
        if (isMobileDevice) {
            // Ensure developer options are not visible on mobile
            devOptionsEl.style.display = 'none';
        } else {
            // Explicitly show on non-mobile (desktop) in case CSS or other code toggles it
            devOptionsEl.style.display = '';
        }
    }
} catch (e) {
    // Fail silently if DOM isn't ready yet or something else goes wrong
    console.warn('Failed to apply mobile developer-options visibility:', e);
}

function showLoadingOverlay() {
    const overlay = document.getElementById('loading-screen');
    if (!overlay) return;
    overlay.style.display = 'flex';
}

function hideLoadingOverlay() {
    if (loadingScreenTimer !== null) {
        clearTimeout(loadingScreenTimer);
        loadingScreenTimer = null;
    }
    const overlay = document.getElementById('loading-screen');
    if (!overlay) return;
    overlay.style.display = 'none';
}

function runWithLoadingOverlay(action, duration = 3000) {
    showLoadingOverlay();
    if (loadingScreenTimer !== null) {
        clearTimeout(loadingScreenTimer);
    }
    loadingScreenTimer = window.setTimeout(() => {
        hideLoadingOverlay();
    }, duration);

    if (typeof action === 'function') {
        requestAnimationFrame(() => {
            try {
                action();
            } catch (error) {
                console.error('World initialization failed:', error);
                hideLoadingOverlay();
                throw error;
            }
        });
    }
}

function hashSeedString(value) {
    let hash = 0;
    for (let i = 0; i < value.length; i++) {
        const charCode = value.charCodeAt(i);
        hash = ((hash << 5) - hash) + charCode;
        hash |= 0; // Keep hash in 32-bit range
    }
    return hash;
}

function activateChunkSpeedBoost() {
    chunkSpeedBoostEndTime = performance.now() + CHUNK_SPEED_BOOST_DURATION_MS;
}

function getTerrainHeight(worldX, worldZ) {
	let height = noise.perlin2(worldX / TERRAIN_SCALE, worldZ / TERRAIN_SCALE); 
	return Math.floor(height * TERRAIN_AMPLITUDE);
}

function getBlock(x, y, z) {
    const floorX = Math.floor(x);
    const floorY = Math.floor(y);
    const floorZ = Math.floor(z);

	const blockKey = `${floorX},${floorY},${floorZ}`;
	if (modifiedBlocks.has(blockKey)) {
		return modifiedBlocks.get(blockKey);
	}
    
    if (floorY <= BEDROCK_LEVEL) {
        const isEven = (floorX + floorZ) % 2 === 0;
        return { color: isEven ? BEDROCK_COLOR_1 : BEDROCK_COLOR_2, type: 'bedrock' };
    }
	const height = getTerrainHeight(floorX, floorZ); 
    if (floorY > height) {
        return null;
    }
	const isEven = (floorX + floorZ) % 2 === 0;
	let color;
    let blockType;
	if (floorY === height) {
		color = SNOW_COLOR;
        blockType = 'snow';
	} else if (floorY > height - 4) {
		color = isEven ? DIRT_COLOR_1 : DIRT_COLOR_2;
        blockType = 'dirt';
	} else {
		color = isEven ? STONE_COLOR_1 : STONE_COLOR_2;
        blockType = 'stone';
	}
	return { color, type: blockType };
}

function getBlockForGeneration(worldX, worldY, worldZ, terrainHeight) {
    const blockKey = `${worldX},${worldY},${worldZ}`;
    if (modifiedBlocks.has(blockKey)) {
        return modifiedBlocks.get(blockKey);
    }

    if (worldY <= BEDROCK_LEVEL) {
        const isEven = (worldX + worldZ) % 2 === 0;
        return { color: isEven ? BEDROCK_COLOR_1 : BEDROCK_COLOR_2, type: 'bedrock' };
    }

    if (terrainHeight === undefined) {
        terrainHeight = getTerrainHeight(worldX, worldZ);
    }

    if (worldY > terrainHeight) {
        return null;
    }

    const isEven = (worldX + worldZ) % 2 === 0;
    if (worldY === terrainHeight) {
        return { color: SNOW_COLOR, type: 'snow' };
    }
    if (worldY > terrainHeight - 4) {
        return { color: isEven ? DIRT_COLOR_1 : DIRT_COLOR_2, type: 'dirt' };
    }
    return { color: isEven ? STONE_COLOR_1 : STONE_COLOR_2, type: 'stone' };
}

function cancelChunkJob(chunkKey) {
    const job = chunkGenerationJobs.get(chunkKey);
    if (!job) return;

    for (const geo of job.geometries) {
        geo.dispose();
    }
    if (job.boxGeometry) {
        job.boxGeometry.dispose();
    }
    chunkGenerationJobs.delete(chunkKey);
}

function createChunkJob(chunkX, chunkZ) {
    const chunkKey = `${chunkX},${chunkZ}`;
    return {
        chunkKey,
        chunkX,
        chunkZ,
        worldXStart: chunkX * CHUNK_SIZE,
        worldZStart: chunkZ * CHUNK_SIZE,
        stage: 'computeHeight',
        x: 0,
        z: 0,
        y: BEDROCK_LEVEL,
        minY: BEDROCK_LEVEL,
        maxY: BEDROCK_LEVEL,
        maxHeight: BEDROCK_LEVEL,
        heightMap: new Array(CHUNK_SIZE * CHUNK_SIZE),
        geometries: [],
        boxGeometry: new THREE.BoxGeometry(0.9999, 0.9999, 0.9999),
        matrix: new THREE.Matrix4()
    };
}

function finalizeChunkJob(job) {
    const chunkKey = job.chunkKey;
    const previousMesh = job.previousMesh || null;

    job.boxGeometry.dispose();
    let chunkMesh = null;

    if (job.geometries.length > 0) {
        const mergedGeometry = BufferGeometryUtils.mergeGeometries(job.geometries, false);
        const material = new THREE.MeshStandardMaterial({ vertexColors: true, metalness: 0, roughness: 1 });
        chunkMesh = new THREE.Mesh(mergedGeometry, material);
        chunkMesh.userData.key = chunkKey;
        scene.add(chunkMesh);
    }

    for (const geo of job.geometries) {
        geo.dispose();
    }

    if (previousMesh) {
        scene.remove(previousMesh);
        if (previousMesh.geometry) {
            previousMesh.geometry.dispose();
        }
        if (previousMesh.material) {
            if (Array.isArray(previousMesh.material)) {
                previousMesh.material.forEach(material => material.dispose());
            } else {
                previousMesh.material.dispose();
            }
        }
    }

    const existing = loadedChunks.get(chunkKey);
    if (existing) {
        existing.mesh = chunkMesh;
        existing.needsRegeneration = false;
    } else {
        loadedChunks.set(chunkKey, { mesh: chunkMesh, needsRegeneration: false });
    }

    chunkGenerationJobs.delete(chunkKey);
}

function processChunkJob(job, stepBudget) {
    let steps = 0;
    while (steps < stepBudget) {
        if (job.stage === 'computeHeight') {
            if (job.z >= CHUNK_SIZE) {
                job.stage = 'generateBlocks';
                job.x = 0;
                job.z = 0;
                job.y = job.minY;
                job.maxY = Math.max(job.maxHeight + 40, job.minY);
                continue;
            }

            const worldX = job.worldXStart + job.x;
            const worldZ = job.worldZStart + job.z;
            const height = getTerrainHeight(worldX, worldZ);
            job.heightMap[job.z * CHUNK_SIZE + job.x] = height;
            if (height > job.maxHeight) {
                job.maxHeight = height;
            }

            job.x++;
            if (job.x >= CHUNK_SIZE) {
                job.x = 0;
                job.z++;
            }

            steps++;
            continue;
        }

        if (job.stage === 'generateBlocks') {
            if (job.x >= CHUNK_SIZE) {
                job.stage = 'finalize';
                continue;
            }

            const worldX = job.worldXStart + job.x;
            const worldZ = job.worldZStart + job.z;
            const worldY = job.y;

            const columnHeight = job.heightMap[job.z * CHUNK_SIZE + job.x];
            const block = getBlockForGeneration(worldX, worldY, worldZ, columnHeight);

            if (block && block !== null) {
                if (!(heldBlock && heldBlock.originalPos.x === worldX && heldBlock.originalPos.y === worldY && heldBlock.originalPos.z === worldZ)) {
                    const left = getBlock(worldX - 1, worldY, worldZ);
                    const right = getBlock(worldX + 1, worldY, worldZ);
                    const up = getBlock(worldX, worldY + 1, worldZ);
                    const down = getBlock(worldX, worldY - 1, worldZ);
                    const forward = getBlock(worldX, worldY, worldZ + 1);
                    const back = getBlock(worldX, worldY, worldZ - 1);

                    if (!(left && right && up && down && forward && back)) {
                        const newGeo = job.boxGeometry.clone();
                        const colorAttr = new THREE.BufferAttribute(new Float32Array(newGeo.attributes.position.count * 3), 3);
                        for (let i = 0; i < colorAttr.count; i++) {
                            colorAttr.setXYZ(i, block.color.r, block.color.g, block.color.b);
                        }
                        newGeo.setAttribute('color', colorAttr);
                        job.matrix.setPosition(worldX + 0.5, worldY + 0.5, worldZ + 0.5);
                        newGeo.applyMatrix4(job.matrix);
                        job.geometries.push(newGeo);
                    }
                }
            }

            job.y++;
            if (job.y > job.maxY) {
                job.y = job.minY;
                job.z++;
                if (job.z >= CHUNK_SIZE) {
                    job.z = 0;
                    job.x++;
                }
            }

            steps++;
            continue;
        }

        if (job.stage === 'finalize') {
            finalizeChunkJob(job);
            return steps;
        }

        return steps;
    }

    return steps;
}

function processChunkGenerationSlice() {
    if (chunkGenerationJobs.size === 0) {
        if (chunkSpeedBoostEndTime !== 0 && performance.now() >= chunkSpeedBoostEndTime) {
            chunkSpeedBoostEndTime = 0;
        }
        return;
    }

    const now = performance.now();
    const boostActive = now < chunkSpeedBoostEndTime;
    if (!boostActive && chunkSpeedBoostEndTime !== 0) {
        chunkSpeedBoostEndTime = 0;
    }

    let stepsRemaining = boostActive ? BOOSTED_CHUNK_STEPS_PER_SLICE : MAX_CHUNK_STEPS_PER_SLICE;

    while (stepsRemaining > 0 && chunkGenerationJobs.size > 0) {
        let jobToProcess = null;
        for (const job of chunkGenerationJobs.values()) {
            jobToProcess = job;
            if (job.isPriority) {
                break;
            }
        }

        if (!jobToProcess) {
            break;
        }

        const used = processChunkJob(jobToProcess, stepsRemaining);
        stepsRemaining -= used;

        if (!chunkGenerationJobs.has(jobToProcess.chunkKey)) {
            continue;
        }

        break;
    }
}

function startChunkGeneration(chunkX, chunkZ, priority = false) {
    const chunkKey = `${chunkX},${chunkZ}`;

    cancelChunkJob(chunkKey);

    const existing = loadedChunks.get(chunkKey);
    let previousMesh = null;
    if (existing && existing.mesh) {
        if (priority) {
            previousMesh = existing.mesh;
        } else {
            unloadChunk(chunkX, chunkZ, false);
        }
    }

    const job = createChunkJob(chunkX, chunkZ);
    job.isPriority = priority;
    job.previousMesh = previousMesh;
    chunkGenerationJobs.set(chunkKey, job);

    if (loadedChunks.has(chunkKey)) {
        const placeholder = loadedChunks.get(chunkKey);
        if (!priority) {
            placeholder.mesh = null;
        }
        placeholder.needsRegeneration = false;
    } else {
        loadedChunks.set(chunkKey, { mesh: null, needsRegeneration: false });
    }
}

function unloadChunk(chunkX, chunkZ, removeFromMap = true) {
    const chunkKey = `${chunkX},${chunkZ}`;

    cancelChunkJob(chunkKey);

    const chunkData = loadedChunks.get(chunkKey);
    if (!chunkData) {
        return;
    }

    if (chunkData.mesh) {
        scene.remove(chunkData.mesh);
        chunkData.mesh.geometry.dispose();
        chunkData.mesh.material.dispose();
    }

    if (removeFromMap) {
        loadedChunks.delete(chunkKey);
    } else {
        chunkData.mesh = null;
    }
}

function updateWorld() {
    if (!playerCube) return;
    const playerChunkX = Math.floor(playerCube.position.x / CHUNK_SIZE);
    const playerChunkZ = Math.floor(playerCube.position.z / CHUNK_SIZE);

    for (const [key, chunkData] of loadedChunks.entries()) {
        if (chunkData.needsRegeneration) {
            const [cx, cz] = key.split(',').map(Number);
            chunkData.needsRegeneration = false;
            startChunkGeneration(cx, cz, true);
            return;
        }
    }

    if (chunkGenerationQueue.size > 0) {
        const key = chunkGenerationQueue.values().next().value;
        chunkGenerationQueue.delete(key);
        const [cx, cz] = key.split(',').map(Number);
        startChunkGeneration(cx, cz);
        return;
    }

    if (currentPlayerChunkX === playerChunkX && currentPlayerChunkZ === playerChunkZ) return;
    currentPlayerChunkX = playerChunkX;
    currentPlayerChunkZ = playerChunkZ;

    for (let x = playerChunkX - RENDER_DISTANCE; x <= playerChunkX + RENDER_DISTANCE; x++) {
        for (let z = playerChunkZ - RENDER_DISTANCE; z <= playerChunkZ + RENDER_DISTANCE; z++) {
            const chunkKey = `${x},${z}`;
            if (!loadedChunks.has(chunkKey)) {
                chunkGenerationQueue.add(chunkKey);
            }
        }
    }

    for (const [key] of loadedChunks.entries()) {
        const [cx, cz] = key.split(',').map(Number);
        if (Math.abs(cx - playerChunkX) > RENDER_DISTANCE + 1 || Math.abs(cz - playerChunkZ) > RENDER_DISTANCE + 1) {
            unloadChunk(cx, cz);
        }
    }
}

function markChunkForRegeneration(worldX, worldZ) {
    const chunkX = Math.floor(worldX / CHUNK_SIZE);
    const chunkZ = Math.floor(worldZ / CHUNK_SIZE);
    const chunkKey = `${chunkX},${chunkZ}`;
    const chunk = loadedChunks.get(chunkKey);
    if (chunk) {
        chunk.needsRegeneration = true;
    }

    if (chunkGenerationJobs.has(chunkKey)) {
        cancelChunkJob(chunkKey);
    }

    const localX = worldX - chunkX * CHUNK_SIZE;
    const localZ = worldZ - chunkZ * CHUNK_SIZE;

    if (localX === 0) {
        const neighborChunk = loadedChunks.get(`${chunkX - 1},${chunkZ}`);
        if (neighborChunk) {
            neighborChunk.needsRegeneration = true;
            if (chunkGenerationJobs.has(`${chunkX - 1},${chunkZ}`)) {
                cancelChunkJob(`${chunkX - 1},${chunkZ}`);
            }
        }
    } else if (localX === CHUNK_SIZE - 1) {
        const neighborChunk = loadedChunks.get(`${chunkX + 1},${chunkZ}`);
        if (neighborChunk) {
            neighborChunk.needsRegeneration = true;
            if (chunkGenerationJobs.has(`${chunkX + 1},${chunkZ}`)) {
                cancelChunkJob(`${chunkX + 1},${chunkZ}`);
            }
        }
    }

    if (localZ === 0) {
        const neighborChunk = loadedChunks.get(`${chunkX},${chunkZ - 1}`);
        if (neighborChunk) {
            neighborChunk.needsRegeneration = true;
            if (chunkGenerationJobs.has(`${chunkX},${chunkZ - 1}`)) {
                cancelChunkJob(`${chunkX},${chunkZ - 1}`);
            }
        }
    } else if (localZ === CHUNK_SIZE - 1) {
        const neighborChunk = loadedChunks.get(`${chunkX},${chunkZ + 1}`);
        if (neighborChunk) {
            neighborChunk.needsRegeneration = true;
            if (chunkGenerationJobs.has(`${chunkX},${chunkZ + 1}`)) {
                cancelChunkJob(`${chunkX},${chunkZ + 1}`);
            }
        }
    }
}



function fireSphere() {
    const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
    const projectileMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffa500,
        emissive: 0xffa500, 
        emissiveIntensity: 1.0,
        metalness: 0,
        roughness: 0.5
    });
    const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    direction.normalize(); // Ensure the direction vector is a unit vector
    const startPosition = new THREE.Vector3();
    camera.getWorldPosition(startPosition);
    projectile.position.copy(startPosition).add(direction.clone().multiplyScalar(0.5));
    const velocity = direction.clone().multiplyScalar(PROJECTILE_SPEED);
    projectiles.push({ mesh: projectile, velocity: velocity });
    scene.add(projectile);
}

function fireMissile() {
    const missileGroup = new THREE.Group();
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.4 });
    const tipMaterial = new THREE.MeshStandardMaterial({ color: 0xcc3333, metalness: 0.4, roughness: 0.5 });
    const finMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.6, roughness: 0.4 });
    const bodyLength = 0.7;
    const bodyRadius = 0.08;
    const bodyGeometry = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyLength, 10);
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0;
    missileGroup.add(body);
    const tipHeight = 0.2;
    const tipGeometry = new THREE.ConeGeometry(bodyRadius, tipHeight, 10);
    const tip = new THREE.Mesh(tipGeometry, tipMaterial);
    tip.position.y = (bodyLength / 2) + (tipHeight / 2);
    missileGroup.add(tip);
    const finWidth = 0.2; 
    const finHeight = 0.15;
    const finThickness = 0.02;
    const finGeometry = new THREE.BoxGeometry(finWidth, finHeight, finThickness);
    const fin1 = new THREE.Mesh(finGeometry, finMaterial);
    fin1.rotation.y = Math.PI / 2;
    fin1.position.set(bodyRadius + finHeight / 2, -bodyLength / 2 + finWidth / 2, 0);
    missileGroup.add(fin1);
    const fin2 = new THREE.Mesh(finGeometry, finMaterial);
    fin2.rotation.y = Math.PI / 2;
    fin2.position.set(-(bodyRadius + finHeight / 2), -bodyLength / 2 + finWidth / 2, 0);
    missileGroup.add(fin2);
    const fin3 = new THREE.Mesh(finGeometry, finMaterial);
    fin3.position.set(0, -bodyLength / 2 + finWidth / 2, bodyRadius + finHeight / 2);
    missileGroup.add(fin3);
    const fin4 = new THREE.Mesh(finGeometry, finMaterial);
    fin4.position.set(0, -bodyLength / 2 + finWidth / 2, -(bodyRadius + finHeight / 2));
    missileGroup.add(fin4);
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    const startPosition = new THREE.Vector3();
    camera.getWorldPosition(startPosition);
    missileGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
    missileGroup.position.copy(startPosition).add(direction.clone().multiplyScalar(0.7));
    const velocity = direction.clone().multiplyScalar(MISSILE_SPEED);
    missiles.push({ mesh: missileGroup, velocity: velocity, lifetime: 0 });
    scene.add(missileGroup);
}

function handleWallPlacement() {
    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    if (meshes.length === 0) return;
    
    const mouse = new THREE.Vector2(0, 0);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(meshes);
    
    if (intersects.length > 0) {
        const intersect = intersects[0];
        const adjacentBlockPos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.01));
        const clickX = Math.floor(adjacentBlockPos.x);
        const clickY = Math.floor(adjacentBlockPos.y);
        const clickZ = Math.floor(adjacentBlockPos.z);
        
        if (!wallCorner1) {
            // First corner of the fill region
            wallCorner1 = { x: clickX, y: clickY, z: clickZ };
            createLaserFlash(new THREE.Vector3(clickX + 0.5, clickY + 0.5, clickZ + 0.5));
        } else if (!wallCorner2) {
            // Second corner - draw the filled volume
            wallCorner2 = { x: clickX, y: clickY, z: clickZ };
            createLaserFlash(new THREE.Vector3(clickX + 0.5, clickY + 0.5, clickZ + 0.5));
            
            // Draw fill between the two corners
            drawWall(wallCorner1, wallCorner2);
            
            // Reset for next fill placement
            wallCorner1 = null;
            wallCorner2 = null;
        }
    }
}

function drawWall(corner1, corner2) {
    const minX = Math.min(corner1.x, corner2.x);
    const maxX = Math.max(corner1.x, corner2.x);
    const minY = Math.min(corner1.y, corner2.y);
    const maxY = Math.max(corner1.y, corner2.y);
    const minZ = Math.min(corner1.z, corner2.z);
    const maxZ = Math.max(corner1.z, corner2.z);
    
    const affectedChunks = new Set();
    
    // Fill the rectangular volume between the two corners
    for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
            for (let z = minZ; z <= maxZ; z++) {
                const blockKey = `${x},${y},${z}`;
                modifiedBlocks.set(blockKey, { color: new THREE.Color(currentColor), type: 'normal' });
                affectedChunks.add(`${Math.floor(x / CHUNK_SIZE)},${Math.floor(z / CHUNK_SIZE)}`);
            }
        }
    }
    
    // Regenerate all affected chunks
    for (const chunkKey of affectedChunks) {
        const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
        markChunkForRegeneration(chunkX * CHUNK_SIZE, chunkZ * CHUNK_SIZE);
    }
}

function handleSphereCreation() {
    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    if (meshes.length === 0) return;
    
    const mouse = new THREE.Vector2(0, 0);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(meshes);
    
    if (intersects.length > 0) {
        const intersect = intersects[0];
        const adjacentBlockPos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.01));
        const centerX = Math.floor(adjacentBlockPos.x);
        const centerY = Math.floor(adjacentBlockPos.y);
        const centerZ = Math.floor(adjacentBlockPos.z);
        
        createLaserFlash(new THREE.Vector3(centerX + 0.5, centerY + 0.5, centerZ + 0.5));
        drawSphere(centerX, centerY, centerZ, SPHERE_RADIUS);
    }
}

function drawSphere(centerX, centerY, centerZ, radius) {
    const affectedChunks = new Set();
    const radiusSquared = radius * radius;
    
    // Iterate through a bounding box around the sphere
    for (let x = centerX - radius; x <= centerX + radius; x++) {
        for (let y = centerY - radius; y <= centerY + radius; y++) {
            for (let z = centerZ - radius; z <= centerZ + radius; z++) {
                // Calculate distance from center
                const dx = x - centerX;
                const dy = y - centerY;
                const dz = z - centerZ;
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                
                // Only place blocks within the sphere radius
                if (distanceSquared <= radiusSquared) {
                    const blockKey = `${x},${y},${z}`;
                    modifiedBlocks.set(blockKey, { color: new THREE.Color(currentColor), type: 'normal' });
                    affectedChunks.add(`${Math.floor(x / CHUNK_SIZE)},${Math.floor(z / CHUNK_SIZE)}`);
                }
            }
        }
    }
    
    // Regenerate all affected chunks
    for (const chunkKey of affectedChunks) {
        const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
        markChunkForRegeneration(chunkX * CHUNK_SIZE, chunkZ * CHUNK_SIZE);
    }
}

function performAction() {
    if (!hasGun) return; // No actions before picking up the gun
    if (currentMode === 'toolgun') {
        if (heldBlock) {
            placeBlock();
        } else {
            pickupBlock();
        }
        return;
    }

    if (currentMode === BEDROCK_PLACE_MODE && !bedrockModesEnabled) {
        return;
    }

    if (currentMode === 'shoot') {
        fireSphere();
        return;
    }
    if (currentMode === 'missile') {
        fireMissile();
        return;
    }
    if (currentMode === JUMP_PAD_MODE) {
        placeJumpPad();
        return;
    }
    
    // Handle fill mode (draw volume between two corners)
    if (currentMode === 'fill') {
        handleWallPlacement();
        return;
    }
    
    // Handle sphere mode (create sphere at clicked location)
    if (currentMode === 'sphere') {
        handleSphereCreation();
        return;
    }

	const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
	if (meshes.length === 0) return;
	
    const mouse = new THREE.Vector2(0, 0);
	raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(meshes);

	if (intersects.length > 0) {
		const intersect = intersects[0];
		let finalX, finalY, finalZ;
		const isPlacementMode = currentMode === 'add' || currentMode === BEDROCK_PLACE_MODE;

        if (isPlacementMode) {
			const adjacentBlockPos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.01));
			[finalX, finalY, finalZ] = [Math.floor(adjacentBlockPos.x), Math.floor(adjacentBlockPos.y), Math.floor(adjacentBlockPos.z)];

            const halfWidth = playerWidth / 2;
            const playerMinX = Math.floor(playerCube.position.x - halfWidth);
            const playerMaxX = Math.floor(playerCube.position.x + halfWidth);
            const playerMinY = Math.floor(playerCube.position.y);
            const playerMaxY = Math.floor(playerCube.position.y + playerHeight);
            const playerMinZ = Math.floor(playerCube.position.z - halfWidth);
            const playerMaxZ = Math.floor(playerCube.position.z + halfWidth);

            if (finalX >= playerMinX && finalX <= playerMaxX && 
                finalY >= playerMinY && finalY <= playerMaxY && 
                finalZ >= playerMinZ && finalZ <= playerMaxZ) {
                return; 
            }

            const blockKey = `${finalX},${finalY},${finalZ}`;
            if (currentMode === BEDROCK_PLACE_MODE) {
                const bedrockColor = (bedrockPlacementToggle ? BEDROCK_COLOR_1 : BEDROCK_COLOR_2).clone();
                modifiedBlocks.set(blockKey, { color: bedrockColor, type: 'bedrock' });
                bedrockPlacementToggle = !bedrockPlacementToggle;
            } else {
			    modifiedBlocks.set(blockKey, { color: new THREE.Color(currentColor), type: 'normal' });
            }
            markChunkForRegeneration(finalX, finalZ);
            createLaserFlash(new THREE.Vector3(finalX + 0.5, finalY + 0.5, finalZ + 0.5));

		} else if (currentMode === 'remove') { 
            const blockPos = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.01));
            [finalX, finalY, finalZ] = [Math.floor(blockPos.x), Math.floor(blockPos.y), Math.floor(blockPos.z)];

            const block = getBlock(finalX, finalY, finalZ);
            if (block && (block.type !== 'bedrock' || bedrockModesEnabled)) {
                modifiedBlocks.set(`${finalX},${finalY},${finalZ}`, null);
                markChunkForRegeneration(finalX, finalZ);
                spawnBlockRemovalParticles(new THREE.Vector3(finalX + 0.5, finalY + 0.5, finalZ + 0.5), block.color);
            }
        }
	}
}

function onMouseDown(event) {
    if (!isMobileDevice && document.pointerLockElement !== renderer.domElement) return;
    
    if (event.preventDefault) event.preventDefault();

    if (event.button === 0) {
        if (currentMode === 'toolgun') {
            isToolgunActive = true; 
            pickupBlock(); 
        } else {
            performAction(); 
        }
    }
    else if (event.button === 2) {
        isAiming = true;
    }
}

function onMouseUp(event) {
    if (isMobileDevice) return; 
    
    if (event.preventDefault) event.preventDefault();

    if (event.button === 0) {
        if (currentMode === 'toolgun') {
            isToolgunActive = false; 
            placeBlock(); 
        }
    }
    else if (event.button === 2) {
        isAiming = false;
    }
}

function init(seedString, explicitSeedValue = null, seedSourceOverride = null) {
    activateChunkSpeedBoost();
    isMobileDevice = isMobile(); 

    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    if (toolgunLaser) {
        scene.remove(toolgunLaser);
        toolgunLaser.geometry.dispose();
        toolgunLaser.material.dispose();
        toolgunLaser = null;
    }
    if (heldBlock) {
        if (heldBlock.glowMesh) {
            heldBlock.mesh.remove(heldBlock.glowMesh); 
            heldBlock.glowMesh.geometry.dispose();
            heldBlock.glowMesh.material.dispose();
        }
        scene.remove(heldBlock.mesh);
        heldBlock.mesh.geometry.dispose();
        heldBlock.mesh.material.dispose();
        heldBlock = null;
    }

    if (renderer) {
        document.body.removeChild(renderer.domElement);
        renderer.dispose();
    }
    if (scene) {
        scene.traverse(object => {
             // Dispose lights properly
            if (object.isLight) {
                 if (object.dispose) object.dispose();
            }
            if (object.isMesh) {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            }
        });
        while(scene.children.length > 0){ 
            scene.remove(scene.children[0]); 
        }
    }
    chunkGenerationQueue.clear();
    for (const key of Array.from(chunkGenerationJobs.keys())) {
        cancelChunkJob(key);
    }
    chunkGenerationJobs.clear();
    loadedChunks.clear();
    modifiedBlocks.clear(); 
    // Dispose jump pads
    for (const pad of jumpPads) {
        if (pad.mesh) {
            scene.remove(pad.mesh);
            if (pad.mesh.geometry) pad.mesh.geometry.dispose();
            if (pad.mesh.material) pad.mesh.material.dispose();
        }
    }
    jumpPads = [];
    projectiles = [];
    missiles = [];
    explosions = [];
    laserFlashes = [];
    for (const particle of blockRemovalParticles) {
        if (particle.sprite && particle.sprite.parent) {
            particle.sprite.parent.remove(particle.sprite);
        }
        if (particle.sprite && particle.sprite.material) {
            particle.sprite.material.dispose();
        }
    }
    blockRemovalParticles = [];
    currentPlayerChunkX = undefined;
    currentPlayerChunkZ = undefined;
    
    // Reset gun state at start
    hasGun = false;
    if (gunPickup) {
        scene.remove(gunPickup);
        gunPickup.traverse(obj => { if (obj.isMesh) { obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose(); } } });
        gunPickup = null;
    }
 
    const hasExplicitSeedValue = explicitSeedValue !== null && explicitSeedValue !== undefined && !Number.isNaN(explicitSeedValue);
    let normalizedSeedString = "";
    if (typeof seedString === 'string') {
        normalizedSeedString = seedString;
    } else if (seedString !== undefined && seedString !== null) {
        normalizedSeedString = String(seedString);
    }
    const trimmedSeed = normalizedSeedString.trim();
    let seedValue;

    if (hasExplicitSeedValue) {
        seedValue = explicitSeedValue;
        worldSeedString = trimmedSeed !== "" ? normalizedSeedString : seedValue.toString();
        worldSeedSource = seedSourceOverride || (trimmedSeed === "" ? 'random' : 'manual');
    } else if (trimmedSeed !== "") {
        const numericCandidate = Number(trimmedSeed);
        const shouldUseNumeric = seedSourceOverride === 'random' || (trimmedSeed.startsWith('0.') && !Number.isNaN(numericCandidate));
        if (shouldUseNumeric && !Number.isNaN(numericCandidate)) {
            seedValue = numericCandidate;
            worldSeedSource = 'random';
        } else {
            seedValue = hashSeedString(normalizedSeedString);
            worldSeedSource = seedSourceOverride || 'manual';
        }
        worldSeedString = normalizedSeedString;
    } else {
        seedValue = Math.random();
        worldSeedString = seedValue.toString();
        worldSeedSource = 'random';
    }

    worldSeedValue = seedValue;
    noise = new Noise(seedValue);

	scene = new THREE.Scene();
	scene.background = new THREE.Color(0x87CEEB);
	scene.fog = new THREE.Fog(0x87CEEB, RENDER_DISTANCE * CHUNK_SIZE / 2, RENDER_DISTANCE * CHUNK_SIZE);
    
    const farPlane = (RENDER_DISTANCE + 2) * CHUNK_SIZE;
    let aspect = window.innerWidth / window.innerHeight;
    let width = window.innerWidth;
    let height = window.innerHeight;

    if (!isMobileDevice) {
        width = 805;
        height = 500;
        aspect = width / height;
    }
	camera = new THREE.PerspectiveCamera(75, aspect, 0.1, farPlane);

	renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize(width, height);
	document.body.appendChild(renderer.domElement);

	const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
	scene.add(ambientLight);
	const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
	directionalLight.position.set(50, 50, 25);
	scene.add(directionalLight);

	raycaster = new THREE.Raycaster();
    projectileRaycaster = new THREE.Raycaster();

	createPlayer(); 
    // Hide modes until gun is picked up
    updateModeButtons();
    updateModeUIVisibility();
    // Spawn a pickup in front of the player on the ground
    spawnGunPickup();
	updateWorld();

	setupEventListeners();
    lastPlayerPos.copy(playerCube.position); 
	animate(); 
}

function createPlayer() {
	const startY = getTerrainHeight(0, 0) + 5; 
	const geometry = new THREE.BoxGeometry(playerWidth, playerHeight, playerWidth);
    geometry.translate(0, playerHeight / 2, 0); 
	const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, visible: false });
	playerCube = new THREE.Mesh(geometry, material);
	playerCube.position.set(0, startY, 0);
    playerSpawnPoint.copy(playerCube.position);
	scene.add(playerCube);

	camera.position.set(0, 1.4, 0); 
	playerCube.add(camera);

    // Do not attach rifle yet; it will be picked up
    rifle = null;

    lastPlayerPos.copy(playerCube.position);
}

function createRifle() {
    const rifleGroup = new THREE.Group();
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222228, metalness: 0.2, roughness: 0.6 });
    const metalMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.4 });
    const emissiveMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1.5 });
    const bodyGeo = new THREE.BoxGeometry(0.7, 0.2, 0.15);
    const body = new THREE.Mesh(bodyGeo, bodyMaterial);
    body.position.set(0, 0, 0);
    rifleGroup.add(body);
    const stockBarGeo = new THREE.BoxGeometry(0.4, 0.05, 0.05);
    const stockBar = new THREE.Mesh(stockBarGeo, metalMaterial);
    stockBar.position.set(-0.45, 0.05, 0);
    rifleGroup.add(stockBar);
    const stockPadGeo = new THREE.BoxGeometry(0.1, 0.2, 0.12);
    const stockPad = new THREE.Mesh(stockPadGeo, bodyMaterial);
    stockPad.position.set(-0.6, 0.0, 0);
    rifleGroup.add(stockPad);

    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.4 });
    const barrelGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.9, 12);
    const barrel = new THREE.Mesh(barrelGeo, barrelMaterial);
    barrel.rotation.z = Math.PI / 2;
    barrel.position.set(0.8, 0.05, 0);
    rifleGroup.add(barrel);
    rifleGroup.barrel = barrel; 

    const muzzleGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.15, 6);
    const muzzle = new THREE.Mesh(muzzleGeo, metalMaterial);
    muzzle.rotation.z = Math.PI / 2;
    muzzle.position.set(1.3, 0.05, 0);
    rifleGroup.add(muzzle);
    const handguardShape = new THREE.Shape();
    handguardShape.moveTo(0, 0);
    handguardShape.lineTo(0.6, 0);
    handguardShape.lineTo(0.6, -0.05);
    handguardShape.lineTo(0.5, -0.15);
    handguardShape.lineTo(0, -0.15);
    handguardShape.lineTo(0, 0);
    const extrudeSettings = { depth: 0.16, bevelEnabled: false };
    const handguardGeo = new THREE.ExtrudeGeometry(handguardShape, extrudeSettings);
    const handguard = new THREE.Mesh(handguardGeo, bodyMaterial);
    handguard.position.set(0.35, 0.1, -0.08);
    rifleGroup.add(handguard);
    const gripGeo = new THREE.BoxGeometry(0.12, 0.4, 0.12);
    const grip = new THREE.Mesh(gripGeo, bodyMaterial);
    grip.position.set(-0.1, -0.2, 0);
    grip.rotation.z = 0.2; 
    rifleGroup.add(grip);
    const magGeo = new THREE.BoxGeometry(0.15, 0.35, 0.12);
    const mag = new THREE.Mesh(magGeo, bodyMaterial);
    mag.position.set(0.15, -0.25, 0);
    rifleGroup.add(mag);
    const emissiveStripGeo = new THREE.BoxGeometry(0.02, 0.3, 0.13);
    const emissiveStrip = new THREE.Mesh(emissiveStripGeo, emissiveMaterial);
    emissiveStrip.position.set(0.23, -0.25, 0);
    rifleGroup.add(emissiveStrip);
    const sightBaseGeo = new THREE.BoxGeometry(0.25, 0.05, 0.12);
    const sightBase = new THREE.Mesh(sightBaseGeo, metalMaterial);
    sightBase.position.set(0.1, 0.2, 0);
    rifleGroup.add(sightBase);
    const sightHousingGeo = new THREE.BoxGeometry(0.05, 0.15, 0.1);
    const sightHousing = new THREE.Mesh(sightHousingGeo, metalMaterial);
    sightHousing.position.set(0.2, 0.25, 0);
    rifleGroup.add(sightHousing);
    const sightEmissiveGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02);
    const sightEmissive = new THREE.Mesh(sightEmissiveGeo, emissiveMaterial);
    sightEmissive.position.set(0.2, 0.18, 0);
    rifleGroup.add(sightEmissive);
    return rifleGroup;
}

function createLaserFlash(targetPosition) {
    if (!rifle) return;

    const laserGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8); 
    const laserMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00FFFF, 
        transparent: true, 
        opacity: 0.7,
        blending: THREE.AdditiveBlending
    });
    const laserMesh = new THREE.Mesh(laserGeo, laserMaterial);

    const laserStart = new THREE.Vector3(1.3, 0.05, 0); 
    rifle.updateWorldMatrix(true, false); 
    laserStart.applyMatrix4(rifle.matrixWorld); 
    const laserEnd = targetPosition;
    
    const distance = laserStart.distanceTo(laserEnd);
    laserMesh.scale.y = distance; 
    laserMesh.position.copy(laserStart).add(laserEnd).multiplyScalar(0.5); 
    laserMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), laserEnd.clone().sub(laserStart).normalize()); 

    scene.add(laserMesh);
    laserFlashes.push({ mesh: laserMesh, timer: LASER_FLASH_DURATION });
}

function spawnBlockRemovalParticles(position, color, count = 6) {
    if (!scene) return;

    const baseColor = (color && color.isColor) ? color.clone() : new THREE.Color(color || 0xffffff);

    for (let i = 0; i < count; i++) {
        const material = new THREE.SpriteMaterial({
            color: baseColor.clone(),
            transparent: true,
            opacity: THREE.MathUtils.randFloat(0.65, 0.95),
            blending: THREE.AdditiveBlending
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        const scale = THREE.MathUtils.randFloat(0.18, 0.38);
        sprite.scale.set(scale, scale, scale);

        const angle = Math.random() * Math.PI * 2;
        const horiz = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        const speed = THREE.MathUtils.randFloat(1.6, 3.2);
        const velocity = horiz.multiplyScalar(speed);
        velocity.y = THREE.MathUtils.randFloat(0.8, 2.3);

        blockRemovalParticles.push({
            sprite,
            velocity,
            life: 0,
            lifetime: THREE.MathUtils.randFloat(0.45, 0.75),
            startOpacity: material.opacity,
            startScale: scale
        });

        scene.add(sprite);
    }

    if (blockRemovalParticles.length > MAX_BLOCK_REMOVAL_PARTICLES) {
        const excess = blockRemovalParticles.length - MAX_BLOCK_REMOVAL_PARTICLES;
        for (let i = 0; i < excess; i++) {
            const particle = blockRemovalParticles.shift();
            if (!particle) break;
            scene.remove(particle.sprite);
            particle.sprite.material.dispose();
        }
    }
}

function updateBlockRemovalParticles(deltaTime) {
    for (let i = blockRemovalParticles.length - 1; i >= 0; i--) {
        const particle = blockRemovalParticles[i];
        particle.life += deltaTime;
        particle.velocity.y -= 4.5 * deltaTime;
        particle.sprite.position.addScaledVector(particle.velocity, deltaTime);

        const progress = particle.life / particle.lifetime;
        particle.sprite.material.opacity = particle.startOpacity * Math.max(0, 1 - progress);
        const currentScale = THREE.MathUtils.lerp(particle.startScale, particle.startScale * 0.25, THREE.MathUtils.clamp(progress, 0, 1));
        particle.sprite.scale.set(currentScale, currentScale, currentScale);

        if (particle.life >= particle.lifetime) {
            scene.remove(particle.sprite);
            particle.sprite.material.dispose();
            blockRemovalParticles.splice(i, 1);
        }
    }
}


function createExplosion(position) {
    const geometry = new THREE.SphereGeometry(MISSILE_EXPLOSION_RADIUS, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.8 });
    const explosionMesh = new THREE.Mesh(geometry, material);
    explosionMesh.position.copy(position);
    scene.add(explosionMesh);
    explosions.push({ mesh: explosionMesh, timer: MISSILE_EXPLOSION_DURATION });

    if (playerCube && !isFlying) {
        const playerPos = playerCube.position.clone().add(new THREE.Vector3(0, playerHeight / 2, 0)); 
        const explosionPos = position;
        const distance = playerPos.distanceTo(explosionPos);
        const radius = MISSILE_EXPLOSION_RADIUS + (playerWidth / 2); 

        if (distance < radius) {
            const knockbackDir = playerPos.clone().sub(explosionPos).normalize();
            
            const forceFalloff = 1 - (distance / radius); 
            const finalForce = MISSILE_KNOCKBACK_FORCE * forceFalloff;

            if (knockbackDir.y < 0.3) {
                knockbackDir.y = 0.3;
                knockbackDir.normalize();
            }

            playerVelocity.add(knockbackDir.multiplyScalar(finalForce));
            playerOnGround = false; 
        }
    }

    const chunksToUpdate = new Set();
    const radius = MISSILE_EXPLOSION_RADIUS;
    const cX = Math.floor(position.x);
    const cY = Math.floor(position.y);
    const cZ = Math.floor(position.z);
    let explosionParticlesSpawned = 0;
    const MAX_EXPLOSION_PARTICLES = 90;
    for (let x = -radius; x <= radius; x++) {
        for (let y = -radius; y <= radius; y++) {
            for (let z = -radius; z <= radius; z++) {
                const pX = cX + x;
                const pY = cY + y;
                const pZ = cZ + z;
                const distSq = x*x + y*y + z*z;
                if (distSq <= radius * radius) {
                    const block = getBlock(pX, pY, pZ);
                    if (block && block.type !== 'bedrock') {
                        if (explosionParticlesSpawned < MAX_EXPLOSION_PARTICLES && Math.random() < 0.35) {
                            const spawnCount = 3;
                            spawnBlockRemovalParticles(new THREE.Vector3(pX + 0.5, pY + 0.5, pZ + 0.5), block.color, spawnCount);
                            explosionParticlesSpawned += spawnCount;
                        }
                        modifiedBlocks.set(`${pX},${pY},${pZ}`, null);
                        const chunkX = Math.floor(pX / CHUNK_SIZE);
                        const chunkZ = Math.floor(pZ / CHUNK_SIZE);
                        chunksToUpdate.add(`${chunkX},${chunkZ}`);
                        
                        const localX = pX - chunkX * CHUNK_SIZE;
                        const localZ = pZ - chunkZ * CHUNK_SIZE;
                        if (localX === 0) chunksToUpdate.add(`${chunkX - 1},${chunkZ}`);
                        if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(`${chunkX + 1},${chunkZ}`);
                        if (localZ === 0) chunksToUpdate.add(`${chunkX},${chunkZ - 1}`);
                        if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(`${chunkX},${chunkZ + 1}`);
                    }
                }
            }
        }
    }
    for (const chunkKey of chunksToUpdate) {
        const chunk = loadedChunks.get(chunkKey);
        if (chunk) {
            chunk.needsRegeneration = true;
        }
    }

    // Destroy any jump pads within explosion radius (XZ circle + vertical allowance)
    if (jumpPads.length > 0) {
        for (let i = jumpPads.length - 1; i >= 0; i--) {
            const pad = jumpPads[i];
            const padCenter = new THREE.Vector3(pad.x + 0.5, pad.y + JUMP_PAD_HEIGHT / 2, pad.z + 0.5);
            const horizDistSq = (padCenter.x - position.x) * (padCenter.x - position.x) + (padCenter.z - position.z) * (padCenter.z - position.z);
            if (horizDistSq <= (MISSILE_EXPLOSION_RADIUS + JUMP_PAD_SIZE * 0.5) * (MISSILE_EXPLOSION_RADIUS + JUMP_PAD_SIZE * 0.5)) {
                if (Math.abs(padCenter.y - position.y) <= MISSILE_EXPLOSION_RADIUS + 1.0) {
                    scene.remove(pad.mesh);
                    if (pad.mesh.geometry) pad.mesh.geometry.dispose();
                    if (pad.mesh.material) pad.mesh.material.dispose();
                    jumpPads.splice(i, 1);
                }
            }
        }
    }
}

function updateProjectiles(deltaTime) {
    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        const pMesh = projectile.mesh;

        const oldPosition = pMesh.position.clone();
        pMesh.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
        const newPosition = pMesh.position;

        const distance = oldPosition.distanceTo(newPosition);
        if (distance === 0) {
            projectiles.splice(i, 1);
            scene.remove(pMesh);
            pMesh.geometry.dispose();
            pMesh.material.dispose();
            continue;
        };

        const direction = newPosition.clone().sub(oldPosition).normalize();
        projectileRaycaster.set(oldPosition, direction);
        projectileRaycaster.far = distance;

        let hit = false;
        if (meshes.length > 0) {
            const intersects = projectileRaycaster.intersectObjects(meshes);
            if (intersects.length > 0) {
                hit = true;
                const intersect = intersects[0];
                const blockPos = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.01));
                const [pX, pY, pZ] = [Math.floor(blockPos.x), Math.floor(blockPos.y), Math.floor(blockPos.z)];

                const block = getBlock(pX, pY, pZ);
                if (block && (block.type !== 'bedrock' || bedrockModesEnabled)) {
                    modifiedBlocks.set(`${pX},${pY},${pZ}`, null);
                    markChunkForRegeneration(pX, pZ);
                    spawnBlockRemovalParticles(new THREE.Vector3(pX + 0.5, pY + 0.5, pZ + 0.5), block.color);
                }
            }
        }

        // Also check for jump pad hits along the projectile path
        if (!hit && jumpPads.length > 0) {
            const dir = newPosition.clone().sub(oldPosition).normalize();
            const segLen = distance;
            // simple sphere overlap per pad for thickness; treat as 0.75 radius in XZ
            for (let j = jumpPads.length - 1; j >= 0; j--) {
                const pad = jumpPads[j];
                const padCenter = new THREE.Vector3(pad.x + 0.5, pad.y + JUMP_PAD_HEIGHT / 2, pad.z + 0.5);
                // Ray-segment to AABB intersection would be ideal; approximate with horizontal distance
                // Project pad center onto segment
                const w = padCenter.clone().sub(oldPosition);
                const t = THREE.MathUtils.clamp(w.dot(dir), 0, segLen);
                const closest = oldPosition.clone().addScaledVector(dir, t);
                const dx = Math.abs(closest.x - padCenter.x);
                const dz = Math.abs(closest.z - padCenter.z);
                const dy = Math.abs(closest.y - padCenter.y);
                const withinXZ = (dx <= JUMP_PAD_SIZE * 0.5) && (dz <= JUMP_PAD_SIZE * 0.5);
                const withinY = dy <= (JUMP_PAD_HEIGHT * 1.2);
                if (withinXZ && withinY) {
                    // destroy pad
                    scene.remove(pad.mesh);
                    if (pad.mesh.geometry) pad.mesh.geometry.dispose();
                    if (pad.mesh.material) pad.mesh.material.dispose();
                    jumpPads.splice(j, 1);
                    hit = true; // stop projectile
                    break;
                }
            }
        }

        if (hit || oldPosition.distanceTo(playerCube.position) > 200) {
            scene.remove(pMesh);
            pMesh.geometry.dispose();
            pMesh.material.dispose();
            projectiles.splice(i, 1);
        }
    }
}

function updateMissiles(deltaTime) {
    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    for (let i = missiles.length - 1; i >= 0; i--) {
        const missile = missiles[i];
        const mMesh = missile.mesh;
        missile.lifetime += deltaTime;
        const oldPosition = mMesh.position.clone();
        mMesh.position.add(missile.velocity.clone().multiplyScalar(deltaTime));
        const newPosition = mMesh.position;
        const distance = oldPosition.distanceTo(newPosition);
        if (distance === 0) continue; 
        const direction = newPosition.clone().sub(oldPosition).normalize();
        projectileRaycaster.set(oldPosition, direction);
        projectileRaycaster.far = distance;
        let hit = false;
        let hitPosition = null;
        if (meshes.length > 0) {
            const intersects = projectileRaycaster.intersectObjects(meshes);
            if (intersects.length > 0) {
                hitPosition = intersects[0].point.clone();
                hit = true;
            }
        }
        if (hit || missile.lifetime > 10.0) {
            createExplosion(hitPosition || newPosition);
            scene.remove(mMesh);
            mMesh.traverse((child) => {
                if (child.isMesh) {
                    child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
            missiles.splice(i, 1);
        }
    }
}

function updateExplosions(deltaTime) {
    for (let i = explosions.length - 1; i >= 0; i--) {
        const explosion = explosions[i];
        explosion.timer -= deltaTime;
        if (explosion.mesh.material.opacity > 0) {
            explosion.mesh.material.opacity = (explosion.timer / MISSILE_EXPLOSION_DURATION) * 0.8;
        }
        if (explosion.timer <= 0) {
            scene.remove(explosion.mesh);
            explosion.mesh.geometry.dispose();
            explosion.mesh.material.dispose();
            explosions.splice(i, 1);
        }
    }
}

function updateLaserFlashes(deltaTime) {
    for (let i = laserFlashes.length - 1; i >= 0; i--) {
        const flash = laserFlashes[i];
        flash.timer -= deltaTime;
        
        const fade = Math.max(0, flash.timer / LASER_FLASH_DURATION);
        flash.mesh.material.opacity = fade * 0.7;

        if (flash.timer <= 0) {
            scene.remove(flash.mesh);
            flash.mesh.geometry.dispose();
            flash.mesh.material.dispose();
            laserFlashes.splice(i, 1);
        }
    }
}



function checkCollision(pos) {
    if (isFlying) return false;
	const halfWidth = playerWidth / 2;
	const minX = Math.floor(pos.x - halfWidth);
	const maxX = Math.floor(pos.x + halfWidth);
	const minY = Math.floor(pos.y); 
	const maxY = Math.floor(pos.y + playerHeight);
	const minZ = Math.floor(pos.z - halfWidth);
	const maxZ = Math.floor(pos.z + halfWidth);
	for (let x = minX; x <= maxX; x++) {
		for (let y = minY; y <= maxY; y++) {
			for (let z = minZ; z <= maxZ; z++) {
				if (getBlock(x, y, z)) return true;
			}
		}
	}
	return false;
}

function updateRiflePosition(deltaTime) {
    if (!rifle) return;

    const baseHipPosition = isMobileDevice ? mobileHipRiflePosition : hipRiflePosition;
    const targetPosition = isAiming ? adsRiflePosition : baseHipPosition;
    const lerpSpeed = 10.0 * deltaTime; 
    
    rifle.position.lerp(targetPosition, lerpSpeed);
}

function pickupBlock() {
    if (heldBlock) return; 

    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
	if (meshes.length === 0) return;
	
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(meshes);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const blockPos = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.01));
        const [pX, pY, pZ] = [Math.floor(blockPos.x), Math.floor(blockPos.y), Math.floor(blockPos.z)];

        const blockData = getBlock(pX, pY, pZ);
        if (!blockData || blockData.type === 'bedrock') return;

        const originalPos = { x: pX, y: pY, z: pZ };
        
        modifiedBlocks.set(`${pX},${pY},${pZ}`, null);
        markChunkForRegeneration(pX, pZ);
    spawnBlockRemovalParticles(new THREE.Vector3(pX + 0.5, pY + 0.5, pZ + 0.5), blockData.color);

        const heldGeo = new THREE.BoxGeometry(1, 1, 1);
        const heldMat = new THREE.MeshStandardMaterial({ 
            color: blockData.color, 
            transparent: true, 
            opacity: 0.8 
        });
        const heldMesh = new THREE.Mesh(heldGeo, heldMat);
        
        const glowGeo = new THREE.BoxGeometry(1.1, 1.1, 1.1); 
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending, 
            side: THREE.BackSide 
        });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        heldMesh.add(glowMesh); 

        heldMesh.position.set(pX + 0.5, pY + 0.5, pZ + 0.5); 
        scene.add(heldMesh);

        heldBlock = { 
            mesh: heldMesh, 
            glowMesh: glowMesh, 
            data: blockData, 
            originalPos: originalPos, 
            targetDistance: 5.0, 
            isPlacing: false, 
            targetPlacePosition: null,
            finalWorldPos: null
        };
    }
}

function placeBlock(instant = false) {
    if (!heldBlock) return;

    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(meshes);

    let finalX, finalY, finalZ;

    if (intersects.length > 0) {
        const adjacentBlockPos = intersects[0].point.clone().add(intersects[0].face.normal.clone().multiplyScalar(0.01));
        [finalX, finalY, finalZ] = [Math.floor(adjacentBlockPos.x), Math.floor(adjacentBlockPos.y), Math.floor(adjacentBlockPos.z)];
    } else {
        const targetPos = new THREE.Vector3(0, 0, -5).applyMatrix4(camera.matrixWorld);
        [finalX, finalY, finalZ] = [Math.floor(targetPos.x), Math.floor(targetPos.y - 1), Math.floor(targetPos.z)];
    }

    const halfWidth = playerWidth / 2;
    const playerMinX = Math.floor(playerCube.position.x - halfWidth);
    const playerMaxX = Math.floor(playerCube.position.x + halfWidth);
    const playerMinY = Math.floor(playerCube.position.y);
    const playerMaxY = Math.floor(playerCube.position.y + playerHeight);
    const playerMinZ = Math.floor(playerCube.position.z - halfWidth);
    const playerMaxZ = Math.floor(playerCube.position.z + halfWidth);
    
    if (finalX >= playerMinX && finalX <= playerMaxX && 
        finalY >= playerMinY && finalY <= playerMaxY && 
        finalZ >= playerMinZ && finalZ <= playerMaxZ) {
        
        [finalX, finalY, finalZ] = [heldBlock.originalPos.x, heldBlock.originalPos.y, heldBlock.originalPos.z];
        
        if (instant) {
            modifiedBlocks.set(`${finalX},${finalY},${finalZ}`, heldBlock.data);
            markChunkForRegeneration(finalX, finalZ);
        } else {
            heldBlock.isPlacing = true;
            heldBlock.targetPlacePosition = new THREE.Vector3(finalX + 0.5, finalY + 0.5, finalZ + 0.5);
            heldBlock.finalWorldPos = { x: finalX, y: finalY, z: finalZ }; 
            heldBlock.mesh.rotation.set(0, 0, 0); 
            return;
        }

    } 

    if (instant) {
        modifiedBlocks.set(`${finalX},${finalY},${finalZ}`, heldBlock.data);
        markChunkForRegeneration(finalX, finalZ);

        if (heldBlock.glowMesh) {
            heldBlock.mesh.remove(heldBlock.glowMesh);
            heldBlock.glowMesh.geometry.dispose();
            heldBlock.glowMesh.material.dispose();
        }

        scene.remove(heldBlock.mesh);
        heldBlock.mesh.geometry.dispose();
        heldBlock.mesh.material.dispose();
        heldBlock = null;
    } else {
        heldBlock.isPlacing = true;
        heldBlock.targetPlacePosition = new THREE.Vector3(finalX + 0.5, finalY + 0.5, finalZ + 0.5);
        heldBlock.finalWorldPos = { x: finalX, y: finalY, z: finalZ }; 
        
        heldBlock.mesh.rotation.set(0, 0, 0); 
    }
}

function updateHeldBlockPosition(deltaTime) {
    if (!heldBlock) return;

    let targetPos;
    const lerpSpeed = 10.0 * deltaTime;
    let targetScale; 

    if (heldBlock.isPlacing) { 
        targetPos = heldBlock.targetPlacePosition;
        targetScale = new THREE.Vector3(1, 1, 1); 
        
        heldBlock.mesh.position.lerp(targetPos, lerpSpeed);
        heldBlock.mesh.scale.lerp(targetScale, lerpSpeed); 
        
        if (heldBlock.mesh.position.distanceTo(targetPos) < 0.05) {
            const { x, y, z } = heldBlock.finalWorldPos;
            
            modifiedBlocks.set(`${x},${y},${z}`, heldBlock.data);
            markChunkForRegeneration(x, z);

            if (heldBlock.glowMesh) {
                heldBlock.mesh.remove(heldBlock.glowMesh);
                heldBlock.glowMesh.geometry.dispose();
                heldBlock.glowMesh.material.dispose();
            }

            scene.remove(heldBlock.mesh);
            heldBlock.mesh.geometry.dispose();
            heldBlock.mesh.material.dispose();
            heldBlock = null;
        }

    } else {
        targetScale = new THREE.Vector3(0.666, 0.666, 0.666); 
        let verticalOffset = 0.0; 

        const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
        let distance = Infinity; 

        if (meshes.length > 0) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                distance = intersects[0].distance;
                if (distance < 2.0) heldBlock.targetDistance = 1.5;
                else if (distance < 2.5) heldBlock.targetDistance = 2.0;
                else if (distance < 3.0) heldBlock.targetDistance = 2.5;
                else if (distance < 3.5) heldBlock.targetDistance = 3.0;
                else if (distance < 4.0) heldBlock.targetDistance = 3.5;
                else if (distance < 4.5) heldBlock.targetDistance = 4.0;
                else if (distance < 5.0) heldBlock.targetDistance = 4.5;
                else if (distance < 5.5) heldBlock.targetDistance = 5.0;
                else if (distance < 6.0) heldBlock.targetDistance = 5.5;
                else if (distance < 6.5) heldBlock.targetDistance = 6.0;
                else if (distance < 7.0) heldBlock.targetDistance = 6.5;
                else if (distance < 7.5) heldBlock.targetDistance = 7.0;
                else if (distance < 8.0) heldBlock.targetDistance = 7.5;
                else heldBlock.targetDistance = 8.0;
            } else {
                heldBlock.targetDistance = 8.0; 
            }

            if (distance <= 7.0) {
                verticalOffset = 0.5;
            }
        }


        const targetDist = heldBlock.targetDistance;
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);
        targetPos = cameraPos.clone().add(cameraDir.clone().multiplyScalar(targetDist));
        
        targetPos.y += verticalOffset; 

        heldBlock.mesh.position.lerp(targetPos, lerpSpeed);
        heldBlock.mesh.scale.lerp(targetScale, lerpSpeed); 
        
        heldBlock.mesh.rotation.y += 0.5 * deltaTime;
        heldBlock.mesh.rotation.x += 0.2 * deltaTime;
    }
}

function updateToolgunLaser() {
    if (!toolgunLaser) {
        const laserGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8); 
        const laserMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00FFFF, 
            transparent: true, 
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        toolgunLaser = new THREE.Mesh(laserGeo, laserMaterial);
        scene.add(toolgunLaser);
    }

    const laserStart = new THREE.Vector3(1.3, 0.05, 0); 
    rifle.updateWorldMatrix(true, false); 
    laserStart.applyMatrix4(rifle.matrixWorld); 
    
    const laserDir = new THREE.Vector3();
    camera.getWorldDirection(laserDir);

    let laserEnd;

    if (heldBlock) {
        laserEnd = heldBlock.mesh.position.clone();
    } else {
        const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
        const cameraRaycaster = new THREE.Raycaster();
        cameraRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = cameraRaycaster.intersectObjects(meshes);
        
        if (intersects.length > 0) {
            laserEnd = intersects[0].point;
        } else {
            const cameraPos = new THREE.Vector3();
            camera.getWorldPosition(cameraPos);
            laserEnd = cameraPos.clone().add(laserDir.clone().multiplyScalar(100));
        }
    }
    
    const distance = laserStart.distanceTo(laserEnd);
    toolgunLaser.scale.y = distance; 
    toolgunLaser.position.copy(laserStart).add(laserEnd).multiplyScalar(0.5); 
    toolgunLaser.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), laserEnd.clone().sub(laserStart).normalize()); 
}

function updateToolgun(deltaTime) {
    if (!hasGun || currentMode !== 'toolgun') {
        if (toolgunLaser) {
            scene.remove(toolgunLaser);
            toolgunLaser.geometry.dispose();
            toolgunLaser.material.dispose();
            toolgunLaser = null;
        }
        if (heldBlock) {
            placeBlock(true);
        }
        isToolgunActive = false; 
        return;
    }
    
    const shouldShowLaser = (isMobileDevice && heldBlock) || (!isMobileDevice && isToolgunActive);

    if (shouldShowLaser) {
        updateToolgunLaser();
    } else if (toolgunLaser) {
        scene.remove(toolgunLaser);
        toolgunLaser.geometry.dispose();
        toolgunLaser.material.dispose();
        toolgunLaser = null;
    }

    if (heldBlock) {
        updateHeldBlockPosition(deltaTime);
    }
}

// ---------------- Jump Pad Feature ----------------
function createJumpPadAt(x, y, z) {
    if (!scene) return;
    const geo = new THREE.BoxGeometry(JUMP_PAD_SIZE, JUMP_PAD_HEIGHT, JUMP_PAD_SIZE);
    const mat = new THREE.MeshStandardMaterial({ color: JUMP_PAD_COLOR, emissive: JUMP_PAD_EMISSIVE, emissiveIntensity: 0.6, metalness: 0.1, roughness: 0.8 });
    const mesh = new THREE.Mesh(geo, mat);
    // Center within block space
    mesh.position.set(x + 0.5, y + (JUMP_PAD_HEIGHT / 2), z + 0.5);
    // Slight scale pulse data
    mesh.userData.baseScale = 1.0;
    mesh.userData.pulseTime = 0;
    scene.add(mesh);
    jumpPads.push({ mesh, x, y, z, lastTriggerTime: -Infinity });
}

function placeJumpPad() {
    if (!jumpPadsEnabled) return;
    const meshes = Array.from(loadedChunks.values()).map(c => c.mesh).filter(m => m);
    if (meshes.length === 0) return;
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(meshes);
    if (intersects.length === 0) return;
    const adjacentBlockPos = intersects[0].point.clone().add(intersects[0].face.normal.clone().multiplyScalar(0.01));
    const finalX = Math.floor(adjacentBlockPos.x);
    const finalY = Math.floor(adjacentBlockPos.y);
    const finalZ = Math.floor(adjacentBlockPos.z);
    // Don't spawn inside player
    const halfWidth = playerWidth / 2;
    const playerMinX = Math.floor(playerCube.position.x - halfWidth);
    const playerMaxX = Math.floor(playerCube.position.x + halfWidth);
    const playerMinY = Math.floor(playerCube.position.y);
    const playerMaxY = Math.floor(playerCube.position.y + playerHeight);
    const playerMinZ = Math.floor(playerCube.position.z - halfWidth);
    const playerMaxZ = Math.floor(playerCube.position.z + halfWidth);
    if (finalX >= playerMinX && finalX <= playerMaxX && finalY >= playerMinY && finalY <= playerMaxY && finalZ >= playerMinZ && finalZ <= playerMaxZ) {
        return;
    }
    createJumpPadAt(finalX, finalY, finalZ);
    createLaserFlash(new THREE.Vector3(finalX + 0.5, finalY + 0.5, finalZ + 0.5));
}

function updateJumpPads(deltaTime) {
    for (const pad of jumpPads) {
        if (!pad.mesh) continue;
        pad.mesh.userData.pulseTime += deltaTime;
        const pulse = (Math.sin(pad.mesh.userData.pulseTime * 3) + 1) * 0.05 + 1;
        pad.mesh.scale.set(pulse, 1, pulse);
    }
}

function isOverJumpPad() {
    const playerBaseY = playerCube.position.y;
    const px = playerCube.position.x;
    const pz = playerCube.position.z;
    for (const pad of jumpPads) {
        const padTopY = pad.y + JUMP_PAD_HEIGHT;
        // horizontal check (pad centered with 0.5 offset)
        const withinX = px >= pad.x && px <= pad.x + 1;
        const withinZ = pz >= pad.z && pz <= pad.z + 1;
        const verticalClose = Math.abs(playerBaseY - padTopY) < 0.25; // near surface
        if (withinX && withinZ && verticalClose) return pad;
    }
    return null;
}

function checkJumpPadActivation() {
    if (isFlying) return; // ignore in noclip fly
    if (playerVelocity.y > 0) return; // only when falling/standing
    const pad = isOverJumpPad();
    if (!pad) return;
    const now = performance.now() / 1000.0;
    if (now - pad.lastTriggerTime < JUMP_PAD_LAND_COOLDOWN) return;
    pad.lastTriggerTime = now;
    playerVelocity.y = JUMP_PAD_BOOST;
    playerOnGround = false;
    playerJumpCount = 1;
}
// ---------------------------------------------------

function updatePlayer(deltaTime) {
    if (!playerCube) return;
	const moveVector = new THREE.Vector3(0, 0, 0);
	if (keys['KeyS']) moveVector.z += 1;
	if (keys['KeyW']) moveVector.z -= 1;
	if (keys['KeyD']) moveVector.x += 1;
	if (keys['KeyA']) moveVector.x -= 1;

    if ( isFlying) {
        if (keys['Space']) moveVector.y += 1;
        if (keys['ShiftLeft']) moveVector.y -= 1;

        if (moveVector.lengthSq() > 0) moveVector.normalize();
        
        moveVector.applyQuaternion(playerCube.quaternion);
        playerCube.position.add(moveVector.multiplyScalar(flyingSpeed * deltaTime));
        playerOnGround = false;
        playerVelocity.set(0, 0, 0);

    } else {
        if (moveVector.lengthSq() > 0) moveVector.normalize();
        
        moveVector.applyQuaternion(playerCube.quaternion);
        const desiredMoveX = moveVector.x * v;
        const desiredMoveZ = moveVector.z * v;

        playerVelocity.y += gravity * deltaTime;

        const isSpacePressed = !!keys['Space'];
        const justPressedSpace = isSpacePressed && !spaceWasPressedLastFrame;
        spaceWasPressedLastFrame = isSpacePressed;

        if (justPressedSpace) {
            // Manual jump still allowed; auto launch handled separately on landing
            if (playerOnGround) {
                playerVelocity.y = playerJumpHeight;
                playerOnGround = false;
                playerJumpCount = 1;
            } else if (playerJumpCount < 2) {
                playerVelocity.y = playerJumpHeight * 0.9;
                playerJumpCount++;
            }
        }
        
        const finalVelocity = new THREE.Vector3(desiredMoveX, playerVelocity.y, desiredMoveZ);
        finalVelocity.x += playerVelocity.x;
        finalVelocity.z += playerVelocity.z;

        const nextPos = playerCube.position.clone().add(finalVelocity.clone().multiplyScalar(deltaTime));
        
        if (checkCollision(nextPos)) {
            const tempPos = playerCube.position.clone();
            
            tempPos.x = nextPos.x;
            if (checkCollision(tempPos)) {
                finalVelocity.x = 0;
                playerVelocity.x = 0;
            }
            
            tempPos.x = playerCube.position.x;
            tempPos.z = nextPos.z;
            if (checkCollision(tempPos)) {
                finalVelocity.z = 0;
                playerVelocity.z = 0;
            }

            tempPos.z = playerCube.position.z;
            tempPos.y = nextPos.y;
            if (checkCollision(tempPos)) {
                if (finalVelocity.y < 0) {
                    playerOnGround = true;
                    playerJumpCount = 0;
                }
                finalVelocity.y = 0;
                playerVelocity.y = 0;
            } else {
                playerOnGround = false;
            }
        } else {
            playerOnGround = false;
        }

        playerCube.position.add(finalVelocity.multiplyScalar(deltaTime));

        playerVelocity.x *= 0.98;
        playerVelocity.z *= 0.98;
        if (Math.abs(playerVelocity.x) < 0.01) playerVelocity.x = 0;
        if (Math.abs(playerVelocity.z) < 0.01) playerVelocity.z = 0;

    }

	if (playerCube.position.y < BEDROCK_LEVEL - 20) respawnPlayer();

    updateJumpPads(deltaTime);
    checkJumpPadActivation();
}

function respawnPlayer() {
    if (heldBlock) placeBlock(true);
    playerCube.position.copy(playerSpawnPoint);
    playerVelocity.set(0, 0, 0);
    isFlying = false;
}

function animate() {
	animationFrameId = requestAnimationFrame(animate); 

	const deltaTime = Math.min(0.05, clock.getDelta());
    const elapsedTime = clock.getElapsedTime();
    
	updatePlayer(deltaTime);
    updateRiflePosition(deltaTime);

    if (rifle && rifle.barrel) {
        const barrelMaterial = rifle.barrel.material;
    if (currentMode === 'add' || currentMode === 'toolgun' || currentMode === BEDROCK_PLACE_MODE || currentMode === 'fill' || currentMode === 'sphere') {
            const pulse = (Math.sin(elapsedTime * 4) + 1) / 2;
            barrelMaterial.emissive.setHex(0x00ffff);
            barrelMaterial.emissiveIntensity = pulse * 1.5;
        } else {
            barrelMaterial.emissiveIntensity = 0;
        }
    }

    updateToolgun(deltaTime); 
    updateProjectiles(deltaTime);
    updateMissiles(deltaTime);
    updateExplosions(deltaTime);
    updateLaserFlashes(deltaTime);
    updateBlockRemovalParticles(deltaTime);
    updateGunPickup(deltaTime);
	
    updateWorld();
    processChunkGenerationSlice();

	renderer.render(scene, camera);

    if (playerCube) {
        lastPlayerPos.copy(playerCube.position); 
    }
	
}

const PI_2 = Math.PI / 2;
function onMouseMove(event) {
    if (!isMobileDevice && document.pointerLockElement !== renderer.domElement) return;

    const movementX = event.movementX || 0;
    const movementY = event.movementY || 0;
    
    const sensitivity = isMobileDevice ? 0.0025 : 0.0015;

    playerCube.rotation.y -= movementX * sensitivity;
    camera.rotation.x -= movementY * sensitivity;
    camera.rotation.x = Math.max(-PI_2, Math.min(PI_2, camera.rotation.x));
}

function saveWorld() {
    if (heldBlock) {
        placeBlock(true);
    }

    const serializableBlocks = {};
    for (const [key, blockData] of modifiedBlocks.entries()) {
        if (blockData) {
            serializableBlocks[key] = { color: blockData.color.getHexString(), type: blockData.type };
        } else {
            serializableBlocks[key] = null; 
        }
    }

    const worldData = {
        seed: worldSeedString,
        seedValue: worldSeedValue,
        seedType: worldSeedSource,
        blocks: serializableBlocks
    };

    const jsonString = JSON.stringify(worldData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const fallbackSeedLabel = worldSeedValue.toString();
    const safeSeedSource = (typeof worldSeedString === 'string' && worldSeedString.length > 0) ? worldSeedString : fallbackSeedLabel;
    const sanitizedSeed = safeSeedSource.replace(/[^a-zA-Z0-9_-]+/g, '').substring(0, 16);
    const fileSeed = sanitizedSeed.length > 0 ? sanitizedSeed : 'world';
    a.download = `world_seed_${fileSeed}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function loadWorld(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const worldData = JSON.parse(e.target.result);
            if (worldData.seed === undefined || worldData.blocks === undefined) {
                throw new Error("Invalid world file format.");
            }
            
            // Hide seed overlay and re-initialize the world
            document.getElementById('seed-overlay').style.display = 'none';

            const hasSeedValueProperty = Object.prototype.hasOwnProperty.call(worldData, 'seedValue');
            let numericSeedValue = null;
            if (hasSeedValueProperty) {
                if (typeof worldData.seedValue === 'number' && !Number.isNaN(worldData.seedValue)) {
                    numericSeedValue = worldData.seedValue;
                } else if (typeof worldData.seedValue === 'string') {
                    const trimmedValue = worldData.seedValue.trim();
                    const parsedValue = Number(trimmedValue);
                    if (!Number.isNaN(parsedValue)) {
                        numericSeedValue = parsedValue;
                    }
                }
            }
            const seedType = (typeof worldData.seedType === 'string') ? worldData.seedType : null;

            runWithLoadingOverlay(() => {
                init(worldData.seed, numericSeedValue, seedType);
                loadModifications(worldData.blocks);
            });

        } catch (error) {
            console.error("Failed to load world:", error);
            // Do not use alert()
            console.error("Error loading world file. Make sure it's a valid world JSON file.");
            hideLoadingOverlay();
        } finally {
            // Reset file input so the same file can be loaded again
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

function loadModifications(loadedBlocks) {
    modifiedBlocks.clear();
    for (const key in loadedBlocks) {
        const blockData = loadedBlocks[key];
        if (blockData) {
            modifiedBlocks.set(key, { 
                color: new THREE.Color("#" + blockData.color), 
                type: blockData.type || 'normal'
            });
        } else {
            modifiedBlocks.set(key, null);
        }
    }
    for (const chunkData of loadedChunks.values()) {
        chunkData.needsRegeneration = true;
    }
}

let onWindowResize;
let onKeyDown, onKeyUp, onRendererClick, onPointerLockChange, onDocMouseDown, onDocMouseUp, onDocContextMenu;
let joystickStart, windowTouchMove, endJoystickHandler;
let jumpStart, jumpEnd, actionStart, switchModeStart, mobileModeDisplayStart, saveStart;
let rendererTouchStart, rendererTouchMove, endLookTouchHandler;


function setupEventListeners() {
    if (onWindowResize) window.removeEventListener('resize', onWindowResize, false);
	onWindowResize = () => {
        if (!isMobileDevice) {
            // On desktop, maintain fixed size
            const aspect = 805 / 500;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(805, 500);
        } else {
            // On mobile, fill screen
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
	};
    // Call it once to set initial size
    onWindowResize(); 
    window.addEventListener('resize', onWindowResize, false);


    if (isMobileDevice) {
        cleanupDesktopControls(); 
        setupMobileControls();
    } else {
        cleanupMobileControls(); 
        setupDesktopControls();
    }

    updateAvailableModes();

	document.getElementById('add-mode-btn').addEventListener('click', () => { setCurrentMode('add'); });
	document.getElementById('shoot-mode-btn').addEventListener('click', () => { setCurrentMode('shoot'); });
    document.getElementById('missile-mode-btn').addEventListener('click', () => {
        setCurrentMode('missile'); 
    });
    document.getElementById('toolgun-mode-btn').addEventListener('click', () => { setCurrentMode('toolgun'); }); 
    const jumpPadButton = document.getElementById('jumppad-mode-btn');
    if (jumpPadButton) {
        jumpPadButton.addEventListener('click', () => {
            if (jumpPadsEnabled && hasGun) {
                setCurrentMode(JUMP_PAD_MODE);
            }
        });
    }
    const bedrockButton = document.getElementById('bedrock-mode-btn');
    if (bedrockButton) {
        bedrockButton.addEventListener('click', () => {
            if (bedrockModesEnabled) {
                setCurrentMode(BEDROCK_PLACE_MODE);
            }
        });
    }
    
    // Map Tools mode buttons
    const fillButton = document.getElementById('fill-mode-btn');
    const sphereButton = document.getElementById('sphere-mode-btn');
    if (fillButton) {
        fillButton.addEventListener('click', () => {
            if (mapToolsEnabled && hasGun) {
                wallCorner1 = null; // Reset stored corners when switching to fill mode
                wallCorner2 = null;
                setCurrentMode('fill');
            }
        });
    }
    if (sphereButton) {
        sphereButton.addEventListener('click', () => {
            if (mapToolsEnabled && hasGun) {
                setCurrentMode('sphere');
            }
        });
    }
    
    document.getElementById('save-world-btn').addEventListener('click', saveWorld);
    document.getElementById('ingame-load-world-btn').addEventListener('click', () => document.getElementById('load-file-input').click());
    document.getElementById('load-file-input').addEventListener('change', loadWorld);
    document.getElementById('start-game-btn').addEventListener('click', startGameFromInput);

	const colorPicker = document.getElementById('cube-color-picker');
	colorPicker.addEventListener('input', (event) => { 
        currentColor = parseInt(event.target.value.substring(1), 16); 
        // Update mobile UI in real-time if it's open
        if (isMobileDevice) {
            updateModeButtons();
        }
    });
	currentColor = parseInt(colorPicker.value.substring(1), 16);
	updateModeButtons();
}

function cleanupDesktopControls() {
    if (onKeyDown) document.removeEventListener('keydown', onKeyDown);
    if (onKeyUp) document.removeEventListener('keyup', onKeyUp);
    if (renderer && onRendererClick) renderer.domElement.removeEventListener('click', onRendererClick);
    if (onPointerLockChange) document.removeEventListener('pointerlockchange', onPointerLockChange);
    if (onDocMouseDown) document.removeEventListener('mousedown', onDocMouseDown, false);
    if (onDocMouseUp) document.removeEventListener('mouseup', onDocMouseUp, false);
    if (onDocContextMenu) document.removeEventListener('contextmenu', onDocContextMenu, false);
    document.removeEventListener("mousemove", onMouseMove, false); 
    
    onKeyDown = onKeyUp = onRendererClick = onPointerLockChange = onDocMouseDown = onDocMouseUp = onDocContextMenu = null;
}

function setupDesktopControls() {
    cleanupDesktopControls(); 
    
    onKeyDown = (event) => {
        keys[event.code] = true;
        if (event.code === 'Digit1') setCurrentMode('shoot'); 
        else if (event.code === 'Digit2') setCurrentMode('missile');
        else if (event.code === 'Digit3') setCurrentMode('toolgun');
        else if (event.code === 'Digit4') {
            setCurrentMode('add');
        }
        else if (event.code === 'Digit5' && bedrockModesEnabled) {
            setCurrentMode(BEDROCK_PLACE_MODE);
        }
        else if (event.code === 'Digit6' && mapToolsEnabled && hasGun) {
            wallCorner1 = null; // Reset stored corners when switching to fill mode
            wallCorner2 = null;
            setCurrentMode('fill');
        }
        else if (event.code === 'Digit7' && mapToolsEnabled && hasGun) {
            setCurrentMode('sphere');
        }
        else if (event.code === 'Digit8' && jumpPadsEnabled && hasGun) {
            setCurrentMode(JUMP_PAD_MODE);
        }
        else if (event.code === 'KeyF') {
            if (noclipEnabled) {
                isFlying = !isFlying;
                playerJumpCount = isFlying ? 0 : playerJumpCount;
            }
        }
    };
	onKeyUp = (event) => { keys[event.code] = false; };

    onRendererClick = () => {
        if (document.getElementById('seed-overlay').style.display === 'none') {
            renderer.domElement.requestPointerLock();
        }
    };
	onPointerLockChange = () => {
        if (document.pointerLockElement === renderer.domElement) {
            document.addEventListener("mousemove", onMouseMove, false);
        } else {
            document.removeEventListener("mousemove", onMouseMove, false);
        }
    };

	onDocMouseDown = onMouseDown; 
    onDocMouseUp = onMouseUp; 
    onDocContextMenu = (event) => {
        if (!isMobileDevice) event.preventDefault();
    };

    document.addEventListener('keydown', onKeyDown);
	document.addEventListener('keyup', onKeyUp);
    renderer.domElement.addEventListener('click', onRendererClick);
	document.addEventListener('pointerlockchange', onPointerLockChange);
	document.addEventListener('mousedown', onDocMouseDown, false);
    document.addEventListener('mouseup', onDocMouseUp, false); 
    document.addEventListener('contextmenu', onDocContextMenu, false);
}

function cleanupMobileControls() {
    const joystick = document.getElementById('joystick-container');
    if (joystickStart) joystick.removeEventListener('touchstart', joystickStart, { passive: false });
    if (windowTouchMove) window.removeEventListener('touchmove', windowTouchMove, { passive: false });
    if (endJoystickHandler) {
        window.removeEventListener('touchend', endJoystickHandler);
        window.removeEventListener('touchcancel', endJoystickHandler);
    }

    const jumpBtn = document.getElementById('mobile-jump-btn');
    const actionBtn = document.getElementById('mobile-action-btn');
    const switchModeBtn = document.getElementById('mobile-switch-mode-btn');
    const saveBtn = document.getElementById('mobile-save-world-btn');
    const mobileModeDisplay = document.getElementById('mobile-mode-display');

    if (jumpStart) jumpBtn.removeEventListener('touchstart', jumpStart, { passive: false });
    if (jumpEnd) jumpBtn.removeEventListener('touchend', jumpEnd, { passive: false });
    if (actionStart) actionBtn.removeEventListener('touchstart', actionStart, { passive: false });
    if (switchModeStart) switchModeBtn.removeEventListener('touchstart', switchModeStart, { passive: false });
    if (mobileModeDisplayStart) mobileModeDisplay.removeEventListener('touchstart', mobileModeDisplayStart, { passive: false });
    if (saveStart) saveBtn.removeEventListener('touchstart', saveStart, { passive: false });

    if (renderer && rendererTouchStart) renderer.domElement.removeEventListener('touchstart', rendererTouchStart, { passive: false });
    if (renderer && rendererTouchMove) renderer.domElement.removeEventListener('touchmove', rendererTouchMove, { passive: false });
    if (renderer && endLookTouchHandler) {
        renderer.domElement.removeEventListener('touchend', endLookTouchHandler);
        renderer.domElement.removeEventListener('touchcancel', endLookTouchHandler);
    }

    joystickStart = windowTouchMove = endJoystickHandler = jumpStart = jumpEnd = actionStart = switchModeStart = mobileModeDisplayStart = saveStart = rendererTouchStart = rendererTouchMove = endLookTouchHandler = null;
}

function setupMobileControls() {
    cleanupMobileControls(); 
    document.getElementById('mobile-controls-container').classList.add('active');
    document.getElementById('mode-selector').style.display = 'none';

    const joystick = document.getElementById('joystick-container');
    const thumb = document.getElementById('joystick-thumb');
    const maxRadius = joystick.offsetWidth / 2;
    let joystickActive = false;
    let joystickTouchId = null;
    let startPos = { x: 0, y: 0 };

    joystickStart = (e) => {
        e.preventDefault();
        if (joystickActive) return;
        const joystickRect = joystick.getBoundingClientRect();
        joystickActive = true;
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        startPos.x = joystickRect.left + maxRadius;
        startPos.y = joystickRect.top + maxRadius;
    };
    joystick.addEventListener('touchstart', joystickStart, { passive: false });

    windowTouchMove = (e) => {
        if (!joystickActive) return;
        
        let foundTouch = null;
        for (let touch of e.touches) {
            if (touch.identifier === joystickTouchId) {
                foundTouch = touch;
                break;
            }
        }
        if (!foundTouch) return;

        const currentX = foundTouch.clientX;
        const currentY = foundTouch.clientY;
        let deltaX = currentX - startPos.x;
        let deltaY = currentY - startPos.y;
        
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const deadzone = maxRadius * 0.15;
        if (distance < deadzone) {
            deltaX = 0;
            deltaY = 0;
        }

        if (distance > maxRadius) {
            deltaX = (deltaX / distance) * maxRadius;
            deltaY = (deltaY / distance) * maxRadius;
        }

        thumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        
        const moveThreshold = maxRadius * 0.2;
        keys['KeyW'] = deltaY < -moveThreshold;
        keys['KeyS'] = deltaY > moveThreshold;
        keys['KeyA'] = deltaX < -moveThreshold;
        keys['KeyD'] = deltaX > moveThreshold;

    };
    joystick.addEventListener('touchmove', (e) => {
        if (joystickActive) {
            e.preventDefault();
        }
    }, { passive: false });
    window.addEventListener('touchmove', windowTouchMove, { passive: false });

    endJoystickHandler = (e) => {
        if (!joystickActive) return;
        
        let foundTouch = false;
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystickTouchId) {
                foundTouch = true;
                break;
            }
        }
        if (!foundTouch) return;

        joystickActive = false;
        joystickTouchId = null;
        thumb.style.transform = 'translate(-50%, -50%)';
        keys['KeyW'] = keys['KeyS'] = keys['KeyA'] = keys['KeyD'] = false;
    };
    
    window.addEventListener('touchend', endJoystickHandler);
    window.addEventListener('touchcancel', endJoystickHandler);


    const jumpBtn = document.getElementById('mobile-jump-btn');
    const actionBtn = document.getElementById('mobile-action-btn');
    const switchModeBtn = document.getElementById('mobile-switch-mode-btn');
    const saveBtn = document.getElementById('mobile-save-world-btn');
    const mobileModeDisplay = document.getElementById('mobile-mode-display');
    const colorSelector = document.getElementById('color-selector');

    jumpStart = (e) => { e.preventDefault(); keys['Space'] = true; };
    jumpEnd = (e) => { e.preventDefault(); keys['Space'] = false; };
    jumpBtn.addEventListener('touchstart', jumpStart, { passive: false });
    jumpBtn.addEventListener('touchend', jumpEnd, { passive: false });

    actionStart = (e) => { 
        e.preventDefault(); 
        if (currentMode === 'toolgun') {
            isToolgunActive = true;
            performAction(); 
            isToolgunActive = false;
        } else {
            performAction(); 
        }
    };
    actionBtn.addEventListener('touchstart', actionStart, { passive: false });
 
 
    switchModeStart = (e) => {
        e.preventDefault();
        if (modes.length === 0) return;
        const nextIndex = (currentModeIndex + 1) % modes.length;
        setCurrentMode(modes[nextIndex]);
    };
    switchModeBtn.addEventListener('touchstart', switchModeStart, { passive: false });
 
    // --- New listener for mobile color picker ---
    mobileModeDisplayStart = (e) => {
        e.preventDefault();
        const colorModes = ['add', 'fill', 'sphere'];
        if (colorModes.includes(currentMode)) {
            // Toggle color picker
            if (colorSelector.style.display === 'flex') {
                colorSelector.style.display = 'none';
            } else {
                colorSelector.style.display = 'flex';
            }
        }
    };
    mobileModeDisplay.addEventListener('touchstart', mobileModeDisplayStart, { passive: false });
    
    // Save world on mobile
    saveStart = (e) => { e.preventDefault(); saveWorld(); };
    saveBtn.addEventListener('touchstart', saveStart, { passive: false });
    // --- End of new listener ---

    let lookTouchId = null;
    let lastLookPos = { x: 0, y: 0 };

    rendererTouchStart = (e) => {
        // Check if tap is on UI elements, if so, ignore.
        if (e.target.closest('#joystick-container, #action-buttons-container, #color-selector')) return;
        
        // Hide color picker if it's open and tap is outside
        document.getElementById('color-selector').style.display = 'none';
        
        if (lookTouchId === null) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            lookTouchId = touch.identifier;
            lastLookPos.x = touch.clientX;
            lastLookPos.y = touch.clientY;
        }
    };
    renderer.domElement.addEventListener('touchstart', rendererTouchStart, { passive: false });

    rendererTouchMove = (e) => {
        e.preventDefault();
        for (let touch of e.changedTouches) {
            if (touch.identifier === lookTouchId) {
                const movementX = touch.clientX - lastLookPos.x;
                const movementY = touch.clientY - lastLookPos.y;
                onMouseMove({ movementX, movementY });
                lastLookPos.x = touch.clientX;
                lastLookPos.y = touch.clientY;
            }
        }
    };
    renderer.domElement.addEventListener('touchmove', rendererTouchMove, { passive: false });

    endLookTouchHandler = (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === lookTouchId) {
                lookTouchId = null;
            }
        }
    };
    renderer.domElement.addEventListener('touchend', endLookTouchHandler);
    renderer.domElement.addEventListener('touchcancel', endLookTouchHandler);
}

function updateModeButtons() {
	document.getElementById('add-mode-btn').classList.toggle('active', currentMode === 'add');
	document.getElementById('shoot-mode-btn').classList.toggle('active', currentMode === 'shoot');
    
    const missileBtn = document.getElementById('missile-mode-btn');
    missileBtn.classList.toggle('active', currentMode === 'missile');
    missileBtn.innerText = 'Missile(2)';
    missileBtn.style.color = '';
    missileBtn.style.backgroundColor = '';
 
    document.getElementById('toolgun-mode-btn').classList.toggle('active', currentMode === 'toolgun');
    const bedrockBtn = document.getElementById('bedrock-mode-btn');
    if (bedrockBtn) {
        const shouldShowBedrock = bedrockModesEnabled && !isMobileDevice;
        bedrockBtn.style.display = shouldShowBedrock ? 'block' : 'none';
        bedrockBtn.classList.toggle('active', currentMode === BEDROCK_PLACE_MODE);
        if (shouldShowBedrock) {
            bedrockBtn.textContent = 'Bedrock(5)';
        }
    }

    // Map Tools mode buttons
    const fillBtn = document.getElementById('fill-mode-btn');
    const sphereBtn = document.getElementById('sphere-mode-btn');
    const jumpPadBtn = document.getElementById('jumppad-mode-btn');
    if (fillBtn && sphereBtn) {
        const shouldShowMapTools = mapToolsEnabled && hasGun && !isMobileDevice;
        fillBtn.style.display = shouldShowMapTools ? 'block' : 'none';
        sphereBtn.style.display = shouldShowMapTools ? 'block' : 'none';
        fillBtn.classList.toggle('active', currentMode === 'fill');
        sphereBtn.classList.toggle('active', currentMode === 'sphere');
        if (shouldShowMapTools) {
            fillBtn.textContent = 'Fill(6)';
            sphereBtn.textContent = 'Sphere(7)';
        }
    }

    if (jumpPadBtn) {
        const shouldShowJumpPad = jumpPadsEnabled && hasGun && !isMobileDevice;
        jumpPadBtn.style.display = shouldShowJumpPad ? 'block' : 'none';
        jumpPadBtn.classList.toggle('active', currentMode === JUMP_PAD_MODE);
        if (shouldShowJumpPad) {
            jumpPadBtn.textContent = 'Jump Pad(8)';
        }
    }

    currentModeIndex = Math.max(0, modes.indexOf(currentMode));

    // Modes UI visibility depends on having the gun
    updateModeUIVisibility();
 
    if (isMobileDevice) {
        const modeDisplay = document.getElementById('mobile-mode-display');
        if (modeDisplay) {
            if (!hasGun) {
                modeDisplay.style.display = 'none';
                return;
            }
            modeDisplay.style.display = 'block';
            let modeText;
            if (currentMode === 'toolgun') modeText = 'Tool Gun';
            else if (currentMode === 'add') modeText = 'Create';
            else if (currentMode === 'shoot') modeText = 'Shoot';
            else if (currentMode === 'missile') modeText = 'Missile';
            else if (currentMode === BEDROCK_PLACE_MODE) modeText = 'Bedrock';
            else if (currentMode === 'fill') modeText = 'Fill';
            else if (currentMode === 'sphere') modeText = 'Sphere';
            else modeText = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);

            const colorModes = ['add', 'fill', 'sphere'];
            if (colorModes.includes(currentMode)) {
                // Update background color, but check brightness for text color
                const hexColor = currentColor.toString(16).padStart(6, '0');
                modeDisplay.style.backgroundColor = `#${hexColor}`;
                
                // Simple brightness check
                const r = (currentColor >> 16) & 0xff;
                const g = (currentColor >> 8) & 0xff;
                const b = currentColor & 0xff;
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                modeDisplay.style.color = brightness > 128 ? '#333333' : '#FFFFFF';

            } else {
                modeDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modeDisplay.style.color = '#FFFFFF';
                // Hide color picker if mode is changed
                document.getElementById('color-selector').style.display = 'none';
            }
            modeDisplay.textContent = modeText;
        }
    }
}

function updateModeUIVisibility() {
    // Desktop modes panel
    const modeSelector = document.getElementById('mode-selector');
    if (modeSelector) {
        modeSelector.style.display = hasGun && !isMobileDevice ? 'flex' : 'none';
    }
    // Color selector only if gun owned and in color-capable mode on desktop
    const colorSelector = document.getElementById('color-selector');
    if (colorSelector) {
        const colorModes = ['add', 'fill', 'sphere'];
        const showColorSelector = hasGun && colorModes.includes(currentMode) && !isMobileDevice;
        colorSelector.style.display = showColorSelector ? 'flex' : 'none';
    }
    // Mobile mode display handled in updateModeButtons()
}

function spawnGunPickup() {
    if (!playerCube) return;
    // Determine a spot ~3 units in front, on ground
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerCube.quaternion).normalize();
    const targetPos = playerCube.position.clone().add(forward.multiplyScalar(3.0));
    const groundY = getTerrainHeight(Math.floor(targetPos.x), Math.floor(targetPos.z));

    const pickup = createRifle();
    pickup.scale.set(0.5, 0.5, 0.5);
    pickup.rotation.y = Math.PI / 2;
    const y = groundY + 2.0; // Float one extra block above current spawn
    pickup.position.set(targetPos.x, y, targetPos.z);
    pickup.userData.baseY = y;
    scene.add(pickup);
    gunPickup = pickup;
    gunPickupBobTime = 0;
}

function updateGunPickup(deltaTime) {
    if (!gunPickup) return;
    // Spin and bob
    gunPickup.rotation.y += GUN_SPIN_SPEED * deltaTime;
    gunPickupBobTime += deltaTime;
    const baseY = gunPickup.userData.baseY || gunPickup.position.y;
    gunPickup.position.y = baseY + Math.sin(gunPickupBobTime * 2.0) * 0.1;

    // Auto-pickup when close
    const playerPos = playerCube ? playerCube.position.clone().add(new THREE.Vector3(0, playerHeight * 0.5, 0)) : null;
    if (playerPos) {
        const d = playerPos.distanceTo(gunPickup.position);
        if (d <= GUN_PICKUP_DISTANCE) {
            pickupGun();
        }
    }
}

function pickupGun() {
    if (!gunPickup || hasGun) return;
    // Remove pickup model
    scene.remove(gunPickup);
    gunPickup.traverse(obj => { if (obj.isMesh) { obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose(); } } });
    gunPickup = null;

    // Attach rifle to camera
    rifle = createRifle();
    if (isMobileDevice) {
        rifle.position.copy(mobileHipRiflePosition);
        rifle.scale.set(0.4, 0.4, 0.4);
    } else {
        rifle.position.copy(hipRiflePosition);
        rifle.scale.set(0.5, 0.5, 0.5);
    }
    rifle.rotation.y = Math.PI / 2;
    camera.add(rifle);

    hasGun = true;
    updateAvailableModes(); // Update modes to include map tools if enabled
    updateModeButtons();
}

const developerOptionsContainer = document.getElementById('developer-options');
if (developerOptionsContainer) {
    const developerToggleButton = document.getElementById('developer-options-toggle');
    const bedrockModeToggle = document.getElementById('bedrock-mode-toggle');
    const noclipToggle = document.getElementById('noclip-toggle');
    const mapToolsToggle = document.getElementById('map-tools-toggle');
    const jumpPadsToggle = document.getElementById('jump-pads-toggle');

    if (developerToggleButton) {
        developerToggleButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            developerOptionsContainer.classList.toggle('open');
        });
    }

    developerOptionsContainer.addEventListener('click', (event) => {
        event.stopPropagation();
    });

    document.addEventListener('click', (event) => {
        if (!developerOptionsContainer.contains(event.target)) {
            developerOptionsContainer.classList.remove('open');
        }
    });

    if (bedrockModeToggle) {
        bedrockModeToggle.addEventListener('change', (event) => {
            setBedrockModesEnabled(event.target.checked);
        });
        bedrockModeToggle.checked = bedrockModesEnabled;
    }

    if (noclipToggle) {
        noclipToggle.addEventListener('change', (event) => {
            setNoclipEnabled(event.target.checked);
        });
        noclipToggle.checked = noclipEnabled;
    }
    
    if (mapToolsToggle) {
        mapToolsToggle.addEventListener('change', (event) => {
            setMapToolsEnabled(event.target.checked);
        });
        mapToolsToggle.checked = mapToolsEnabled;
    }
    if (jumpPadsToggle) {
        jumpPadsToggle.addEventListener('change', (event) => {
            setJumpPadsEnabled(event.target.checked);
        });
        jumpPadsToggle.checked = jumpPadsEnabled;
    }
}
 
document.getElementById('start-game-btn').addEventListener('click', startGameFromInput);

document.getElementById('load-world-btn').addEventListener('click', () => {
    document.getElementById('load-file-input').click();
});

document.getElementById('load-file-input').addEventListener('change', loadWorld);

document.getElementById('seed-input').addEventListener('keypress', function (e) {
    if (e.key === 'Enter') {
        document.getElementById('start-game-btn').click();
    }
});

function startGameFromInput() {
    const seed = document.getElementById('seed-input').value;
    document.getElementById('seed-overlay').style.display = 'none';
    runWithLoadingOverlay(() => init(seed));
}
    </script>
</body>
</html>

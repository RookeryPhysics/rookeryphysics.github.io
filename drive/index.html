<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta property="og:site_name" content="Roadst3r" />
    <meta property="og:title" content="Play Roadst3r" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://rookeryphysics.github.io/drive" />
    <meta property="og:description" content="Voxel driving game. Drift through a city and try to beat your top score." />
    <meta property="og:image" content="https://rookeryphysics.github.io/drive/img.jpg" />
    <meta property="og:image:secure_url" content="https://rookeryphysics.github.io/drive/img.jpg" />
    <!-- Optional width/height; adjust if img.jpg differs -->
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <link rel="canonical" href="https://rookeryphysics.github.io/drive" />
    <title>Roadst3r</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            font-size: 14px;
            pointer-events: none;
            backdrop-filter: blur(4px);
            animation: fadeOut 5s forwards;
            animation-delay: 5s;
            width: 80%;
            max-width: 400px;
            z-index: 15;
        }

        /* --- Game Over Modal --- */
        #game-over-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 40px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            color: white;
            z-index: 200;
            display: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            min-width: 200px;
            pointer-events: none;
        }
        
        #game-over-modal h2 {
            margin: 0 0 10px 0;
            color: #ff3366;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #game-over-modal p {
            margin: 0;
            font-size: 20px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #game-over-modal.active {
            display: block;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* --- Controls Layout --- */

        #movement-zone {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 180px;
            height: 180px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #stick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #heading-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: center center;
            z-index: 10;
        }

        #heading-arrow::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 14px;
            background-color: #ff3366;
            left: -3px;
            bottom: 2px;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #heading-arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 16px solid #ff3366;
            left: -10px;
            bottom: 14px;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.3));
        }





        /* --- Day/Night Toggle Button --- */
        #time-btn {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #time-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Share Button --- */
        #share-btn {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #share-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Share Modal --- */
        #share-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        #share-modal.active {
            display: flex;
        }

        #share-modal-content {
            background: rgba(20, 20, 30, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            max-width: 400px;
            width: 80%;
            max-height: 80%; /* Increased height */
            overflow-y: auto; /* Added scroll for content overflow */
            position: relative;
        }

        /* Allow normal interactions inside modal on mobile */
        #share-modal,
        #share-modal * {
            touch-action: auto;
        }

        /* Re-enable text selection for the share link input */
        #share-link {
            user-select: text;
            -webkit-user-select: text;
        }

        #share-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #share-modal-close:hover {
            color: #ff3366;
        }

        /* --- Vehicle Modal --- */
        #vehicle-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70vw; /* Reduced from 90vw */
            max-width: 350px; /* Reduced from 500px */
            height: 60vh; /* Reduced from 80vh */
            max-height: 350px; /* Reduced from 500px */
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }
        
        #vehicle-modal.active {
            display: flex;
            opacity: 1;
        }

        #vehicle-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            z-index: 101;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #modal-canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 50;
        }

        #color-palette {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 102;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
            width: 80%;
            max-width: 250px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-swatch:hover, .color-swatch.selected {
            transform: scale(1.2);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #vehicle-info {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        #vehicle-name {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        #vehicle-stats {
            font-size: 16px;
            opacity: 0.8;
        }

        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffcc00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
        }

        #fps-counter {
            position: absolute;
            top: 20px;
            left: 60px;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px; /* Made slightly smaller */
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.3s ease;
        }

        #collapse-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.3s ease;
        }

        #collapse-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* HUD Hidden State */
        body.hud-hidden #fps-counter,
        body.hud-hidden #score-board,
        body.hud-hidden #time-btn,
        body.hud-hidden #share-btn,
        body.hud-hidden #minimap-container,
        body.hud-hidden .instructions {
            opacity: 0;
            pointer-events: none;
        }
        
        #score-board, #time-btn, #share-btn, #minimap-container, .instructions {
            transition: opacity 0.3s ease;
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            left: 130px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: #000;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MCV5P2FEE7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-MCV5P2FEE7');
    </script>
</head>

<body>

    <div id="ui-layer">
        <div id="collapse-btn">‚óÄ</div>
        <div id="fps-counter">FPS: 60</div>
        <div id="score-board">Score: 0</div>
        <div id="time-btn">üåô</div>
        <div id="share-btn">
            <img src="snap.png" alt="Snapchat Logo" width="54" height="54">
        </div>
        <div id="minimap-container">
            <canvas id="minimap" width="200" height="200"></canvas>
        </div>

        <div id="movement-zone">
            <div id="stick-knob">
                <div id="heading-arrow"></div>
            </div>
        </div>

    </div>

    <div id="share-modal">
        <div id="share-modal-content">
            <button id="share-modal-close">√ó</button>
            <h2 id="share-modal-title" style="margin:5px 0 10px; font-size:20px; color:#ffffff; text-align:center; font-weight:600; letter-spacing:0.5px;">Share the game!</h2>
            <img src="qr.png" alt="QR Code" style="display:block; margin: 15px auto 25px; max-width: 150px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">
            <div id="share-controls" style="display:flex; gap:10px; align-items:center; margin-top:25px;">
                <input id="share-link" type="text" value="https://rookeryphysics.github.io/drive" readonly style="flex:1; padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.3); background:rgba(255,255,255,0.08); color:#ffffff; font-size:14px;">
                <button id="copy-link-btn" style="padding:10px 14px; border-radius:8px; border:1px solid rgba(255,255,255,0.3); background:rgba(0,0,0,0.4); color:#ffffff; cursor:pointer;">Copy</button>
            </div>
            <div class="share-separator" style="margin-top:24px; text-align:center; font-weight:600; color:#ffffff; font-size:12px; opacity:0.85; letter-spacing:2px;">OR</div>
            <div class="snapchat-creative-kit-share" data-size="large" data-theme="dark" data-share-url="https://rookeryphysics.github.io/drive" data-share-text="Come drive this voxel racer!" style="display:flex; justify-content:center; align-items:center; margin:24px auto 0;"></div>
        </div>
    </div>

    <div id="vehicle-modal">
        <button id="vehicle-modal-close">√ó</button>
        <canvas id="modal-canvas"></canvas>
        <div id="color-palette"></div>
    </div>

    <div id="game-over-modal">
        <div id="game-over-content">
            <h2>GAME OVER</h2>
            <p id="go-top-score">Top Score: 0</p>
        </div>
    </div>

    <div id="game-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Variables ---
        let scene, camera, renderer;
        let uiScene, uiCamera;
        let miniatureGroup;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Modal Variables
        let vehicleModalOpen = false;
        let modalScene, modalCamera, modalRenderer;
        let modalCarGroup;
        let holdTimer = null;
        let isHolding = false;
        const HOLD_DURATION = 600; // ms
        const vehicleModal = document.getElementById('vehicle-modal');
        const vehicleModalClose = document.getElementById('vehicle-modal-close');

        // Modal Car Dragging
        let isDraggingModalCar = false;
        let lastDragX = 0;
        // Paint Logic
        let selectedColor = 0xff0000; // Default red
        const vehicleColors = {
            supercar: { body: 0xffffff, spoiler: 0x000000 }, // Default body white, spoiler black
            hypercar: { body: 0xFFD700, spoiler: 0x111111 } // Default body gold, spoiler dark grey
        };
        const paintColors = [
            0xFF0000, 0xFF7F00, 0xFFFF00, 0x7FFF00, 0x00FF00, 0x00FF7F, 
            0x00FFFF, 0x007FFF, 0x0000FF, 0x7F00FF, 0xFF00FF, 0xFF007F,
            0xFFFFFF, 0xCCCCCC, 0x888888, 0x444444, 0x000000, 0xFF1493,
            0x00008B, 0x5F9EA0, 0x4682B4, 0x20B2AA, 0x008080, 0x008B8B
        ];
        let paintRaycaster = new THREE.Raycaster();
        let modalMouse = new THREE.Vector2();
        let isPaintClick = false;

        let player;
        let initialSpawnX = 0;
        let initialSpawnZ = 0;
        let carType = 'hypercar';
        let currentCarMesh = null;
        let ambientLight, sunLight;

        let isNightMode = false;
        
        let controlMode = 'vehicle'; // 'vehicle' or 'pedestrian'
        let userPedestrian = null;
        
        // ... (skipping lines to match context if needed, but I can just replace the block down to initVehicleModal if I'm careful, or just separate calls)
        // Actually, I will do separate replacements to be safe.


        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        const scoreElement = document.getElementById('score-board');
        const fpsElement = document.getElementById('fps-counter');

        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d', { alpha: false }); // Opt for speed

        const allPedestrians = [];
        const activeObstacles = [];
        const particles = [];
        const trafficVehicles = []; // NPC Cars

        // Snow System
        let snowSystem, snowGeo;
        const snowCount = 2500;
        const snowRange = 320;
        const lastSnowPlayerPos = new THREE.Vector3();

        // Cache materials to reduce draw calls
        const materialCache = new Map();
        const buildingMaterialCache = new Map();

        // Pre-computed Textures
        let dayGroundTexture, nightGroundTexture;
        let lightSpotTexture;

        let lastChunkUpdatePos = new THREE.Vector3(99999, 99999, 99999);

        const pedGeometries = {};
        const buildingGeometries = {};
        let groundGeometry, groundMaterial;
        let roadTileGeometry, roadMaterial;
        let lineTileGeometry, lineMaterial;
        let grassGeometry, grassMaterial;
        let poleGeometry, poleMaterial, lightBulbGeometry, lightBulbMaterial;
        let lightSpotGeometry, lightSpotMaterial;

        const CULL_DIST = 220;
        const CULL_DIST_SQ = CULL_DIST * CULL_DIST;
        const CHUNK_SIZE = 200;
        const CHUNK_RENDER_DIST = 1;
        const activeChunks = new Map();
        const ROAD_TILE_SIZE = 10;
        const ROAD_WIDTH_THRESHOLD = 0.25;

        // Physics
        let PLAYER_SPEED = 0.15;
        const FRICTION = 0.97;
        const BRAKING_FRICTION = 0.90;
        let MAX_SPEED = 2.0;
        const PLAYER_BASE_Y = 0.05;
        const GRAVITY = 0.02;
        let isGameOver = false;
        let isAirborne = false;

        // Movement
        const velocity = new THREE.Vector3();
        let moveInput = { x: 0, y: 0 };
        const keysPressed = {};

        // Camera
        let cameraAngle = 0;
        let cameraVerticalAngle = 0.5;
        const CAMERA_DIST = 25;
        let isManualCamera = false;
        let manualCamTimer = 0;

        // Input
        let moveTouchId = null;
        let camTouchId = null;
        let camLastPos = { x: 0, y: 0 };
        const joystickRadius = 90;
        let lastTapTime = 0;

        // FPS
        let lastTime = performance.now();
        let frameCount = 0;
        let globalFrame = 0; // For throttling minimap

        // Elements
        const stickKnob = document.getElementById('stick-knob');
        const headingArrow = document.getElementById('heading-arrow');
        const movementZone = document.getElementById('movement-zone');

        const timeBtn = document.getElementById('time-btn');
        const collapseBtn = document.getElementById('collapse-btn');
        const shareBtn = document.getElementById('share-btn');
        const shareModal = document.getElementById('share-modal');
        const shareModalClose = document.getElementById('share-modal-close');
        const shareLinkInput = document.getElementById('share-link');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const snapShareDiv = document.querySelector('.snapchat-creative-kit-share');
        const snapFallbackLink = document.getElementById('snap-fallback-link');

        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');

            // Compute absolute share URL for reliability across domains/hosts
            const shareUrl = new URL('/drive', window.location.origin).toString().replace(/\/$/, '');
            if (shareLinkInput) shareLinkInput.value = shareUrl;
            if (snapShareDiv) {
                snapShareDiv.setAttribute('data-share-url', shareUrl);
                if (!snapShareDiv.getAttribute('data-share-text')) {
                    snapShareDiv.setAttribute('data-share-text', 'Come drive this voxel racer!');
                }
            }
            if (snapFallbackLink) {
                snapFallbackLink.href = 'https://www.snapchat.com/compose?attachmentUrl=' + encodeURIComponent(shareUrl);
            }

            scene = new THREE.Scene();

            // Initial Day Mode Setup
            const dayColor = 0x87CEEB;
            scene.background = new THREE.Color(dayColor);
            scene.fog = new THREE.Fog(0xa0d8ef, 50, 240);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 800);

            // Optimization: Limit pixel ratio to 1.5. Mobile screens don't need native 4k.
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            // Optimization: Smaller shadow map texture
            sunLight.shadow.mapSize.width = 512;
            sunLight.shadow.mapSize.height = 512;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            const d = 100;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            scene.add(sunLight);

            // UI Scene
            uiScene = new THREE.Scene();
            uiCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            uiCamera.position.z = 10;

            const uiAmb = new THREE.AmbientLight(0xffffff, 0.8);
            uiScene.add(uiAmb);
            const uiDir = new THREE.DirectionalLight(0xffffff, 1.0);
            uiDir.position.set(2, 5, 5);
            uiScene.add(uiDir);

            miniatureGroup = new THREE.Group();
            updateMiniaturePosition();
            uiScene.add(miniatureGroup);

            // PRE-GENERATE TEXTURES (Speed Boost)
            dayGroundTexture = createGroundTexture(false);
            nightGroundTexture = createGroundTexture(true);

            // Geometry Init
            initPedestrianGeometries();
            initWorldGeometries();

            // Player Init
            createPlayer();
            updateMiniatureModel();
            createSnow();

            // Entities - Reduced count slightly for mobile optimization
            for (let i = 0; i < 200; i++) {
                createPedestrianData();
            }

            // Events
            window.addEventListener('resize', onWindowResize);
            
            // Keyboard Controls
            document.addEventListener('keydown', (e) => {
                if (moveTouchId !== null) return;
                const k = e.key;
                if (['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(k) || 
                    ['W','A','S','D'].includes(k)) {
                    keysPressed[k.toLowerCase()] = true;
                    if (k.startsWith('Arrow')) keysPressed[k] = true; // Handle Arrow keys specifically if needed or just normalize
                    updateMoveInputFromKeys();
                }
            });
            document.addEventListener('keyup', (e) => {
                const k = e.key;
                if (['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(k) || 
                    ['W','A','S','D'].includes(k)) {
                    keysPressed[k.toLowerCase()] = false;
                    if (k.startsWith('Arrow')) keysPressed[k] = false;
                    if (moveTouchId === null) updateMoveInputFromKeys();
                }
            });
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            document.addEventListener('mousedown', onMouseDown);



            timeBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); toggleDayNight(); });
            timeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleDayNight(); }, { passive: false });

            collapseBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); toggleHUD(); });
            collapseBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleHUD(); }, { passive: false });

            shareBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); openShareModal(); });
            shareBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); openShareModal(); }, { passive: false });

            shareModalClose.addEventListener('click', closeShareModal);
            shareModal.addEventListener('click', (e) => { if (e.target === shareModal) closeShareModal(); });

            copyLinkBtn.addEventListener('click', copyShareLink);

            // Mobile touch handlers for modal actions
            shareModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closeShareModal(); }, { passive: false });
            shareModal.addEventListener('touchstart', (e) => {
                if (e.target === shareModal) { e.preventDefault(); e.stopPropagation(); closeShareModal(); }
            }, { passive: false });
            copyLinkBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); copyShareLink(); }, { passive: false });

            // Event listeners for modal car dragging and painting
            const mCanvas = document.getElementById('modal-canvas');
            mCanvas.addEventListener('mousedown', onModalMouseDown, false);
            mCanvas.addEventListener('mousemove', onModalMouseMove, false);
            mCanvas.addEventListener('mouseup', onModalMouseUp, false);
            mCanvas.addEventListener('mouseleave', onModalMouseUp, false);

            mCanvas.addEventListener('touchstart', onModalTouchStart, { passive: false });
            mCanvas.addEventListener('touchmove', onModalTouchMove, { passive: false });
            mCanvas.addEventListener('touchend', onModalTouchEnd, { passive: false });

            vehicleModalClose.addEventListener('click', closeVehicleModal);
            vehicleModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closeVehicleModal(); }, { passive: false });

            initVehicleModal();
            initColorPalette();
        }

        // --- Vehicle Modal Functions ---
        function initColorPalette() {
            const container = document.getElementById('color-palette');
            paintColors.forEach((col, index) => {
                const div = document.createElement('div');
                div.className = 'color-swatch';
                div.style.backgroundColor = '#' + new THREE.Color(col).getHexString();
                div.dataset.color = col;
                if (index === 0) div.classList.add('selected');
                
                div.addEventListener('click', (e) => {
                    // Prevent modal drag/close
                    e.stopPropagation(); 
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                });
                // Touch support
                div.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent ghost clicks
                    e.stopPropagation();
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                }, { passive: false });

                container.appendChild(div);
            });
        }

        function onModalMouseDown(event) {
            if (event.target === vehicleModalClose) return;
            isDraggingModalCar = true;
            isPaintClick = true; // Assume click until moved
            lastDragX = event.clientX;
        }

        function onModalMouseMove(event) {
            if (!isDraggingModalCar) return;
            isPaintClick = false; // Movement detected, not a static click
            const deltaX = event.clientX - lastDragX;
            modalCarGroup.rotation.y += deltaX * 0.015;
            lastDragX = event.clientX;
        }

        function onModalMouseUp(event) {
            if (isDraggingModalCar && isPaintClick) {
                // It was a click!
                handlePaintClick(event.clientX, event.clientY);
            }
            isDraggingModalCar = false;
        }

        function onModalTouchStart(event) {
            if (event.target === vehicleModalClose) return;
            isDraggingModalCar = true;
            isPaintClick = true;
            lastDragX = event.touches[0].clientX;
            event.preventDefault();
        }

        function onModalTouchMove(event) {
            if (!isDraggingModalCar) return;
            const currentX = event.touches[0].clientX;
            // Threshold for "movement" to avoid micro-jitters preventing clicks
            if (Math.abs(currentX - lastDragX) > 2) {
                isPaintClick = false;
            }
            const deltaX = currentX - lastDragX;
            modalCarGroup.rotation.y += deltaX * 0.015;
            lastDragX = currentX;
            event.preventDefault();
        }

        function onModalTouchEnd(event) {
            if (isDraggingModalCar && isPaintClick) {
                // Use changedTouches for position
                const t = event.changedTouches[0];
                handlePaintClick(t.clientX, t.clientY);
            }
            isDraggingModalCar = false;
            event.preventDefault(); // Prevent double firing if browser synthesizes mouse events
        }

        function handlePaintClick(clientX, clientY) {
            // Raycast logic
            if (!modalRenderer || !modalCamera) return;

            const rect = modalRenderer.domElement.getBoundingClientRect();
            modalMouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            modalMouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            paintRaycaster.setFromCamera(modalMouse, modalCamera);

            // Intersect with modal car
            // Note: modalCarGroup has a child which is the car Group
            const intersects = paintRaycaster.intersectObjects(modalCarGroup.children, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const mesh = hit.object;
                
                if (mesh.isMesh) {
                    if (mesh.userData.paintable === false || mesh.userData.partGroup === 'light' || mesh.userData.partGroup === 'non-paintable') return; // Non-paintable parts like wheels, lights, etc.

                    if (mesh.userData.partType === 'glass') {
                        // For glass, create a new transparent material
                        mesh.material = new THREE.MeshStandardMaterial({
                            color: selectedColor,
                            transparent: true,
                            opacity: 0.6, // Adjust for desired transparency
                            metalness: 0.8,
                            roughness: 0.1
                        });
                        // Save glass color separately if needed, or assume it's not persistently customizable
                    } else if (mesh.userData.partGroup === 'body') {
                        // For body parts
                        mesh.material.color.setHex(selectedColor);
                        vehicleColors[carType].body = selectedColor; // Save body color
                    } else if (mesh.userData.partGroup === 'spoiler') {
                        // For spoiler parts
                        mesh.material.color.setHex(selectedColor);
                        vehicleColors[carType].spoiler = selectedColor; // Save spoiler color
                    }
                    
                    // If emissive exists and is not black, update it too? 
                    // This part remains unchanged, typically emissive is for lights.
                    if (mesh.material.emissive && mesh.material.emissive.getHex() > 0) {
                         // Only if it's not a light component we probably shouldn't touch emissive
                         // For now just albedo.
                    }

                    // Sync with Player Car
                    // Find the index of this mesh in the modal hierarchy
                    // The structure is modalCarGroup -> carGroup -> [Mesh1, Mesh2, ...]
                    // We need to find which child index of carGroup matches `mesh`.
                    
                    const carGroup = modalCarGroup.children[0];
                    if (!carGroup) return;
                    
                    let foundIndex = -1;
                    for (let i = 0; i < carGroup.children.length; i++) {
                        if (carGroup.children[i] === mesh) {
                            foundIndex = i;
                            break;
                        }
                    }

                    if (foundIndex !== -1 && currentCarMesh) {
                        const playerMeshPart = currentCarMesh.children[foundIndex];
                        if (playerMeshPart && playerMeshPart.isMesh) {
                            if (playerMeshPart.userData.partType === 'glass') {
                                playerMeshPart.material = new THREE.MeshStandardMaterial({
                                    color: selectedColor,
                                    transparent: true,
                                    opacity: 0.6,
                                    metalness: 0.8,
                                    roughness: 0.1
                                });
                            } else {
                                playerMeshPart.material.color.setHex(selectedColor);
                            }
                        }
                    }
                }
            }
        }


        function initVehicleModal() {
            modalScene = new THREE.Scene();
            modalCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            modalCamera.position.set(0, 1.25, 3.5); // Adjusted Y and Z for smaller car and lower car
            modalCamera.lookAt(0, -1.05, 0); // Look lower to shift vehicle up

            const canvas = document.getElementById('modal-canvas');
            modalRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            modalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            modalRenderer.setClearColor(0x000000, 0); // Transparent

            // Lights for modal
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            modalScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(5, 10, 5);
            modalScene.add(dir);
            const spot = new THREE.SpotLight(0xffffff, 0.8);
            spot.position.set(-5, 5, 5);
            modalScene.add(spot);

            modalCarGroup = new THREE.Group();
            modalScene.add(modalCarGroup);
        }

        function openVehicleModal() {
            vehicleModal.classList.add('active');
            vehicleModalOpen = true;

            const width = vehicleModal.clientWidth;
            const height = vehicleModal.clientHeight;
            modalRenderer.setSize(width, height, false);
            modalCamera.aspect = width / height;
            modalCamera.updateProjectionMatrix();

            // Clear previous
            while (modalCarGroup.children.length > 0) {
                modalCarGroup.remove(modalCarGroup.children[0]);
            }

            // Build current car for modal
            const mesh = createVehicle({
                type: carType,
                bodyColor: vehicleColors[carType].body, // Pass saved body color
                spoilerColor: vehicleColors[carType].spoiler, // Pass saved spoiler color
                addLights: true,
                scale: 0.25
            });
            
            // Rotate continuously in animate loop
            modalCarGroup.add(mesh);
            
            // Pause game? Maybe just set flag to ignore inputs
        }

        function closeVehicleModal() {
            vehicleModal.classList.remove('active');
            vehicleModalOpen = false;
        }

        // --- Share Modal Functions ---
        function openShareModal() {
            shareModal.classList.add('active');
        }

        function closeShareModal() {
            shareModal.classList.remove('active');
        }

        function copyShareLink() {
            const text = shareLinkInput.value;
            const showCopied = () => {
                copyLinkBtn.textContent = 'Copied!';
                setTimeout(() => { copyLinkBtn.textContent = 'Copy'; }, 1200);
            };
            const fallbackCopy = () => {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'fixed';
                    ta.style.top = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    showCopied();
                } catch (err) {
                    showCopied();
                }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(showCopied).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        }

        // --- Day/Night Toggle System (Updated for Brightness) ---

        function toggleHUD() {
            document.body.classList.toggle('hud-hidden');
            const isHidden = document.body.classList.contains('hud-hidden');
            collapseBtn.innerText = isHidden ? '‚ñ∂' : '‚óÄ';
            if (miniatureGroup) {
                miniatureGroup.visible = !isHidden;
            }
        }

        function toggleDayNight() {
            isNightMode = !isNightMode;

            if (isNightMode) {
                const duskColor = 0x1a1a2e;
                scene.background.setHex(duskColor);
                scene.fog.color.setHex(duskColor);
                scene.fog.near = 30;
                scene.fog.far = 180;

                // BRIGHTER NIGHT SETTINGS
                ambientLight.intensity = 0.55;
                sunLight.color.setHex(0xaaccff);
                sunLight.intensity = 0.6;

                const instr = document.querySelector('.instructions');
                if (instr) instr.innerHTML = "Night Run<br>Left Stick: Drive";
                timeBtn.innerText = "‚òÄÔ∏è";

                roadMaterial.color.setHex(0x222222);
                lineMaterial.color.setHex(0xaa8800);
                grassMaterial.color.setHex(0x335533);
                lightBulbMaterial.emissiveIntensity = 3.0; // Very bright
                lightSpotMaterial.opacity = 0.8; // Turn on ground spots

                // Swap texture instantly
                groundMaterial.map = nightGroundTexture;

            } else {
                const dayColor = 0x87CEEB;
                scene.background.setHex(dayColor);
                scene.fog.color.setHex(0xa0d8ef);
                scene.fog.near = 50;
                scene.fog.far = 240;

                ambientLight.intensity = 0.6;
                sunLight.color.setHex(0xffffff);
                sunLight.intensity = 0.8;

                const instr = document.querySelector('.instructions');
                if (instr) instr.innerHTML = "Day Run<br>Left Stick: Drive";
                timeBtn.innerText = "üåô";

                roadMaterial.color.setHex(0x333333);
                lineMaterial.color.setHex(0xffcc00);
                grassMaterial.color.setHex(0x44aa44);
                lightBulbMaterial.emissiveIntensity = 0.2; // Dim
                lightSpotMaterial.opacity = 0.0; // Hide ground spots

                // Swap texture instantly
                groundMaterial.map = dayGroundTexture;
            }

            // Update buildings to swap window textures
            activeChunks.forEach(chunk => {
                chunk.mesh.traverse(child => {
                    if (child.userData.isBuilding) {
                        const seed = child.userData.seed;
                        // Swap entire material reference to cached Day/Night material
                        child.material = getBuildingMaterial(seed, isNightMode);
                    }
                });
            });

            // Update traffic lights
            trafficVehicles.forEach(npc => {
                npc.mesh.traverse(child => {
                    if (child.isLight) {
                        // Only enable spotlights at night
                        child.visible = isNightMode;
                    }
                });
            });

            loadCarModel(carType);
        }

        // --- Miniature UI ---

        function updateMiniaturePosition() {
            const aspect = window.innerWidth / window.innerHeight;
            const visibleHeight = 2 * Math.tan((uiCamera.fov * Math.PI / 180) / 2) * uiCamera.position.z;
            const visibleWidth = visibleHeight * aspect;
            const unitsPerPixel = visibleHeight / window.innerHeight;
            const yOffsetPixels = 140;
            const xOffsetPixels = 70;
            const x = visibleWidth / 2 - (xOffsetPixels * unitsPerPixel);
            const y = -visibleHeight / 2 + (yOffsetPixels * unitsPerPixel);
            miniatureGroup.position.set(x, y, 0);
        }

        function updateMiniatureModel() {
            while (miniatureGroup.children.length > 0) {
                miniatureGroup.remove(miniatureGroup.children[0]);
            }
            const targetType = (carType === 'supercar') ? 'hypercar' : 'supercar';
            const mesh = createVehicle({
                type: targetType,
                color: vehicleColors[targetType],
                addLights: false,
                scale: targetType === 'supercar' ? 0.4 : 0.35
            });
            mesh.position.y = -0.5;
            miniatureGroup.add(mesh);
            miniatureGroup.userData.targetType = targetType;
        }

        function checkMiniatureClick(clientX, clientY) {
            if (!miniatureGroup.visible) return false;
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, uiCamera);
            const intersects = raycaster.intersectObjects(miniatureGroup.children, true);
            if (intersects.length > 0) {
                // toggleCarModel(); // Moved to input handlers
                return true;
            }
            return false;
        }

        function checkVehicleTap(clientX, clientY) {
            if (!player) return false;
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(player.children, true);
            return intersects.length > 0;
        }

        function handleVehicleTap() {
            if (controlMode === 'vehicle') {
                velocity.set(0, 0, 0);
                spawnPedestrianBesidePlayer();
            } else if (controlMode === 'pedestrian') {
                enterVehicle();
            }
        }

        function enterVehicle() {
            if (userPedestrian) {
                scene.remove(userPedestrian.mesh);
                userPedestrian = null;
            }
            controlMode = 'vehicle';
            centerCamera();
        }

        function spawnPedestrianBesidePlayer() {
            // Remove from allPedestrians if we are recycling createPedestrianData
            // But createPedestrianData adds to allPedestrians array.
            // We should create a separate pedestrian for the user.
            
            const angle = player.rotation.y + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
            const dist = 5.0;
            const pos = new THREE.Vector3(
                player.position.x + Math.sin(angle) * dist,
                2.0,
                player.position.z + Math.cos(angle) * dist
            );

            // Create user pedestrian data manually to avoid AI loop interference
            userPedestrian = {
                position: pos,
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: Math.atan2(player.position.x - pos.x, player.position.z - pos.z),
                animPhase: 0,
                mesh: null,
                colors: { shirt: 0x111111, pants: 0x000000, skin: 0xffccaa },
                isUser: true
            };

            userPedestrian.mesh = buildPedestrianMesh(userPedestrian);
            userPedestrian.mesh.position.copy(userPedestrian.position);
            userPedestrian.mesh.rotation.y = userPedestrian.rotation;
            scene.add(userPedestrian.mesh);

            controlMode = 'pedestrian';
        }

        // --- Infinite Map System ---

        function createLightSpotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, 'rgba(255, 255, 200, 0.8)'); // Bright warm center
            grd.addColorStop(0.3, 'rgba(255, 255, 220, 0.3)');
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function initWorldGeometries() {
            groundGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
            groundMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.9, metalness: 0.1, map: dayGroundTexture
            });

            roadTileGeometry = new THREE.PlaneGeometry(ROAD_TILE_SIZE, ROAD_TILE_SIZE);
            roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.2 });

            lineTileGeometry = new THREE.PlaneGeometry(2, 6);
            lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

            buildingGeometries.small = new THREE.BoxGeometry(10, 30, 10);
            buildingGeometries.tall = new THREE.BoxGeometry(15, 80, 15);
            buildingGeometries.wide = new THREE.BoxGeometry(30, 25, 20);

            // Grass Geometry
            grassGeometry = new THREE.PlaneGeometry(0.8, 2.0);
            grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x44aa44,
                roughness: 1.0,
                side: THREE.DoubleSide
            });

            // Streetlight Geometries
            const poleH = 14;
            const pGeo = new THREE.CylinderGeometry(0.4, 0.4, poleH);
            pGeo.translate(0, poleH / 2, 0);
            poleGeometry = pGeo;

            poleMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 });

            // Light Bulb (Emissive) - A bit larger
            lightBulbGeometry = new THREE.BoxGeometry(1.5, 0.3, 0.8);
            lightBulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffaa,
                emissive: 0xffaa00,
                emissiveIntensity: 0.2
            });

            // Light Spot on Road (Fake volumetric lighting)
            lightSpotTexture = createLightSpotTexture();

            // SIGNIFICANTLY WIDENED LIGHT SPOT
            lightSpotGeometry = new THREE.PlaneGeometry(70, 70);

            lightSpotMaterial = new THREE.MeshBasicMaterial({
                map: lightSpotTexture,
                transparent: true,
                opacity: 0,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
        }

        function createGroundTexture(isNight) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            if (isNight) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#e0e0e0';
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#e0e0e0';
            }

            ctx.lineWidth = 4;
            const cells = 4;
            const step = 256 / cells;
            for (let i = 0; i <= cells; i++) {
                ctx.beginPath(); ctx.moveTo(i * step, 0); ctx.lineTo(i * step, 256); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * step); ctx.lineTo(256, i * step); ctx.stroke();
            }

            ctx.fillStyle = isNight ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const w = Math.random() * 10 + 2;
                ctx.fillRect(x, y, w, w);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Generate a building texture with windows
        function createBuildingTexture(seed, isNight) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Base Color
            const baseColor = isNight
                ? (seed > 0.5 ? '#222233' : '#111122')
                : (seed > 0.5 ? '#cccccc' : '#99aadd');

            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 128, 128);

            // Windows
            const rows = 8;
            const cols = 4;
            const pW = 128 / cols;
            const pH = 128 / rows;
            const gap = 6;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Chance for light to be on/off
                    const lightOn = Math.random() > 0.4;

                    if (isNight) {
                        if (lightOn) {
                            ctx.fillStyle = Math.random() > 0.5 ? '#ffcc66' : '#ffeeaa'; // Yellow/Warm light
                        } else {
                            ctx.fillStyle = '#000000'; // Dark
                        }
                    } else {
                        // Day windows (reflection)
                        ctx.fillStyle = '#334455';
                    }

                    ctx.fillRect((c * pW) + gap, (r * pH) + gap, pW - (gap * 2), pH - (gap * 2));
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function pseudoRandom(x, z) {
            const val = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
            return val - Math.floor(val);
        }

        // Raw Road Function for flow calculations
        function getRawRoadValue(x, z) {
            const scale = 0.005;
            const v1 = Math.sin(x * scale) + Math.cos(z * scale);
            const v2 = Math.sin(x * scale * 0.5 + z * scale * 0.2) * 0.5;
            return v1 + v2;
        }

        // Visual Road Value (Absolute)
        function getRoadValue(x, z) {
            return Math.abs(getRawRoadValue(x, z));
        }

        // Calculate tangent of the road isoline for smooth traffic flow
        function getRoadTangent(x, z) {
            const scale = 0.005;
            // Function f = sin(xs) + cos(zs) + 0.5*sin(xs0.5 + zs0.2)
            // Derivative wrt x:
            const dx = scale * Math.cos(x * scale) + 0.5 * scale * 0.5 * Math.cos(x * scale * 0.5 + z * scale * 0.2);
            // Derivative wrt z:
            const dz = -scale * Math.sin(z * scale) + 0.5 * scale * 0.2 * Math.cos(x * scale * 0.5 + z * scale * 0.2);

            // Tangent is perpendicular to gradient (dx, dz).
            // T = (-dz, dx) or (dz, -dx).
            const t = new THREE.Vector3(-dz, 0, dx);
            t.normalize();
            return t;
        }

        function disposeChunk(chunkData) {
            if (!chunkData) return;
            const group = chunkData.mesh;
            // Iterate and dispose geometries/materials
            group.traverse(child => {
                if (child.isMesh) {
                    // Don't dispose shared geometries
                }
            });
            scene.remove(group);
        }

        function updateChunks() {
            if (!player) return;
            if (player.position.distanceToSquared(lastChunkUpdatePos) < 2500) return;
            lastChunkUpdatePos.copy(player.position);
            const px = player.position.x;
            const pz = player.position.z;
            const currentChunkX = Math.floor(px / CHUNK_SIZE + 0.5);
            const currentChunkZ = Math.floor(pz / CHUNK_SIZE + 0.5);

            const newKeys = new Set();

            // Generate valid keys
            for (let x = -CHUNK_RENDER_DIST; x <= CHUNK_RENDER_DIST; x++) {
                for (let z = -CHUNK_RENDER_DIST; z <= CHUNK_RENDER_DIST; z++) {
                    const cx = currentChunkX + x;
                    const cz = currentChunkZ + z;
                    const key = `${cx},${cz}`;
                    newKeys.add(key);
                    if (!activeChunks.has(key)) createChunk(cx, cz);
                }
            }

            // Garbage Collection
            for (const [key, chunkData] of activeChunks) {
                if (!newKeys.has(key)) {
                    disposeChunk(chunkData);
                    activeChunks.delete(key);
                }
            }
        }

        function getBuildingMaterial(seed, isNight) {
            // Bucket seed into 3 types to reduce material count
            let type = 0;
            if (seed < 0.3) type = 1;
            else if (seed < 0.6) type = 2;
            else type = 3;

            const key = `${type}_${isNight}`;
            if (!buildingMaterialCache.has(key)) {
                // Generate texture for this bucket
                const map = createBuildingTexture(seed, isNight);
                const mat = new THREE.MeshStandardMaterial({
                    map: map,
                    roughness: 0.3,
                    metalness: 0.1
                });
                if (isNight) {
                    mat.emissive = new THREE.Color(0x222222); // Slight glow for windows visibility
                    mat.emissiveMap = map;
                    mat.emissiveIntensity = 0.5;
                }
                buildingMaterialCache.set(key, mat);
            }
            return buildingMaterialCache.get(key);
        }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            const chunkX = cx * CHUNK_SIZE;
            const chunkZ = cz * CHUNK_SIZE;
            group.position.set(chunkX, 0, chunkZ);

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.frustumCulled = false;
            group.add(ground);

            const roadMatrices = [];
            const lineMatrices = [];
            const poleMatrices = [];
            const armMatrices = [];
            const bulbMatrices = [];
            const spotMatrices = [];

            const obstacles = [];
            const roadMapPositions = [];
            const roadSet = new Set();
            const halfSize = CHUNK_SIZE / 2;

            // Pre-allocate Objects to avoid GC
            const dummy = new THREE.Object3D();

            for (let lx = -halfSize; lx < halfSize; lx += ROAD_TILE_SIZE) {
                for (let lz = -halfSize; lz < halfSize; lz += ROAD_TILE_SIZE) {
                    const wx = chunkX + lx + ROAD_TILE_SIZE / 2;
                    const wz = chunkZ + lz + ROAD_TILE_SIZE / 2;

                    const rawVal = getRawRoadValue(wx, wz);
                    const val = Math.abs(rawVal);

                    if (val < ROAD_WIDTH_THRESHOLD) {
                        // IT IS ROAD
                        dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.1, lz + ROAD_TILE_SIZE / 2);
                        dummy.rotation.x = -Math.PI / 2;
                        dummy.rotation.y = 0;
                        dummy.rotation.z = 0;
                        dummy.scale.set(1, 1, 1);
                        dummy.updateMatrix();

                        roadMatrices.push(dummy.matrix.clone());
                        roadSet.add(`${lx + ROAD_TILE_SIZE / 2},${lz + ROAD_TILE_SIZE / 2}`);
                        roadMapPositions.push({ x: wx, z: wz });

                        if (val < 0.03) {
                            dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.15, lz + ROAD_TILE_SIZE / 2);
                            dummy.updateMatrix();
                            lineMatrices.push(dummy.matrix.clone());
                        }

                        // --- NPC TRAFFIC SPAWNING ---
                        // Only spawn on valid "lanes" (between center and edge)
                        // Lanes are approx 0.05 to 0.20
                        if (val > 0.05 && val < 0.20) {
                            if (Math.random() < 0.02) { // 2% chance per road tile
                                spawnTrafficCar(wx, 0.5, wz, rawVal > 0);
                            }
                        }

                    } else {
                        // IT IS GRASS/GROUND
                        // CHECK IF WE ARE NEXT TO A ROAD (EDGE DETECTION)
                        // Check neighbors
                        const nRightVal = getRoadValue(wx + ROAD_TILE_SIZE, wz);
                        const nLeftVal = getRoadValue(wx - ROAD_TILE_SIZE, wz);
                        const nTopVal = getRoadValue(wx, wz + ROAD_TILE_SIZE);
                        const nBottomVal = getRoadValue(wx, wz - ROAD_TILE_SIZE);

                        let placeLight = false;
                        let rotY = 0;

                        const LIGHT_SPACING = 60; // Units apart
                        const FREQ_CHECK = (Math.abs(wx) + Math.abs(wz)) % LIGHT_SPACING < ROAD_TILE_SIZE;

                        if (FREQ_CHECK) {
                            if (nRightVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = Math.PI / 2; // Face Right
                            } else if (nLeftVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = -Math.PI / 2; // Face Left
                            } else if (nTopVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = 0; // Face Top (Z+)
                            } else if (nBottomVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = Math.PI; // Face Bottom
                            }
                        }

                        if (placeLight) {
                            const pX = lx + ROAD_TILE_SIZE / 2;
                            const pZ = lz + ROAD_TILE_SIZE / 2;

                            // 1. Pole Vertical
                            dummy.position.set(pX, 0, pZ);
                            dummy.rotation.set(0, rotY, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            poleMatrices.push(dummy.matrix.clone());

                            // 2. Bulb
                            const armLen = 5;
                            const bX = pX + Math.sin(rotY) * armLen;
                            const bZ = pZ + Math.cos(rotY) * armLen;

                            dummy.position.set(bX, 13.5, bZ);
                            dummy.rotation.set(0, rotY, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            bulbMatrices.push(dummy.matrix.clone());

                            // 3. Arm 
                            dummy.position.set(pX + Math.sin(rotY) * (armLen / 2), 13.8, pZ + Math.cos(rotY) * (armLen / 2));
                            dummy.rotation.set(Math.PI / 2, rotY, 0); // Lay flat
                            dummy.scale.set(1, 0.5, 1); // Length 7
                            dummy.updateMatrix();
                            armMatrices.push(dummy.matrix.clone());

                            // 4. Light Spot (Ground Glare)
                            dummy.position.set(bX, 0.16, bZ);
                            dummy.rotation.set(-Math.PI / 2, 0, 0); // Flat on ground
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            spotMatrices.push(dummy.matrix.clone());

                            obstacles.push({ x: chunkX + pX, z: chunkZ + pZ, radiusSq: 1.0, isLightpost: true, height: 14 });
                        }
                    }
                }
            }

            if (roadMatrices.length > 0) {
                const roadMesh = new THREE.InstancedMesh(roadTileGeometry, roadMaterial, roadMatrices.length);
                roadMesh.receiveShadow = true;
                for (let i = 0; i < roadMatrices.length; i++) roadMesh.setMatrixAt(i, roadMatrices[i]);
                group.add(roadMesh);
            }
            if (lineMatrices.length > 0) {
                const lineMesh = new THREE.InstancedMesh(lineTileGeometry, lineMaterial, lineMatrices.length);
                for (let i = 0; i < lineMatrices.length; i++) lineMesh.setMatrixAt(i, lineMatrices[i]);
                group.add(lineMesh);
            }
            if (poleMatrices.length > 0) {
                const poleMesh = new THREE.InstancedMesh(poleGeometry, poleMaterial, poleMatrices.length);
                poleMesh.castShadow = true;
                for (let i = 0; i < poleMatrices.length; i++) poleMesh.setMatrixAt(i, poleMatrices[i]);
                group.add(poleMesh);
            }
            if (bulbMatrices.length > 0) {
                const bulbMesh = new THREE.InstancedMesh(lightBulbGeometry, lightBulbMaterial, bulbMatrices.length);
                for (let i = 0; i < bulbMatrices.length; i++) bulbMesh.setMatrixAt(i, bulbMatrices[i]);
                group.add(bulbMesh);
            }
            if (armMatrices.length > 0) {
                const armMesh = new THREE.InstancedMesh(poleGeometry, poleMaterial, armMatrices.length);
                for (let i = 0; i < armMatrices.length; i++) armMesh.setMatrixAt(i, armMatrices[i]);
                group.add(armMesh);
            }
            if (spotMatrices.length > 0) {
                const spotMesh = new THREE.InstancedMesh(lightSpotGeometry, lightSpotMaterial, spotMatrices.length);
                for (let i = 0; i < spotMatrices.length; i++) spotMesh.setMatrixAt(i, spotMatrices[i]);
                group.add(spotMesh);
            }

            let seed = pseudoRandom(cx, cz);
            // obstacles array already initialized above
            const numObjects = seed > 0.8 ? 15 : (seed > 0.4 ? 4 : 2);

            for (let i = 0; i < numObjects; i++) {
                seed = pseudoRandom(seed, i);
                const bx = (pseudoRandom(seed * 10, i) - 0.5) * (CHUNK_SIZE - 20);
                const bz = (pseudoRandom(seed * 20, i) - 0.5) * (CHUNK_SIZE - 20);
                const snapX = Math.round(bx / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;
                const snapZ = Math.round(bz / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;

                let onRoad = false;
                if (roadSet.has(`${snapX},${snapZ}`)) onRoad = true;
                if (!onRoad) {
                    const worldX = chunkX + bx;
                    const worldZ = chunkZ + bz;
                    if (getRoadValue(worldX, worldZ) < ROAD_WIDTH_THRESHOLD + 0.1) onRoad = true;
                }

                if (onRoad) continue;

                let geo, radius, height, width, depth;
                if (seed < 0.3) { geo = buildingGeometries.small; radius = 8; height = 30; width = 10; depth = 10; }
                else if (seed < 0.6) { geo = buildingGeometries.tall; radius = 10; height = 80; width = 15; depth = 15; }
                else { geo = buildingGeometries.wide; radius = 15; height = 25; width = 30; depth = 20; }

                const mat = getBuildingMaterial(seed, isNightMode);
                const mesh = new THREE.Mesh(geo, mat);
                const rot = (pseudoRandom(seed * 30, i) * Math.PI * 4);
                mesh.position.set(bx, geo.parameters.height / 2, bz);
                mesh.rotation.y = rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.matrixAutoUpdate = false;
                mesh.updateMatrix();

                mesh.userData = { isBuilding: true, seed: seed };

                group.add(mesh);
                obstacles.push({ x: chunkX + bx, z: chunkZ + bz, radiusSq: radius * radius, isBuilding: true, rotation: rot, height: height, width: width, depth: depth });
            }



            scene.add(group);
            activeChunks.set(`${cx},${cz}`, { mesh: group, obstacles: obstacles, roads: roadMapPositions });
        }

        // --- Entities ---
        function initPedestrianGeometries() {
            pedGeometries.head = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            pedGeometries.body = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            pedGeometries.arm = new THREE.BoxGeometry(0.25, 1.0, 0.25);
            pedGeometries.arm.translate(0, -0.4, 0);
            pedGeometries.leg = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            pedGeometries.leg.translate(0, -0.6, 0);
            pedGeometries.robe = new THREE.BoxGeometry(0.9, 2.4, 0.6);
            pedGeometries.cape = new THREE.BoxGeometry(1.0, 2.2, 0.1);
            pedGeometries.turban = new THREE.BoxGeometry(0.68, 0.35, 0.68);
        }
        function createPedestrianData() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 200 + 50;
            const pedData = {
                position: new THREE.Vector3(Math.sin(angle) * dist, 2.0, Math.cos(angle) * dist),
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.2),
                rotation: Math.random() * Math.PI * 2,
                animPhase: Math.random() * 100,
                isActive: false, mesh: null,
                colors: { shirt: Math.random() * 0xffffff, pants: Math.random() * 0xffffff, skin: 0xffccaa }
            };
            allPedestrians.push(pedData);
        }
        function getCachedMaterial(colorHex) {
            const hex = Math.floor(colorHex);
            if (!materialCache.has(hex)) materialCache.set(hex, new THREE.MeshStandardMaterial({ color: hex }));
            return materialCache.get(hex);
        }
        function buildPedestrianMesh(data) {
            const group = new THREE.Group();
            const skinMat = getCachedMaterial(data.colors.skin);
            const shirtMat = getCachedMaterial(data.colors.shirt);
            const pantsMat = getCachedMaterial(data.colors.pants);
            const head = new THREE.Mesh(pedGeometries.head, skinMat); head.position.y = 0.9; head.castShadow = true; group.add(head);
            const body = new THREE.Mesh(pedGeometries.body, shirtMat); body.position.y = 0; body.castShadow = true; group.add(body);
            const armL = new THREE.Mesh(pedGeometries.arm, shirtMat); armL.position.set(-0.55, 0.4, 0); armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(pedGeometries.arm, shirtMat); armR.position.set(0.55, 0.4, 0); armR.castShadow = true; group.add(armR);
            const legL = new THREE.Mesh(pedGeometries.leg, pantsMat); legL.position.set(-0.25, -0.6, 0); legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(pedGeometries.leg, pantsMat); legR.position.set(0.25, -0.6, 0); legR.castShadow = true; group.add(legR);
            
            if (data.isUser) {
                const blackMat = getCachedMaterial(0x000000);
                const robe = new THREE.Mesh(pedGeometries.robe, blackMat);
                robe.position.y = -0.6;
                robe.castShadow = true;
                group.add(robe);

                const cape = new THREE.Mesh(pedGeometries.cape, blackMat);
                cape.position.set(0, -0.25, -0.35); // Lower on back
                cape.castShadow = true;
                group.add(cape);

                const greyMat = getCachedMaterial(0x555555);
                const turban = new THREE.Mesh(pedGeometries.turban, greyMat);
                turban.position.y = 1.35; // Head is at 0.9, height 0.6 (top 1.2). Turban height 0.35/2 = 0.175. 1.2+0.175 = 1.375 approx.
                turban.castShadow = true;
                group.add(turban);
            }

            // Assign limbs to userData, preserving existing properties if any
            if (!group.userData) group.userData = {};
            group.userData.limbs = { armL, armR, legL, legR };
            return group;
        }

        // --- CAR MODELS & HEADLIGHTS ---

        function createHeadlights(group, xOffset, y, z, intensity = 2) {
            // NPC lights only visible at night, controlled by toggle
            const spotL = new THREE.SpotLight(0xffffdd, intensity);
            spotL.position.set(-xOffset, y, z);
            spotL.angle = Math.PI / 6;
            spotL.penumbra = 0.3;
            spotL.decay = 1.5;
            spotL.distance = 60;
            spotL.castShadow = false;
            spotL.target.position.set(-xOffset, 0, z + 20);
            spotL.visible = isNightMode;
            spotL.isLight = true;
            group.add(spotL);
            group.add(spotL.target);

            const spotR = new THREE.SpotLight(0xffffdd, intensity);
            spotR.position.set(xOffset, y, z);
            spotR.angle = Math.PI / 6;
            spotR.penumbra = 0.3;
            spotR.decay = 1.5;
            spotR.distance = 60;
            spotR.target.position.set(xOffset, 0, z + 20);
            spotR.visible = isNightMode;
            spotR.isLight = true;
            group.add(spotR);
            group.add(spotR.target);
        }

        // --- Vehicle Abstraction ---
        function createVehicle(config) {
            const type = config.type || 'supercar';
            const bodyColor = config.bodyColor || null; // Use bodyColor
            const spoilerColor = config.spoilerColor || null; // Use spoilerColor
            const addLights = config.addLights !== undefined ? config.addLights : true;
            const scale = config.scale || 1.0;

            let mesh;
            if (type === 'supercar') {
                mesh = buildSupercarMesh(addLights, bodyColor, spoilerColor); // Pass body and spoiler colors
            } else if (type === 'hypercar') {
                mesh = buildHypercarMesh(addLights, bodyColor, spoilerColor); // Pass body and spoiler colors
            } else {
                mesh = buildSupercarMesh(addLights, bodyColor, spoilerColor); // Default to supercar
            }

            if (scale !== 1.0) {
                mesh.scale.set(scale, scale, scale);
            }

            return mesh;
        }

        function buildSupercarMesh(addLights = true, bodyColor = null, spoilerColor = null) {
            const group = new THREE.Group();

            // Materials
            const currentBodyColor = bodyColor ? bodyColor : vehicleColors.supercar.body;
            const currentSpoilerColor = spoilerColor ? spoilerColor : vehicleColors.supercar.spoiler;

            const bodyMat = new THREE.MeshStandardMaterial({ color: currentBodyColor, roughness: 0.3, metalness: 0.2 });
            const spoilerMat = new THREE.MeshStandardMaterial({ color: currentSpoilerColor, roughness: 0.3, metalness: 0.2 }); // Uses provided spoilerColor
            const secondaryMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.6 }); // Glossy black accents
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x223344, // Dark bluish tint
                roughness: 0.1,
                metalness: 0.7,
                transparent: true,
                opacity: 0.7 // Slightly transparent
            });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.2 });

            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity * 1.5 });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xaaccff, emissive: 0xaaccff, emissiveIntensity: lightIntensity });

            // Main Body (Split into Rear and Hood)
            // Rear Body (Chassis under cabin and rear)
            const mainBodyGeo = new THREE.BoxGeometry(2.1, 0.5, 3.6);
            const mainBody = new THREE.Mesh(mainBodyGeo, bodyMat);
            mainBody.position.set(0, 0.5, -0.5);
            mainBody.userData.partGroup = 'body'; // Mark as body part
            group.add(mainBody);

            // Side Skirts
            const skirtGeo = new THREE.BoxGeometry(0.2, 0.2, 3.0); // Depth, Height, Length
            const skirtL = new THREE.Mesh(skirtGeo, spoilerMat);
            skirtL.position.set(-1.15, 0.15, -0.5); // Positioned to the left side
            skirtL.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(skirtL);

            const skirtR = new THREE.Mesh(skirtGeo, spoilerMat);
            skirtR.position.set(1.15, 0.15, -0.5); // Positioned to the right side
            skirtR.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(skirtR);

            // Hood (Front nose)
            const hoodGeo = new THREE.BoxGeometry(2.1, 0.5, 1.0);
            const hood = new THREE.Mesh(hoodGeo, bodyMat);
            hood.position.set(0, 0.5, 1.8);
            hood.userData.partGroup = 'body'; // Mark as body part
            group.add(hood);

            // Cabin (Teardrop style)
            const cabinGeo = new THREE.BoxGeometry(1.3, 0.4, 2.2);
            const cabin = new THREE.Mesh(cabinGeo, glassMat);
            cabin.position.set(0, 0.9, 0.2);
            cabin.userData = { partType: 'glass', partGroup: 'glass' }; // Mark as glass part
            group.add(cabin);

            // Fenders (Wide arches)
            const fenderGeo = new THREE.BoxGeometry(0.6, 0.65, 1.2);
            const fl = new THREE.Mesh(fenderGeo, bodyMat); fl.position.set(-1.1, 0.525, 1.6); fl.userData.partGroup = 'body'; group.add(fl); // Mark as body part
            const fr = new THREE.Mesh(fenderGeo, bodyMat); fr.position.set(1.1, 0.525, 1.6); fr.userData.partGroup = 'body'; group.add(fr); // Mark as body part

            const rearFenderGeo = new THREE.BoxGeometry(0.7, 0.7, 1.4);
            const rl = new THREE.Mesh(rearFenderGeo, bodyMat); rl.position.set(-1.15, 0.55, -1.4); rl.userData.partGroup = 'body'; group.add(rl); // Mark as body part
            const rr = new THREE.Mesh(rearFenderGeo, bodyMat); rr.position.set(1.15, 0.55, -1.4); rr.userData.partGroup = 'body'; group.add(rr); // Mark as body part

            // Spoiler (Aggressive Wing)
            const wingPillarGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
            const pL = new THREE.Mesh(wingPillarGeo, spoilerMat); pL.position.set(-0.6, 0.9, -2.0); pL.userData.partGroup = 'spoiler'; group.add(pL); // Mark as spoiler part
            const pR = new THREE.Mesh(wingPillarGeo, spoilerMat); pR.position.set(0.6, 0.9, -2.0); pR.userData.partGroup = 'spoiler'; group.add(pR); // Mark as spoiler part

            const wingGeo = new THREE.BoxGeometry(2.8, 0.05, 0.8);
            const wing = new THREE.Mesh(wingGeo, spoilerMat);
            wing.position.set(0, 1.15, -2.1);
            wing.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(wing);

            // Lights
            // Rear light strip (Cyberpunk style)
            const stripGeo = new THREE.BoxGeometry(2.0, 0.1, 0.1);
            const strip = new THREE.Mesh(stripGeo, tailLightMat);
            strip.position.set(0, 0.6, -2.35);
            strip.userData.partGroup = 'light'; // Mark as light
            group.add(strip);

            // Headlights (Angled slits)
            const hlGeo = new THREE.BoxGeometry(0.5, 0.05, 0.2);
            const hlL = new THREE.Mesh(hlGeo, headLightMat); hlL.position.set(-0.9, 0.5, 2.3); hlL.rotation.y = 0.2; hlL.userData.partGroup = 'light'; group.add(hlL); // Mark as light
            const hlR = new THREE.Mesh(hlGeo, headLightMat); hlR.position.set(0.9, 0.5, 2.3); hlR.rotation.y = -0.2; hlR.userData.partGroup = 'light'; group.add(hlR); // Mark as light
                        // Wheels
                        const wheelGeo = new THREE.BoxGeometry(0.6, 0.8, 0.8); // Using box for style consistency with low poly
                        const positions = [
                            { x: -1.15, z: 1.6 }, { x: 1.15, z: 1.6 }, // Front
                            { x: -1.25, z: -1.4 }, { x: 1.25, z: -1.4 } // Rear (Wider)
                        ];
            
                        positions.forEach(pos => {
                            const w = new THREE.Mesh(wheelGeo, secondaryMat);
                            w.position.set(pos.x, 0.4, pos.z);
                            w.userData = { paintable: false };
                            group.add(w);
            
                            // Rim detail
                            const rim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.5), rimMat);
                            rim.position.set(pos.x + (pos.x > 0 ? 0.26 : -0.26), 0.4, pos.z);
                            rim.userData = { paintable: false };
                            group.add(rim);
                        });
            
                        if (addLights) {
                // Cooler blue-ish headlights for the black car
                createHeadlights(group, 0.9, 0.5, 2.4, 12.0);
            }

            return group;
        }

        function buildHypercarMesh(addLights = true, bodyColor = null, spoilerColor = null) {
            const group = new THREE.Group();
            const currentBodyColor = bodyColor ? bodyColor : vehicleColors.hypercar.body;
            const currentSpoilerColor = spoilerColor ? spoilerColor : vehicleColors.hypercar.spoiler;
            const bodyMat = new THREE.MeshStandardMaterial({ color: currentBodyColor, roughness: 0.2, metalness: 0.6 });
            const carbonMat = new THREE.MeshStandardMaterial({ color: currentSpoilerColor, roughness: 0.5, metalness: 0.5 }); // Carbon mat for spoiler is now paintable
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x223344, // Dark bluish tint
                roughness: 0.1,
                metalness: 0.7,
                transparent: true,
                opacity: 0.7 // Slightly transparent
            });

            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: lightIntensity });
            const exhaustMat = new THREE.MeshStandardMaterial({ color: 0x8888ff, metalness: 1.0, roughness: 0.2, emissive: 0x2222ff, emissiveIntensity: isNightMode ? 2.0 : 0.5 });

            const chassisGeo = new THREE.BoxGeometry(2.0, 0.5, 4.4);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat); chassis.position.y = 0.5; chassis.userData.partGroup = 'body'; group.add(chassis);
            const cabinGeo = new THREE.BoxGeometry(1.4, 0.5, 2.0);
            const cabin = new THREE.Mesh(cabinGeo, glassMat); cabin.position.set(0, 1.0, 0.2);
            cabin.userData = { partType: 'glass', partGroup: 'glass' };
            group.add(cabin);
            const fenderGeoFront = new THREE.BoxGeometry(0.8, 0.65, 1.2);
            const fenderGeoRear = new THREE.BoxGeometry(0.9, 0.72, 1.4);
            const fl = new THREE.Mesh(fenderGeoFront, bodyMat); fl.position.set(-1.2, 0.525, 1.4); fl.userData.partGroup = 'body'; group.add(fl);
            const fr = new THREE.Mesh(fenderGeoFront, bodyMat); fr.position.set(1.2, 0.525, 1.4); fr.userData.partGroup = 'body'; group.add(fr);
            const rl = new THREE.Mesh(fenderGeoRear, bodyMat); rl.position.set(-1.25, 0.6, -1.2); rl.userData.partGroup = 'body'; group.add(rl);
            const rr = new THREE.Mesh(fenderGeoRear, bodyMat); rr.position.set(1.25, 0.6, -1.2); rr.userData.partGroup = 'body'; group.add(rr);
            const skirtGeo = new THREE.BoxGeometry(0.4, 0.2, 2.0);
            const skirtL = new THREE.Mesh(skirtGeo, carbonMat); skirtL.position.set(-1.1, 0.3, 0.1); skirtL.userData.partGroup = 'spoiler'; group.add(skirtL);
            const skirtR = new THREE.Mesh(skirtGeo, carbonMat); skirtR.position.set(1.1, 0.3, 0.1); skirtR.userData.partGroup = 'spoiler'; group.add(skirtR);
            const wingPillarGeo = new THREE.BoxGeometry(0.2, 0.6, 0.4);
            const wpL = new THREE.Mesh(wingPillarGeo, carbonMat); wpL.position.set(-0.5, 0.8, -1.8); wpL.userData.partGroup = 'spoiler'; group.add(wpL);
            const wpR = new THREE.Mesh(wingPillarGeo, carbonMat); wpR.position.set(0.5, 0.8, -1.8); wpR.userData.partGroup = 'spoiler'; group.add(wpR);
            const wingBladeGeo = new THREE.BoxGeometry(2.6, 0.1, 0.8);
            const wing = new THREE.Mesh(wingBladeGeo, carbonMat); wing.position.set(0, 1.1, -1.9); wing.userData.partGroup = 'spoiler'; group.add(wing);
            const exhaustBoxGeo = new THREE.BoxGeometry(0.6, 0.4, 0.1);
            const exhaustBox = new THREE.Mesh(exhaustBoxGeo, carbonMat); exhaustBox.position.set(0, 0.6, -2.25); group.add(exhaustBox);
            const pipeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            [[-0.15, 0.1], [0.15, 0.1], [-0.15, -0.1], [0.15, -0.1]].forEach(off => {
                const pipe = new THREE.Mesh(pipeGeo, exhaustMat); pipe.position.set(off[0], 0.6 + off[1], -2.31); group.add(pipe);
            });
            const tlGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const tlL = new THREE.Mesh(tlGeo, tailLightMat); tlL.position.set(-1.4, 0.7, -1.9); group.add(tlL);
            const tlR = new THREE.Mesh(tlGeo, tailLightMat); tlR.position.set(1.4, 0.7, -1.9); group.add(tlR);
            const hlGeo = new THREE.BoxGeometry(0.6, 0.1, 0.2);
            const hlL = new THREE.Mesh(hlGeo, headLightMat); hlL.position.set(-1.0, 0.5, 2.0); group.add(hlL);
            const hlR = new THREE.Mesh(hlGeo, headLightMat); hlR.position.set(1.0, 0.5, 2.0); group.add(hlR);

            // Wheels
            const wheelGeo = new THREE.BoxGeometry(0.9, 0.8, 0.8);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });

            const flWheel = new THREE.Mesh(wheelGeo, wheelMat); flWheel.position.set(-1.25, 0.4, 1.4); flWheel.userData = { paintable: false }; group.add(flWheel);
            const frWheel = new THREE.Mesh(wheelGeo, wheelMat); frWheel.position.set(1.25, 0.4, 1.4); frWheel.userData = { paintable: false }; group.add(frWheel);
            const rlWheel = new THREE.Mesh(wheelGeo, wheelMat); rlWheel.position.set(-1.35, 0.45, -1.2); rlWheel.userData = { paintable: false }; group.add(rlWheel);
            const rrWheel = new THREE.Mesh(wheelGeo, wheelMat); rrWheel.position.set(1.35, 0.45, -1.2); rrWheel.userData = { paintable: false }; group.add(rrWheel);

            if (addLights) {
                createHeadlights(group, 1.0, 0.5, 2.0, 10.0);
            }
            return group;
        }

        // --- NPC TRAFFIC SYSTEM ---

        function spawnTrafficCar(x, y, z, isPositiveLane) {
            // Random color
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffaa00, 0xaa00aa, 0xffffff, 0x222222];
            const col = colors[Math.floor(Math.random() * colors.length)];

            // Reuse supercar mesh but scaled down slightly
            const mesh = createVehicle({
                type: 'supercar',
                color: col,
                addLights: true,
                scale: 1.6
            });
            mesh.position.set(x, y, z);

            scene.add(mesh);

            trafficVehicles.push({
                mesh: mesh,
                speed: 0.4 + Math.random() * 0.2, // Random speed
                laneDir: isPositiveLane ? 1 : -1, // +1 for positive raw road value, -1 for negative
                velocity: new THREE.Vector3(),
                color: col // Store color for explosion
            });
        }

        function updateTraffic() {
            if (!player) return;
            const pPos = player.position;

            for (let i = trafficVehicles.length - 1; i >= 0; i--) {
                const car = trafficVehicles[i];
                const mesh = car.mesh;

                // 1. Move
                const tangent = getRoadTangent(mesh.position.x, mesh.position.z);

                // If laneDir is -1 (negative raw value side), we inverse the tangent flow
                if (car.laneDir < 0) {
                    tangent.negate();
                }

                car.velocity.copy(tangent).multiplyScalar(car.speed);
                mesh.position.add(car.velocity);

                // 2. Rotate to face velocity
                const angle = Math.atan2(car.velocity.x, car.velocity.z);
                mesh.rotation.y = angle;

                // 3. Keep on ground / simple bounce
                mesh.position.y = PLAYER_BASE_Y + Math.sin(Date.now() * 0.02 + i) * 0.03;

                // 4. Culling (Remove if too far)
                const dx = mesh.position.x - pPos.x;
                const dz = mesh.position.z - pPos.z;
                if (dx * dx + dz * dz > CULL_DIST_SQ * 1.5) { // Slightly larger cull dist to prevent pop-in on edges
                    scene.remove(mesh);
                    trafficVehicles.splice(i, 1);
                }
            }
        }

        function createPlayer() {
            player = new THREE.Group();

            // Find a valid spawn point on the road
            let spawnX = 0, spawnZ = 0;
            // Search nearby for a road
            for (let i = 0; i < 5000; i += 10) {
                if (getRoadValue(i, 0) < 0.1) { spawnX = i; break; }
                if (getRoadValue(-i, 0) < 0.1) { spawnX = -i; break; }
                if (getRoadValue(0, i) < 0.1) { spawnZ = i; break; }
                if (getRoadValue(0, -i) < 0.1) { spawnZ = -i; break; }
            }

            player.position.set(spawnX, PLAYER_BASE_Y, spawnZ);
            initialSpawnX = spawnX;
            initialSpawnZ = spawnZ;
            scene.add(player);
            // Default to hypercar
            loadCarModel('hypercar');
            centerCamera(); // Center camera after spawning
        }

        function loadCarModel(type) {
            if (currentCarMesh) {
                player.remove(currentCarMesh);
                // Dispose logic for car would go here if we were generating new geoms constantly,
                // but we are rebuilding small groups. 
            }
            carType = type;
            currentCarMesh = createVehicle({
                type: type,
                color: vehicleColors[type],
                addLights: true,
                scale: 1.8
            });

            if (type === 'supercar') {
                PLAYER_SPEED = 0.18; MAX_SPEED = 3.8;
            } else if (type === 'hypercar') {
                PLAYER_SPEED = 0.16; MAX_SPEED = 3.5;
            }
            currentCarMesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            player.add(currentCarMesh);
        }

        function toggleCarModel() {
            const newType = (carType === 'supercar') ? 'hypercar' : 'supercar';
            loadCarModel(newType);
            velocity.y = 0.5;
            isAirborne = true;
            updateMiniatureModel();
        }

        function onMouseMoveCam(e) {
            const dx = e.clientX - camLastPos.x;
            const dy = e.clientY - camLastPos.y;
            updateCameraAngle(dx, dy);
            camLastPos = { x: e.clientX, y: e.clientY };
        }

        function onMouseDown(e) {
            // Check miniature hold/click
            if (checkMiniatureClick(e.clientX, e.clientY)) {
                isHolding = true;
                holdTimer = setTimeout(() => {
                    openVehicleModal();
                    isHolding = false; // Consumed
                }, HOLD_DURATION);
                
                // Add one-time mouseup listener
                const onMouseUp = () => {
                    clearTimeout(holdTimer);
                    if (isHolding) {
                        toggleCarModel();
                        isHolding = false;
                    }
                    document.removeEventListener('mouseup', onMouseUp);
                };
                document.addEventListener('mouseup', onMouseUp);
                return;
            }

            if (checkVehicleTap(e.clientX, e.clientY)) {
                handleVehicleTap();
                return;
            }

            if (e.target === timeBtn || e.target === shareBtn) return;
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            if (e.clientX < window.innerWidth / 2) {
            } else {
                isManualCamera = true;
                manualCamTimer = 120;
                camLastPos = { x: e.clientX, y: e.clientY };
                document.addEventListener('mousemove', onMouseMoveCam);
                document.addEventListener('mouseup', () => { document.removeEventListener('mousemove', onMouseMoveCam); });
            }
        }

        function onTouchStart(e) {
            // If share modal is open and the touch is inside the modal content,
            // allow default behavior so clicks/taps work as expected.
            if (shareModal.classList.contains('active')) {
                if (e.target === shareModal) {
                    // Tapping on backdrop closes the modal
                    closeShareModal();
                    return;
                }
                if (e.target.closest && e.target.closest('#share-modal-content')) {
                    return;
                }
            }
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];
                if (checkMiniatureClick(t.clientX, t.clientY)) {
                    isHolding = true;
                    holdTimer = setTimeout(() => {
                        openVehicleModal();
                        isHolding = false;
                    }, HOLD_DURATION);
                    continue;
                }
                if (checkVehicleTap(t.clientX, t.clientY)) {
                    handleVehicleTap();
                    continue;
                }
                if (t.target === timeBtn) {
                    toggleDayNight();
                    continue;
                }
                if (t.target === shareBtn) {
                    openShareModal();
                    continue;
                }
                const dx = t.clientX - zoneCenter.x;
                const dy = t.clientY - zoneCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (moveTouchId === null && dist < joystickRadius * 1.5) {
                    moveTouchId = t.identifier;
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (camTouchId === null) {
                    camTouchId = t.identifier;
                    isManualCamera = true;
                    manualCamTimer = 120;
                    camLastPos = { x: t.clientX, y: t.clientY };
                }
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];
                if (t.identifier === moveTouchId) {
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (t.identifier === camTouchId) {
                    const dx = t.clientX - camLastPos.x;
                    const dy = t.clientY - camLastPos.y;
                    updateCameraAngle(dx, dy);
                    camLastPos = { x: t.clientX, y: t.clientY };
                    isManualCamera = true;
                    manualCamTimer = 120;
                }
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            
            // Check if we are releasing the miniature button
            if (isHolding || holdTimer) {
                clearTimeout(holdTimer);
                if (isHolding) {
                    toggleCarModel();
                    isHolding = false;
                }
                // If we were holding, we don't want to process other touch ends potentially?
                // Actually, we should process others just in case.
            }

            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === moveTouchId) {
                    moveTouchId = null;
                    updateMoveInputFromKeys();
                }
                if (touches[i].identifier === camTouchId) camTouchId = null;
            }
        }

        function updateJoystick(clientX, clientY, center) {
            let dx = clientX - center.x;
            let dy = clientY - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > joystickRadius) {
                const ratio = joystickRadius / distance;
                dx *= ratio;
                dy *= ratio;
            }
            stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            moveInput.x = dx / joystickRadius;
            moveInput.y = dy / joystickRadius;
        }

        function updateCameraAngle(dx, dy) {
            const sensitivity = 0.005;
            cameraAngle -= dx * sensitivity;
            cameraVerticalAngle -= dy * sensitivity;
            cameraVerticalAngle = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraVerticalAngle));
        }

        function centerCamera() {
            if (!player) return;
            cameraAngle = player.rotation.y + Math.PI;
            cameraVerticalAngle = 0.5;
            isManualCamera = false;
            manualCamTimer = 0;
        }

        function updateHeadingIndicator() {
            if (!player) return;
            const carRot = player.rotation.y;
            const camRot = cameraAngle;
            const diff = carRot - camRot;
            const screenX = Math.sin(diff);
            const screenY = -Math.cos(diff);
            const angleRad = Math.atan2(screenX, screenY);
            const angleDeg = angleRad * (180 / Math.PI);
            headingArrow.style.transform = `rotate(${angleDeg}deg)`;
        }

        function shortestAngleDist(a, b) {
            let diff = b - a;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }

        function updatePhysics() {
            if (isGameOver) return;

            if (controlMode === 'pedestrian' && userPedestrian) {
                // Pedestrian Control Logic
                const PED_SPEED = 0.25;
                const turnSpeed = 0.15;

                // Input vector from joystick/keys
                const dx = moveInput.x;
                const dy = moveInput.y; // -1 is up (forward) usually in 2D screen coords, but let's check input logic
                // In updateMoveInputFromKeys: 'w' (up) -> dy = -1. 's' (down) -> dy = 1.
                // In joystick: up -> dy negative.
                
                // Movement relative to camera
                // Camera looks at player.
                // We want "Up" to be "Away from camera".
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                camDir.y = 0;
                camDir.normalize();

                const camRight = new THREE.Vector3();
                camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0));
                
                // dy is negative for UP/Forward input.
                // dx is positive for Right input.
                
                const moveDir = new THREE.Vector3();
                moveDir.addScaledVector(camDir, -dy); // -(-1) = +1 (Forward along camera view)
                moveDir.addScaledVector(camRight, dx);

                if (moveDir.lengthSq() > 0.01) {
                    moveDir.normalize();
                    userPedestrian.position.addScaledVector(moveDir, PED_SPEED);
                    
                    // Only rotate to face movement if not moving backwards relative to camera
                    if (dy <= 0.2) {
                        const targetRot = Math.atan2(moveDir.x, moveDir.z);
                        let rotDiff = shortestAngleDist(userPedestrian.rotation, targetRot);
                        userPedestrian.rotation += rotDiff * turnSpeed;
                    }
                    
                    // Animation: reverse if backing up
                    const animSpeed = dy > 0.2 ? -0.4 : 0.4;
                    userPedestrian.animPhase += animSpeed;
                    const swing = Math.sin(userPedestrian.animPhase) * 0.6;
                    userPedestrian.mesh.userData.limbs.legL.rotation.x = swing;
                    userPedestrian.mesh.userData.limbs.legR.rotation.x = -swing;
                    userPedestrian.mesh.userData.limbs.armL.rotation.x = -swing;
                    userPedestrian.mesh.userData.limbs.armR.rotation.x = swing;
                } else {
                    // Idle pose
                    userPedestrian.mesh.userData.limbs.legL.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.legR.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.armL.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.armR.rotation.x = 0;
                }
                
                userPedestrian.mesh.position.copy(userPedestrian.position);
                userPedestrian.mesh.rotation.y = userPedestrian.rotation;
                
                // Keep player (car) updating slightly for collisions logic if we wanted, 
                // but for now just stop it.
                velocity.set(0, 0, 0); 
                return;
            }

            let appliedFriction = FRICTION;

            if (Math.abs(moveInput.x) > 0.1) {
                // Scaling turn speed with speed for realism (slower turn at high speeds? or low speeds?)
                // Arcade style: constant turn usually feels better, but let's keep it simple.
                const turnFactor = carType === 'hypercar' ? 0.05 : 0.04;
                player.rotation.y -= moveInput.x * turnFactor;
                if (Math.abs(moveInput.x) > 0.85 && Math.random() < 0.25) emitWheelSmoke();
            }
            if (Math.abs(moveInput.y) > 0.1) {
                const throttle = -moveInput.y;
                const rotation = player.rotation.y;

                // Detect Braking: Moving forward but input is backward (or vice versa)
                // We project velocity onto the car's forward vector
                const vx = velocity.x;
                const vz = velocity.z;
                const forwardX = Math.sin(rotation);
                const forwardZ = Math.cos(rotation);
                const dot = vx * forwardX + vz * forwardZ;

                // If moving reasonably fast and input opposes movement
                if ((dot > 0.5 && throttle < -0.1) || (dot < -0.5 && throttle > 0.1)) {
                    appliedFriction = BRAKING_FRICTION;
                    // Add red brake light effect? (Optional visual polish)
                }

                const accelX = Math.sin(rotation) * throttle * PLAYER_SPEED;
                const accelZ = Math.cos(rotation) * throttle * PLAYER_SPEED;
                velocity.x += accelX;
                velocity.z += accelZ;
            }

            velocity.x *= appliedFriction;
            velocity.z *= appliedFriction;
            velocity.y -= GRAVITY;

            const hSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
            if (hSpeed > MAX_SPEED) {
                const ratio = MAX_SPEED / hSpeed;
                velocity.x *= ratio;
                velocity.z *= ratio;
            }
            player.position.add(velocity);

            if (player.position.y < PLAYER_BASE_Y) {
                player.position.y = PLAYER_BASE_Y;
                velocity.y = 0;
                isAirborne = false;
            } else {
                isAirborne = true;
            }

            const pRadiusSq = 4.0;

            // --- Building Collisions ---
            for (const chunk of activeChunks.values()) {
                if (!chunk.obstacles) continue;
                for (let i = 0; i < chunk.obstacles.length; i++) {
                    const obs = chunk.obstacles[i];
                    const dx = player.position.x - obs.x;
                    const dz = player.position.z - obs.z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < obs.radiusSq + pRadiusSq && player.position.y < obs.height) {
                        explode(player.position, 0xff4400);
                        explode(player.position, 0xffee00);
                        triggerGameOver();
                        return;
                    }
                }
            }

            // --- Traffic Collisions ---
            const trafficCollisionDistSq = 12.0; // Approx 3.5^2
            for (let i = 0; i < trafficVehicles.length; i++) {
                const npc = trafficVehicles[i];
                const dx = player.position.x - npc.mesh.position.x;
                const dz = player.position.z - npc.mesh.position.z;
                const distSq = dx * dx + dz * dz;

                if (distSq < trafficCollisionDistSq) {
                    explode(player.position, 0xff4400);
                    explode(npc.mesh.position, npc.color); // Use NPC color
                    npc.mesh.visible = false;
                    triggerGameOver();
                    return;
                }
            }
        }

        function triggerGameOver() {
            isGameOver = true;
            player.visible = false;
            velocity.set(0, 0, 0);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }

            // Show Game Over Modal
            const modal = document.getElementById('game-over-modal');
            const scoreText = document.getElementById('go-top-score');
            if (modal && scoreText) {
                scoreText.innerText = "Top Score: " + highScore;
                modal.classList.add('active');
            }

            // Hide instructions temporarily if needed
            const instr = document.querySelector('.instructions');
            if (instr) instr.style.opacity = 0;

            setTimeout(() => resetGame(), 2000);
        }

        function resetGame() {
            isGameOver = false;
            player.visible = true;
            player.position.set(initialSpawnX, PLAYER_BASE_Y, initialSpawnZ);
            player.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0);
            moveInput = { x: 0, y: 0 };
            score = 0;
            scoreElement.innerText = "Score: 0";
            centerCamera();

            // Hide Game Over Modal
            const modal = document.getElementById('game-over-modal');
            if (modal) modal.classList.remove('active');

            // Clear traffic
            trafficVehicles.forEach(c => scene.remove(c.mesh));
            trafficVehicles.length = 0;

            const instr = document.querySelector('.instructions');
            if (instr) {
                // Restore instructions
                instr.innerHTML = isNightMode ? "Night Run<br>Left Stick: Drive" : "Day Run<br>Left Stick: Drive";
                instr.style.opacity = 1;
                instr.style.animation = 'none';
                instr.offsetHeight; // Trigger reflow
                instr.style.animation = 'fadeOut 5s forwards';
                instr.style.animationDelay = '2s';
            }
        }

        function updatePedestrians() {
            if (isGameOver) return;
            const time = Date.now() * 0.005;
            const playerPos = player.position;
            const SPAWN_RANGE = 250;
            activeObstacles.length = 0;

            // Reusable loop vars to reduce GC
            let ped, dx, dz, distSq, phase, swing;

            for (let i = 0; i < allPedestrians.length; i++) {
                ped = allPedestrians[i];
                if (!ped.isStationary) {
                    ped.position.add(ped.velocity);
                }

                // Wrap around logic
                if (ped.position.x > playerPos.x + SPAWN_RANGE) ped.position.x -= SPAWN_RANGE * 2;
                if (ped.position.x < playerPos.x - SPAWN_RANGE) ped.position.x += SPAWN_RANGE * 2;
                if (ped.position.z > playerPos.z + SPAWN_RANGE) ped.position.z -= SPAWN_RANGE * 2;
                if (ped.position.z < playerPos.z - SPAWN_RANGE) ped.position.z += SPAWN_RANGE * 2;

                dx = ped.position.x - playerPos.x;
                dz = ped.position.z - playerPos.z;
                distSq = dx * dx + dz * dz;

                if (distSq < CULL_DIST_SQ) {
                    if (!ped.mesh) {
                        ped.mesh = buildPedestrianMesh(ped);
                        ped.mesh.rotation.y = ped.rotation;
                    }
                    if (!ped.isActive) {
                        scene.add(ped.mesh);
                        ped.isActive = true;
                    }
                    ped.mesh.position.copy(ped.position);
                    ped.mesh.rotation.y = ped.rotation;

                    // Simple animation
                    if (!ped.isStationary) {
                        phase = time + ped.animPhase;
                        swing = Math.sin(phase) * 0.6;
                        ped.mesh.userData.limbs.legL.rotation.x = swing;
                        ped.mesh.userData.limbs.legR.rotation.x = -swing;
                        ped.mesh.userData.limbs.armL.rotation.x = -swing;
                        ped.mesh.userData.limbs.armR.rotation.x = swing;
                    } else {
                        ped.mesh.userData.limbs.legL.rotation.x = 0;
                        ped.mesh.userData.limbs.legR.rotation.x = 0;
                        ped.mesh.userData.limbs.armL.rotation.x = 0;
                        ped.mesh.userData.limbs.armR.rotation.x = 0;
                    }

                    activeObstacles.push(ped);
                } else {
                    if (ped.isActive) {
                        scene.remove(ped.mesh);
                        ped.isActive = false;
                    }
                }
            }
        }

        function checkCollisions() {
            if (isGameOver) return;
            const collisionThresholdSq = 16.0;
            for (let i = activeObstacles.length - 1; i >= 0; i--) {
                const pedData = activeObstacles[i];
                const dx = player.position.x - pedData.position.x;
                const dz = player.position.z - pedData.position.z;
                const distSq = dx * dx + dz * dz;
                if (distSq < collisionThresholdSq) {
                    explode(pedData.position);
                    pedData.position.x = player.position.x + (Math.random() - 0.5) * 300;
                    pedData.position.z = player.position.z + (Math.random() - 0.5) * 300;
                    if (pedData.isActive) {
                        scene.remove(pedData.mesh);
                        pedData.isActive = false;
                    }
                    score++;
                    scoreElement.innerText = "Score: " + score;
                }
            }
        }

        function emitWheelSmoke() {
            if (!player) return;
            let wheelOffsets = [];
            if (carType === 'supercar') {
                wheelOffsets = [{ x: -1.2, z: 1.6 }, { x: 1.2, z: 1.6 }, { x: -1.25, z: -1.4 }, { x: 1.25, z: -1.4 }];
            } else {
                wheelOffsets = [{ x: -1.32, z: 1.4 }, { x: 1.32, z: 1.4 }, { x: -1.38, z: -1.2 }, { x: 1.38, z: -1.2 }];
            }
            const carRot = player.rotation.y;
            const cos = Math.cos(carRot);
            const sin = Math.sin(carRot);
            wheelOffsets.forEach(offset => {
                const rx = offset.x * cos + offset.z * sin;
                const rz = -offset.x * sin + offset.z * cos;
                const pos = new THREE.Vector3(player.position.x + rx, player.position.y + 0.2, player.position.z + rz);
                spawnSmokeParticle(pos); // Reduced to 1 particle per wheel for speed
            });
        }

        function spawnSmokeParticle(pos) {
            const size = Math.random() * 0.4 + 0.2;
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.4 });
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            p.position.x += (Math.random() - 0.5) * 0.5;
            p.position.z += (Math.random() - 0.5) * 0.5;
            p.userData = {
                type: 'smoke', life: 1.0,
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.05, 0.05 + Math.random() * 0.05, (Math.random() - 0.5) * 0.05)
            };
            scene.add(p);
            particles.push(p);
        }

        function explode(pos, color = 0xFF0000) {
            const pGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const pMat = new THREE.MeshBasicMaterial({ color: color });
            for (let k = 0; k < 5; k++) { // Reduced particle count
                const p = new THREE.Mesh(pGeo, pMat);
                p.position.copy(pos);
                p.position.y += 1.5;
                p.userData = {
                    type: 'debris', life: 1.0,
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 1.0, Math.random() * 1.0 + 0.2, (Math.random() - 0.5) * 1.0)
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function createSnow() {
            const positions = [];
            const velocities = [];
            
            // Spawn locally around (0,0,0)
            for (let i = 0; i < snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * snowRange,
                    Math.random() * 60 - 20, // Height variation
                    (Math.random() - 0.5) * snowRange
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.15, // x drift
                    -Math.random() * 0.3 - 0.1, // y fall speed (slightly faster)
                    (Math.random() - 0.5) * 0.15  // z drift
                );
            }

            snowGeo = new THREE.BufferGeometry();
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            snowGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.4, // Slightly larger
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);
            
            if (player) {
                snowSystem.position.copy(player.position);
                lastSnowPlayerPos.copy(player.position);
            }
        }

        function updateSnow() {
            if (!player || !snowSystem) return;

            // Calculate player movement delta
            const deltaX = player.position.x - lastSnowPlayerPos.x;
            const deltaY = player.position.y - lastSnowPlayerPos.y;
            const deltaZ = player.position.z - lastSnowPlayerPos.z;

            // Update system position to match player (Keep box centered)
            snowSystem.position.copy(player.position);
            lastSnowPlayerPos.copy(player.position);

            const positions = snowGeo.attributes.position.array;
            const velocities = snowGeo.attributes.velocity.array;
            const halfRange = snowRange / 2;

            for (let i = 0; i < snowCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Apply Velocity (Falling)
                positions[ix] += velocities[ix];
                positions[iy] += velocities[iy];
                positions[iz] += velocities[iz];

                // 2. Shift particles opposite to player movement
                // This keeps them "stationary" in world space as the system moves
                positions[ix] -= deltaX;
                positions[iy] -= deltaY;
                positions[iz] -= deltaZ;

                // 3. Wrap around within the local box
                if (positions[ix] > halfRange) positions[ix] -= snowRange;
                if (positions[ix] < -halfRange) positions[ix] += snowRange;

                if (positions[iz] > halfRange) positions[iz] -= snowRange;
                if (positions[iz] < -halfRange) positions[iz] += snowRange;

                if (positions[iy] < -20) positions[iy] += 80; // Wrap height (local)
                if (positions[iy] > 60) positions[iy] -= 80;
            }
            
            snowGeo.attributes.position.needsUpdate = true;
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'smoke') {
                    p.rotation.x += 0.05; p.rotation.y += 0.05; p.scale.addScalar(0.04); p.userData.life -= 0.025;
                    if (p.material.opacity > 0) p.material.opacity = p.userData.life * 0.4;
                } else {
                    p.userData.velocity.y -= 0.03; p.rotation.x += 0.1; p.rotation.y += 0.1;
                    if (p.position.y < 0) { p.userData.velocity.y *= -0.5; p.position.y = 0; }
                    p.userData.life -= 0.05; p.scale.setScalar(p.userData.life);
                }
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    if (p.material) p.material.dispose();
                    if (p.geometry) p.geometry.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        function updateCamera() {
            let targetObj = player;
            if (controlMode === 'pedestrian' && userPedestrian) {
                targetObj = userPedestrian; // Use object with .position and .rotation (if we want camera to rotate with ped)
                // Pedestrian rotation might jitter, maybe keep camera angle independent or smooth follow?
            }

            if (isManualCamera) {
                manualCamTimer--;
                if (manualCamTimer <= 0) isManualCamera = false;
            } else {
                if (controlMode === 'vehicle' && velocity.length() > 0.1) {
                    const targetAngle = player.rotation.y + Math.PI;
                    const dist = shortestAngleDist(cameraAngle, targetAngle);
                    cameraAngle += dist * 0.05;
                    const targetPitch = 0.5;
                    cameraVerticalAngle += (targetPitch - cameraVerticalAngle) * 0.02;
                } else if (controlMode === 'pedestrian' && userPedestrian) {
                    // Only auto-align if NOT moving backwards
                    if (moveInput.y <= 0.2) {
                        const targetAngle = userPedestrian.rotation + Math.PI;
                        const dist = shortestAngleDist(cameraAngle, targetAngle);
                        cameraAngle += dist * 0.1; // Slightly faster follow for pedestrian
                    }
                    const targetPitch = 0.4; // Lower pitch for pedestrian
                    cameraVerticalAngle += (targetPitch - cameraVerticalAngle) * 0.02;
                }
            }
            const hDist = CAMERA_DIST * Math.cos(cameraVerticalAngle);
            const vDist = CAMERA_DIST * Math.sin(cameraVerticalAngle);
            const offsetX = hDist * Math.sin(cameraAngle);
            const offsetZ = hDist * Math.cos(cameraAngle);
            const targetPos = new THREE.Vector3(
                targetObj.position.x + offsetX,
                targetObj.position.y + vDist,
                targetObj.position.z + offsetZ
            );
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(targetObj.position);
        }

        function updateMinimap() {
            if (!player) return;
            // Throttle minimap updates: only update every 10th frame
            if (globalFrame % 4 !== 0) return;

            const w = minimapCanvas.width;
            const h = minimapCanvas.height;
            minimapCtx.clearRect(0, 0, w, h);

            minimapCtx.fillStyle = isNightMode ? 'rgba(10, 20, 30, 0.9)' : 'rgba(68, 119, 68, 0.8)';
            minimapCtx.fillRect(0, 0, w, h);

            minimapCtx.save();
            minimapCtx.translate(w / 2, h / 2);
            minimapCtx.rotate(player.rotation.y + Math.PI);
            minimapCtx.scale(0.8, 0.8); // Zoom out slightly
            minimapCtx.translate(-player.position.x, -player.position.z);

            minimapCtx.fillStyle = isNightMode ? '#333' : '#222';
            for (const chunk of activeChunks.values()) {
                if (chunk.roads) {
                    for (const road of chunk.roads) {
                        minimapCtx.fillRect(road.x - ROAD_TILE_SIZE / 2, road.z - ROAD_TILE_SIZE / 2, ROAD_TILE_SIZE + 1, ROAD_TILE_SIZE + 1);
                    }
                }
            }

            minimapCtx.fillStyle = isNightMode ? '#445566' : '#87CEEB';
            for (const chunk of activeChunks.values()) {
                if (chunk.obstacles) {
                    for (const obs of chunk.obstacles) {
                        if (obs.isBuilding) {
                            minimapCtx.fillRect(obs.x - obs.width / 2, obs.z - obs.depth / 2, obs.width, obs.depth);
                        }
                    }
                }
            }

            // Draw Traffic on minimap
            minimapCtx.fillStyle = '#ffcc00';
            trafficVehicles.forEach(c => {
                const cx = c.mesh.position.x;
                const cz = c.mesh.position.z;
                // Only draw if within reasonable minimap range
                if (Math.abs(cx - player.position.x) < 150 && Math.abs(cz - player.position.z) < 150) {
                    minimapCtx.fillRect(cx - 2, cz - 2, 4, 4);
                }
            });

            minimapCtx.restore();

            // Draw arrow
            minimapCtx.save();
            minimapCtx.translate(w / 2, h / 2);
            minimapCtx.fillStyle = '#ff3366';
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, -10);
            minimapCtx.lineTo(8, 10);
            minimapCtx.lineTo(0, 6);
            minimapCtx.lineTo(-8, 10);
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.stroke();
            minimapCtx.restore();
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsElement.innerText = "FPS: " + frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateFPS();
            globalFrame++;

            if (player && !vehicleModalOpen) {
                updatePhysics();
                updateChunks();
                updatePedestrians();
                checkCollisions();
                updateParticles();
                updateSnow();
                updateCamera();
                updateHeadingIndicator();
                updateMinimap();
                updateTraffic(); // NPC update
                if (sunLight) {
                    sunLight.position.set(player.position.x + 50, 100, player.position.z + 50);
                    sunLight.target.position.copy(player.position);
                    sunLight.target.updateMatrixWorld();
                }
                if (!isAirborne) {
                    const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                    if (speed > 0.01) {
                        const bounceFreq = carType === 'hypercar' ? 0.03 : 0.015;
                        const bounceAmp = carType === 'hypercar' ? 0.02 : 0.05;
                        player.position.y = PLAYER_BASE_Y + Math.sin(Date.now() * bounceFreq) * bounceAmp;
                    }
                }
            }
            renderer.clear();
            renderer.render(scene, camera);
            if (miniatureGroup) miniatureGroup.rotation.y += 0.02;
            renderer.clearDepth();
            renderer.render(uiScene, uiCamera);

            if (vehicleModalOpen) {
                // if (modalCarGroup) modalCarGroup.rotation.y += 0.01; // Removed automatic rotation
                // Render modal scene on top (using separate renderer)
                modalRenderer.render(modalScene, modalCamera);
            }
        }

        function updateMoveInputFromKeys() {
            let dx = 0;
            let dy = 0;
            if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= 1;
            if (keysPressed['s'] || keysPressed['ArrowDown']) dy += 1;
            if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= 1;
            if (keysPressed['d'] || keysPressed['ArrowRight']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                // Normalize for consistent speed diagonally
                const len = Math.sqrt(dx*dx + dy*dy);
                dx /= len;
                dy /= len;
            }

            moveInput.x = dx;
            moveInput.y = dy;

            // Visual feedback on joystick
            const joyX = dx * joystickRadius;
            const joyY = dy * joystickRadius;
            if (stickKnob) stickKnob.style.transform = `translate(calc(-50% + ${joyX}px), calc(-50% + ${joyY}px))`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            uiCamera.aspect = window.innerWidth / window.innerHeight;
            uiCamera.updateProjectionMatrix();
            updateMiniaturePosition();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (vehicleModalOpen && modalRenderer) {
                const width = vehicleModal.clientWidth;
                const height = vehicleModal.clientHeight;
                modalRenderer.setSize(width, height, false);
                modalCamera.aspect = width / height;
                modalCamera.updateProjectionMatrix();
            }
        }
    </script>
    <script>
        // Load the SDK asynchronously
        (function (d, s, id) {
        var js,
        sjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s);
        js.id = id;
        js.src = 'https://sdk.snapkit.com/js/v1/create.js';
        sjs.parentNode.insertBefore(js, sjs);
        
        // Add touch event handling for mobile after SDK loads
        js.onload = function() {
            setTimeout(function() {
                const snapButton = document.querySelector('.snapchat-creative-kit-share');
                if (snapButton) {
                    // Enable touch events for mobile
                    snapButton.style.touchAction = 'auto';
                    snapButton.style.webkitTouchCallout = 'default';
                    
                    // Add explicit touch handler that delegates to click
                    snapButton.addEventListener('touchstart', function(e) {
                        e.stopPropagation();
                    }, { passive: true });
                    
                    snapButton.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        // Find and trigger the actual SDK button inside
                        const sdkButton = snapButton.querySelector('button, a, [role="button"]');
                        if (sdkButton) {
                            sdkButton.click();
                        } else {
                            snapButton.click();
                        }
                    }, { passive: false });
                }
            }, 500); // Wait for SDK to inject the button
        };
        })(document, 'script', 'snapkit-creative-kit-sdk');
    </script>
</body>

</html>
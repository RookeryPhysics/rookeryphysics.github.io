<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta property="og:site_name" content="Roadst3r" />
    <meta property="og:title" content="Play Roadst3r" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://rookeryphysics.github.io/drive" />
    <meta property="og:description"
        content="Voxel driving game. Drift through a city and try to beat your top score." />
    <meta property="og:image" content="https://rookeryphysics.github.io/drive/img.jpg" />
    <meta property="og:image:secure_url" content="https://rookeryphysics.github.io/drive/img.jpg" />
    <!-- Optional width/height; adjust if img.jpg differs -->
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <link rel="canonical" href="https://rookeryphysics.github.io/drive" />
    <title>Roadst3r</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            font-size: 14px;
            pointer-events: none;
            backdrop-filter: blur(4px);
            animation: fadeOut 5s forwards;
            animation-delay: 5s;
            width: 80%;
            max-width: 400px;
            z-index: 15;
        }

        /* --- Game Over Modal --- */
        #game-over-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 40px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            color: white;
            z-index: 200;
            display: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            min-width: 200px;
            pointer-events: none;
        }

        #game-over-modal h2 {
            margin: 0 0 10px 0;
            color: #ff3366;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #game-over-modal p {
            margin: 0;
            font-size: 20px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #game-over-modal.active {
            display: block;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* --- Controls Layout --- */

        #movement-zone {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 180px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #stick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #heading-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: center center;
            z-index: 10;
        }

        #heading-arrow::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 14px;
            background-color: #ff3366;
            left: -3px;
            bottom: 2px;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #heading-arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 16px solid #ff3366;
            left: -10px;
            bottom: 14px;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.3));
        }






        /* --- Settings Button --- */
        #settings-btn {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.3s ease;
        }

        #settings-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Settings Modal --- */
        #settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }

        #settings-modal.active {
            display: flex;
        }

        #settings-modal-content {
            background: rgba(20, 20, 30, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            max-width: 400px;
            width: 80%;
            position: relative;
            color: white;
            text-align: center;
        }

        #settings-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #settings-modal-close:hover {
            color: #ff3366;
        }

        /* --- Day/Night Toggle Button --- */
        #time-btn {
            position: relative;
            margin: 20px auto;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            transition: transform 0.2s, background 0.2s;
        }

        #time-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #time-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Share Button --- */
        #share-btn {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #share-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Share Modal --- */
        #share-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        #share-modal.active {
            display: flex;
        }

        #share-modal-content {
            background: rgba(20, 20, 30, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            max-width: 400px;
            width: 80%;
            max-height: 80%;
            /* Increased height */
            overflow-y: auto;
            /* Added scroll for content overflow */
            position: relative;
        }

        /* Allow normal interactions inside modal on mobile */
        #share-modal,
        #share-modal * {
            touch-action: auto;
        }

        /* Re-enable text selection for the share link input */
        #share-link {
            user-select: text;
            -webkit-user-select: text;
        }

        #share-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #share-modal-close:hover {
            color: #ff3366;
        }

        /* --- Vehicle Modal --- */
        #vehicle-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70vw;
            /* Reduced from 90vw */
            max-width: 350px;
            /* Reduced from 500px */
            height: 60vh;
            /* Reduced from 80vh */
            max-height: 350px;
            /* Reduced from 500px */
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }

        #vehicle-modal.active {
            display: flex;
            opacity: 1;
        }

        #vehicle-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            z-index: 101;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #modal-canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 50;
        }

        #color-palette {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 102;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
            width: 80%;
            max-width: 250px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-swatch:hover,
        .color-swatch.selected {
            transform: scale(1.2);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #vehicle-info {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        #vehicle-name {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #vehicle-stats {
            font-size: 16px;
            opacity: 0.8;
        }

        /* --- Pedestrian Modal --- */
        #pedestrian-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            max-width: 400px;
            height: 70vh;
            max-height: 500px;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }

        #pedestrian-modal.active {
            display: flex;
            opacity: 1;
        }

        /* Re-enable text selection and touch interactions for the username input */
        #player-username {
            user-select: text;
            -webkit-user-select: text;
            touch-action: auto;
        }

        #pedestrian-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            z-index: 101;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #ped-modal-canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 50;
        }

        #ped-color-palette {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 102;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
            width: 80%;
            max-width: 250px;
        }

        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffcc00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
        }

        #fps-counter {
            position: absolute;
            top: 20px;
            left: 120px;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            /* Made slightly smaller */
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.3s ease;
            display: none;
        }

        #collapse-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.3s ease;
        }

        #collapse-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* HUD Hidden State */
        body.hud-hidden #fps-counter,
        body.hud-hidden #score-board,

        body.hud-hidden #settings-btn,
        body.hud-hidden #share-btn,

        body.hud-hidden .instructions {
            opacity: 0;
            pointer-events: none;
        }

        #res-control {
            position: relative;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 80%;
            pointer-events: auto;
        }

        #res-label {
            color: white;
            font-size: 10px;
            margin-bottom: 2px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 0 1px 2px black;
        }

        #res-slider {
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
        }

        .modal-reset-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 101;
            backdrop-filter: blur(4px);
            transition: background 0.2s, transform 0.1s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-reset-btn:active {
            transform: scale(0.95);
        }

        #score-board,

        #share-btn,
        .instructions {
            transition: opacity 0.3s ease;
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MCV5P2FEE7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-MCV5P2FEE7');
    </script>
</head>

<body>

    <div id="ui-layer">
        <div id="collapse-btn">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path
                    d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24">
                </path>
                <line x1="1" y1="1" x2="23" y2="23"></line>
            </svg>
        </div>
        <div id="settings-btn">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path
                    d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z">
                </path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        </div>
        <div id="fps-counter">FPS: 60</div>
        <div id="score-board">Score: 0</div>


        <div id="share-btn">
            <img src="snap.png" alt="Snapchat Logo" width="54" height="54">
        </div>

        <div id="movement-zone">
            <div id="stick-knob">
                <div id="heading-arrow"></div>
            </div>
        </div>

    </div>

    <div id="share-modal">
        <div id="share-modal-content">
            <button id="share-modal-close">Ã—</button>
            <h2 id="share-modal-title"
                style="margin:5px 0 10px; font-size:20px; color:#ffffff; text-align:center; font-weight:600; letter-spacing:0.5px;">
                Share the game!</h2>
            <img src="qr.png" alt="QR Code"
                style="display:block; margin: 15px auto 25px; max-width: 150px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">
            <div id="share-controls" style="display:flex; gap:10px; align-items:center; margin-top:25px;">
                <input id="share-link" type="text" value="https://rookeryphysics.github.io/drive" readonly
                    style="flex:1; padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.3); background:rgba(255,255,255,0.08); color:#ffffff; font-size:14px;">
                <button id="copy-link-btn"
                    style="padding:10px 14px; border-radius:8px; border:1px solid rgba(255,255,255,0.3); background:rgba(0,0,0,0.4); color:#ffffff; cursor:pointer;">Copy</button>
            </div>
            <div class="share-separator"
                style="margin-top:24px; text-align:center; font-weight:600; color:#ffffff; font-size:12px; opacity:0.85; letter-spacing:2px;">
                OR</div>
            <div class="snapchat-creative-kit-share" data-size="large" data-theme="dark"
                data-share-url="https://rookeryphysics.github.io/drive" data-share-text="Come drive this voxel racer!"
                style="display:flex; justify-content:center; align-items:center; margin:24px auto 0;"></div>
        </div>
    </div>

    <div id="vehicle-modal">
        <button id="vehicle-modal-close">Ã—</button>
        <button id="vehicle-reset-btn" class="modal-reset-btn">Reset</button>
        <canvas id="modal-canvas"></canvas>
        <div id="color-palette"></div>
    </div>

    <div id="pedestrian-modal">
        <button id="pedestrian-modal-close">Ã—</button>
        <input type="text" id="player-username" placeholder="Username" maxlength="12" style="
            position: absolute; 
            top: 10px; 
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 105; 
            background: rgba(0,0,0,0.5); 
            color: white; 
            border: 1px solid rgba(255,255,255,0.5); 
            border-radius: 5px; 
            padding: 8px; 
            text-align: center; 
            font-family: inherit;
            font-size: 16px;
            width: 150px;
        ">
        <button id="pedestrian-reset-btn" class="modal-reset-btn" style="top: 60px;">Reset</button>
        <canvas id="ped-modal-canvas"></canvas>
        <div id="ped-color-palette"></div>
    </div>

    <div id="settings-modal">
        <div id="settings-modal-content">
            <button id="settings-modal-close">Ã—</button>
            <h2>Settings</h2>
            <div id="time-btn">ðŸŒ™</div>
            <div id="miniature-row" style="display:flex; justify-content:center; gap:20px; margin: 10px auto;">
                <div id="miniature-container-supercar"
                    style="width: 120px; height: 120px; position: relative; cursor: pointer; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; background: rgba(255,255,255,0.05);">
                    <canvas id="settings-miniature-canvas-supercar"
                        style="width: 100%; height: 100%; display: block; border-radius: 50%;"></canvas>
                </div>
                <div id="miniature-container-hypercar"
                    style="width: 120px; height: 120px; position: relative; cursor: pointer; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; background: rgba(255,255,255,0.05);">
                    <canvas id="settings-miniature-canvas-hypercar"
                        style="width: 100%; height: 100%; display: block; border-radius: 50%;"></canvas>
                </div>
            </div>
            <button id="settings-pimp-btn" style="
                display: block;
                width: 100%;
                box-sizing: border-box;
                margin-top: 15px;
                margin-bottom: 10px;
                padding: 10px 20px;
                font-size: 16px;
                color: #fff;
                background: #444;
                border: 2px solid #666;
                border-radius: 8px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Modify Vehicle</button>
            <button id="settings-pimp-ped-btn" style="
                display: block;
                width: 100%;
                box-sizing: border-box;
                margin-top: 5px;
                margin-bottom: 15px;
                padding: 10px 20px;
                font-size: 16px;
                color: #fff;
                background: #444;
                border: 2px solid #666;
                border-radius: 8px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Modify Player</button>
            <button id="settings-join-server-btn" style="
                display: block;
                width: 100%;
                box-sizing: border-box;
                margin-top: 5px;
                margin-bottom: 15px;
                padding: 10px 20px;
                font-size: 16px;
                color: #fff;
                background: #444;
                border: 2px solid #666;
                border-radius: 8px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Join Server</button>
            <div id="res-control">
                <span id="res-label">RESOLUTION</span>
                <input type="range" id="res-slider" min="0.1" max="1.5" step="0.05" value="1.5">
                <button id="toggle-fps-btn" style="
                    margin-top: 15px;
                    padding: 8px 12px;
                    font-size: 11px;
                    font-weight: bold;
                    color: #fff;
                    background: rgba(255,255,255,0.1);
                    border: 1px solid rgba(255,255,255,0.3);
                    border-radius: 6px;
                    cursor: pointer;
                    text-transform: uppercase;
                    width: 100%;
                    transition: background 0.2s;
                ">Show FPS</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal">
        <div id="game-over-content">
            <h2>GAME OVER</h2>
            <p id="go-top-score">Top Score: 0</p>
        </div>
    </div>

    <div id="game-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        // --- Variables ---
        let scene, camera, renderer;
        let settingsMiniatureSceneSuper, settingsMiniatureCameraSuper, settingsMiniatureRendererSuper;
        let settingsMiniatureSceneHyper, settingsMiniatureCameraHyper, settingsMiniatureRendererHyper;
        let miniatureGroupSuper, miniatureGroupHyper;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Multiplayer
        let socket;
        let otherPlayers = {};

        // Modal Variables
        let vehicleModalOpen = false;
        let modalScene, modalCamera, modalRenderer;
        let modalCarGroup;
        let holdTimer = null;
        let isHolding = false;
        const HOLD_DURATION = 600; // ms
        const vehicleModal = document.getElementById('vehicle-modal');
        const vehicleModalClose = document.getElementById('vehicle-modal-close');

        let pedestrianModalOpen = false;
        let pedModalScene, pedModalCamera, pedModalRenderer;
        let pedModalPedGroup;
        let tempPedColors = null;
        const pedestrianModal = document.getElementById('pedestrian-modal');
        const pedestrianModalClose = document.getElementById('pedestrian-modal-close');

        // Modal Car Dragging
        let isDraggingModalCar = false;
        let lastDragX = 0;
        // Paint Logic
        let selectedColor = 0xff0000; // Default red
        // Persistent Colors Initialization
        const savedVehicleColors = localStorage.getItem('vehicleColors');
        const vehicleColors = savedVehicleColors ? JSON.parse(savedVehicleColors) : {
            supercar: { body: 0xffffff, spoiler: 0x000000 },
            hypercar: { body: 0xFFD700, spoiler: 0x111111 }
        };

        const savedPedColors = localStorage.getItem('pedestrianColors');
        const defaultPedestrianColors = savedPedColors ? JSON.parse(savedPedColors) : {
            shirt: 0x111111, pants: 0x111111, skin: 0xffccaa, robe: 0x000000, hat: 0x555555
        };
        const paintColors = [
            0xFF0000, 0xFF7F00, 0xFFFF00, 0x7FFF00, 0x00FF00, 0x00FF7F,
            0x00FFFF, 0x007FFF, 0x0000FF, 0x7F00FF, 0xFF00FF, 0xFF007F,
            0xFFFFFF, 0xCCCCCC, 0x888888, 0x444444, 0x000000, 0xFF1493,
            0x00008B, 0x5F9EA0, 0x4682B4, 0x20B2AA, 0x008080, 0x008B8B
        ];
        const clothingColors = [
            0xFFFFFF, 0xDDDDDD, 0xAAAAAA, 0x777777, 0x333333, 0x111111,
            0x2C3E50, 0x4A6A8A, 0x5D6D7E, 0x2E4053, 0x1E272E, 0x556B2F,
            0x224422, 0x8A9A5B, 0x663333, 0x800020, 0x704214, 0xD2B48C,
            0x9E5B6D, 0x7E5E60, 0x4B3832, 0x3C2F2F, 0x004040, 0x483D8B
        ];
        let paintRaycaster = new THREE.Raycaster();
        let modalMouse = new THREE.Vector2();
        let isPaintClick = false;

        let player;
        let initialSpawnX = 0;
        let initialSpawnZ = 0;
        let carType = 'hypercar';
        let currentCarMesh = null;
        let ambientLight, sunLight;

        let isNightMode = false;

        let controlMode = 'vehicle'; // 'vehicle' or 'pedestrian'
        let userPedestrian = null;

        // ... (skipping lines to match context if needed, but I can just replace the block down to initVehicleModal if I'm careful, or just separate calls)
        // Actually, I will do separate replacements to be safe.


        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        const scoreElement = document.getElementById('score-board');
        const fpsElement = document.getElementById('fps-counter');

        const allPedestrians = [];
        const activeObstacles = [];
        const particles = [];
        const floatingTexts = [];
        const particlePool = []; // Object Pool for particles
        const pedestrianPool = []; // Object Pool for pedestrians
        const trafficPool = []; // Object Pool for traffic cars
        const trafficVehicles = []; // Active Traffic NPCs

        // Reusable Geometries for Particles
        const debrisGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const smokeBaseGeometry = new THREE.BoxGeometry(1, 1, 1);
        const debrisMaterialCache = new Map(); // Cache materials for debris

        // Mobile Detection for Performance Optimization
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

        // Frame skip settings for mobile optimization
        const PEDESTRIAN_UPDATE_INTERVAL = 1;
        const TRAFFIC_UPDATE_INTERVAL = 1;
        const COLLISION_CHECK_INTERVAL = 1;
        const PARTICLE_UPDATE_INTERVAL = 1;

        // Snow System
        let snowSystem, snowGeo;
        const snowCount = 500; // Unified for mobile and desktop
        const snowRange = 320;

        // Cache materials to reduce draw calls
        const materialCache = new Map();
        const buildingMaterialCache = new Map();

        // Pre-computed Textures
        let dayGroundTexture, nightGroundTexture;
        let lightSpotTexture;

        let lastChunkUpdatePos = new THREE.Vector3(99999, 99999, 99999);
        let lastLightUpdatePos = new THREE.Vector3(99999, 99999, 99999); // Init for light throttling

        const pedGeometries = {};
        const buildingGeometries = {};
        let groundGeometry, groundMaterial;
        let roadTileGeometry, roadMaterial;
        let lineTileGeometry, lineMaterial;
        let grassGeometry, grassMaterial;
        let poleGeometry, poleMaterial, lightBulbGeometry, lightBulbMaterial, poleBaseGeometry;

        let lightSpotGeometry, lightSpotMaterial;

        // Voxel Score Resources
        const voxelScoreGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const voxelScoreMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        const CULL_DIST = 220;
        const CULL_DIST_SQ = CULL_DIST * CULL_DIST;
        const CHUNK_SIZE = 200;
        const CHUNK_RENDER_DIST = 1;
        const activeChunks = new Map();
        const ROAD_TILE_SIZE = 10;
        const ROAD_WIDTH_THRESHOLD = 0.25;

        // Physics
        let ACCELERATION = 0.15;
        const FRICTION = 0.97;
        const BRAKING_FRICTION = 0.90;
        let MAX_SPEED = 2.0;
        const PLAYER_BASE_Y = 0.05;
        const GRAVITY = 0.02;
        let isGameOver = false;
        let isAirborne = false;

        // Movement
        const velocity = new THREE.Vector3();
        let moveInput = { x: 0, y: 0 };
        const keysPressed = {};

        // Camera
        let cameraAngle = 0;
        let cameraVerticalAngle = 0.5;
        const CAMERA_DIST = 25;
        let isManualCamera = false;
        let manualCamTimer = 0;

        // Input
        let moveTouchId = null;
        let camTouchId = null;
        let camLastPos = { x: 0, y: 0 };
        const joystickRadius = 90;
        let lastTapTime = 0;

        // FPS
        let lastTime = performance.now();
        let frameCount = 0;
        let globalFrame = 0;

        // Elements
        const stickKnob = document.getElementById('stick-knob');
        const headingArrow = document.getElementById('heading-arrow');
        const movementZone = document.getElementById('movement-zone');

        const timeBtn = document.getElementById('time-btn');
        const collapseBtn = document.getElementById('collapse-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const settingsModalClose = document.getElementById('settings-modal-close');
        const shareBtn = document.getElementById('share-btn');
        const shareModal = document.getElementById('share-modal');
        const shareModalClose = document.getElementById('share-modal-close');
        const shareLinkInput = document.getElementById('share-link');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const snapShareDiv = document.querySelector('.snapchat-creative-kit-share');
        const snapFallbackLink = document.getElementById('snap-fallback-link');

        init();
        animate();
        /**
         * Initialize the game scene, renderer, listeners, and entities.
         */
        function init() {
            const container = document.getElementById('game-container');

            // Compute absolute share URL for reliability across domains/hosts
            const shareUrl = new URL('/drive', window.location.origin).toString().replace(/\/$/, '');
            if (shareLinkInput) shareLinkInput.value = shareUrl;
            if (snapShareDiv) {
                snapShareDiv.setAttribute('data-share-url', shareUrl);
                if (!snapShareDiv.getAttribute('data-share-text')) {
                    snapShareDiv.setAttribute('data-share-text', 'Come drive this voxel racer!');
                }
            }
            if (snapFallbackLink) {
                snapFallbackLink.href = 'https://www.snapchat.com/compose?attachmentUrl=' + encodeURIComponent(shareUrl);
            }

            scene = new THREE.Scene();

            // Initial Day Mode Setup
            const dayColor = 0x87CEEB;
            scene.background = new THREE.Color(dayColor);
            scene.fog = new THREE.Fog(0xa0d8ef, 50, 240);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 800);

            // Optimization: Limit pixel ratio to 1.5 by default (max), adjustable by user.
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            // Optimization: Adjustable shadow map texture
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            const d = 100;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            scene.add(sunLight);

            // Settings Miniature Scene - Supercar
            settingsMiniatureSceneSuper = new THREE.Scene();
            settingsMiniatureCameraSuper = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            settingsMiniatureCameraSuper.position.set(0, 0, 3.5);

            const canvasSuper = document.getElementById('settings-miniature-canvas-supercar');
            settingsMiniatureRendererSuper = new THREE.WebGLRenderer({ canvas: canvasSuper, alpha: true, antialias: true });
            settingsMiniatureRendererSuper.setSize(120, 120);
            settingsMiniatureRendererSuper.setPixelRatio(window.devicePixelRatio);
            settingsMiniatureRendererSuper.setClearColor(0x000000, 0);

            const ambSuper = new THREE.AmbientLight(0xffffff, 0.8);
            settingsMiniatureSceneSuper.add(ambSuper);
            const dirSuper = new THREE.DirectionalLight(0xffffff, 1.0);
            dirSuper.position.set(2, 5, 5);
            settingsMiniatureSceneSuper.add(dirSuper);

            miniatureGroupSuper = new THREE.Group();
            settingsMiniatureSceneSuper.add(miniatureGroupSuper);

            // Settings Miniature Scene - Hypercar
            settingsMiniatureSceneHyper = new THREE.Scene();
            settingsMiniatureCameraHyper = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            settingsMiniatureCameraHyper.position.set(0, 0, 3.5);

            const canvasHyper = document.getElementById('settings-miniature-canvas-hypercar');
            settingsMiniatureRendererHyper = new THREE.WebGLRenderer({ canvas: canvasHyper, alpha: true, antialias: true });
            settingsMiniatureRendererHyper.setSize(120, 120);
            settingsMiniatureRendererHyper.setPixelRatio(window.devicePixelRatio);
            settingsMiniatureRendererHyper.setClearColor(0x000000, 0);

            const ambHyper = new THREE.AmbientLight(0xffffff, 0.8);
            settingsMiniatureSceneHyper.add(ambHyper);
            const dirHyper = new THREE.DirectionalLight(0xffffff, 1.0);
            dirHyper.position.set(2, 5, 5);
            settingsMiniatureSceneHyper.add(dirHyper);

            miniatureGroupHyper = new THREE.Group();
            settingsMiniatureSceneHyper.add(miniatureGroupHyper);

            // Miniature click handling
            const btnSuper = document.getElementById('miniature-container-supercar');
            if (btnSuper) {
                btnSuper.addEventListener('click', (e) => { e.stopPropagation(); selectCarType('supercar'); });
                btnSuper.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); selectCarType('supercar'); }, { passive: false });
            }
            const btnHyper = document.getElementById('miniature-container-hypercar');
            if (btnHyper) {
                btnHyper.addEventListener('click', (e) => { e.stopPropagation(); selectCarType('hypercar'); });
                btnHyper.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); selectCarType('hypercar'); }, { passive: false });
            }



            // PRE-GENERATE TEXTURES (Speed Boost)
            dayGroundTexture = createGroundTexture(false);
            nightGroundTexture = createGroundTexture(true);

            // Geometry Init
            initPedestrianGeometries();
            initWorldGeometries();

            // Player Init
            createPlayer();
            updateMiniatureModels();
            createSnow();

            // Entities - Reduced count for mobile optimization
            const pedestrianCount = 80; // Unified for mobile and desktop
            for (let i = 0; i < pedestrianCount; i++) {
                createPedestrianData();
            }

            // Events
            window.addEventListener('resize', onWindowResize);

            // Keyboard Controls
            document.addEventListener('keydown', (e) => {
                if (moveTouchId !== null) return;
                const k = e.key;
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'].includes(k) ||
                    ['W', 'A', 'S', 'D'].includes(k)) {
                    keysPressed[k.toLowerCase()] = true;
                    if (k.startsWith('Arrow')) keysPressed[k] = true; // Handle Arrow keys specifically if needed or just normalize
                    updateMoveInputFromKeys();
                }
            });
            document.addEventListener('keyup', (e) => {
                const k = e.key;
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'].includes(k) ||
                    ['W', 'A', 'S', 'D'].includes(k)) {
                    keysPressed[k.toLowerCase()] = false;
                    if (k.startsWith('Arrow')) keysPressed[k] = false;
                    if (moveTouchId === null) updateMoveInputFromKeys();
                }
            });
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            document.addEventListener('mousedown', onMouseDown);



            timeBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); toggleDayNight(); updateMiniatureModels(); });
            timeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleDayNight(); updateMiniatureModels(); }, { passive: false });

            // Pimp My Ride Button
            const pimpBtn = document.getElementById('settings-pimp-btn');
            if (pimpBtn) {
                pimpBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeSettingsModal();
                    openVehicleModal();
                });
                pimpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeSettingsModal();
                    openVehicleModal();
                }, { passive: false });
            }

            // Modify Player Button
            const pimpPedBtn = document.getElementById('settings-pimp-ped-btn');
            if (pimpPedBtn) {
                pimpPedBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeSettingsModal();
                    openPedestrianModal();
                });
                pimpPedBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeSettingsModal();
                    openPedestrianModal();
                }, { passive: false });
            }

            // Join Server Button
            const joinServerBtn = document.getElementById('settings-join-server-btn');
            if (joinServerBtn) {
                const handleJoin = () => {
                    const currentIP = localStorage.getItem('serverIP') || '172.16.1.218';
                    const ip = prompt("Enter Server IP Address:", currentIP);
                    if (ip && ip.trim() !== "") {
                        localStorage.setItem('serverIP', ip.trim());
                        location.reload();
                    }
                };
                joinServerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleJoin();
                });
                joinServerBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoin();
                }, { passive: false });
            }

            const resSlider = document.getElementById('res-slider');
            resSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('res-label').innerText = "RESOLUTION: " + val.toFixed(2);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, val));
                if (modalRenderer) modalRenderer.setPixelRatio(val);

                // Also update shadow resolution
                if (sunLight && sunLight.shadow) {
                    const shadowSize = Math.round(1024 * val);
                    sunLight.shadow.mapSize.width = shadowSize;
                    sunLight.shadow.mapSize.height = shadowSize;
                    if (sunLight.shadow.map) {
                        sunLight.shadow.map.dispose();
                        sunLight.shadow.map = null;
                    }
                }
            });


            // Stop propagation to prevent driving while sliding
            resSlider.addEventListener('mousedown', (e) => e.stopPropagation());
            resSlider.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: false });

            // FPS Toggle Logic
            const toggleFpsBtn = document.getElementById('toggle-fps-btn');
            if (toggleFpsBtn) {
                const updateFpsBtnState = () => {
                    const fpsCounter = document.getElementById('fps-counter');
                    // Check computed style to act correctly on first click
                    const isHidden = window.getComputedStyle(fpsCounter).display === 'none';
                    if (isHidden) {
                        fpsCounter.style.display = 'block';
                        toggleFpsBtn.innerText = "Hide FPS";
                        toggleFpsBtn.style.background = "rgba(255,255,255,0.3)";
                    } else {
                        fpsCounter.style.display = 'none';
                        toggleFpsBtn.innerText = "Show FPS";
                        toggleFpsBtn.style.background = "rgba(255,255,255,0.1)";
                    }
                };

                toggleFpsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    updateFpsBtnState();
                });
                toggleFpsBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    updateFpsBtnState();
                }, { passive: false });
            }

            collapseBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); toggleHUD(); });
            collapseBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleHUD(); }, { passive: false });

            settingsBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); openSettingsModal(); });
            settingsBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); openSettingsModal(); }, { passive: false });

            settingsModalClose.addEventListener('click', closeSettingsModal);
            settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsModal(); });
            settingsModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closeSettingsModal(); }, { passive: false });
            settingsModal.addEventListener('touchstart', (e) => { if (e.target === settingsModal) { e.preventDefault(); e.stopPropagation(); closeSettingsModal(); } }, { passive: false });

            shareBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); openShareModal(); });
            shareBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); openShareModal(); }, { passive: false });

            shareModalClose.addEventListener('click', closeShareModal);
            shareModal.addEventListener('click', (e) => { if (e.target === shareModal) closeShareModal(); });

            copyLinkBtn.addEventListener('click', copyShareLink);

            // Mobile touch handlers for modal actions
            shareModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closeShareModal(); }, { passive: false });
            shareModal.addEventListener('touchstart', (e) => {
                if (e.target === shareModal) { e.preventDefault(); e.stopPropagation(); closeShareModal(); }
            }, { passive: false });
            copyLinkBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); copyShareLink(); }, { passive: false });

            // Event listeners for modal car dragging and painting
            const mCanvas = document.getElementById('modal-canvas');
            mCanvas.addEventListener('mousedown', onModalMouseDown, false);
            mCanvas.addEventListener('mousemove', onModalMouseMove, false);
            mCanvas.addEventListener('mouseup', onModalMouseUp, false);
            mCanvas.addEventListener('mouseleave', onModalMouseUp, false);

            mCanvas.addEventListener('touchstart', onModalTouchStart, { passive: false });
            mCanvas.addEventListener('touchmove', onModalTouchMove, { passive: false });
            mCanvas.addEventListener('touchend', onModalTouchEnd, { passive: false });

            vehicleModalClose.addEventListener('click', closeVehicleModal);
            vehicleModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closeVehicleModal(); }, { passive: false });

            // Reset Buttons
            const vReset = document.getElementById('vehicle-reset-btn');
            vReset.addEventListener('mousedown', (e) => { e.stopPropagation(); resetVehicleDefaults(); });
            vReset.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); resetVehicleDefaults(); }, { passive: false });

            const pReset = document.getElementById('pedestrian-reset-btn');
            pReset.addEventListener('mousedown', (e) => { e.stopPropagation(); resetPedestrianDefaults(); });
            pReset.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); resetPedestrianDefaults(); }, { passive: false });

            // Username Input Logic
            const usernameInput = document.getElementById('player-username');
            if (usernameInput) {
                const savedName = localStorage.getItem('playerUsername');
                if (savedName) usernameInput.value = savedName;

                usernameInput.addEventListener('input', (e) => {
                    localStorage.setItem('playerUsername', e.target.value);
                });
                usernameInput.addEventListener('mousedown', (e) => e.stopPropagation());
                usernameInput.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: false });
                usernameInput.addEventListener('touchend', (e) => e.stopPropagation(), { passive: false });
                usernameInput.addEventListener('keydown', (e) => e.stopPropagation());
            }

            initVehicleModal();
            initColorPalette();

            initPedestrianModal();
            initPedestrianColorPalette();
            initSocket();
        }

        // --- Vehicle Modal Functions ---
        /**
         * Initialize the vehicle color palette UI.
         */
        function initColorPalette() {
            const container = document.getElementById('color-palette');
            paintColors.forEach((col, index) => {
                const div = document.createElement('div');
                div.className = 'color-swatch';
                div.style.backgroundColor = '#' + new THREE.Color(col).getHexString();
                div.dataset.color = col;
                if (index === 0) div.classList.add('selected');

                div.addEventListener('click', (e) => {
                    // Prevent modal drag/close
                    e.stopPropagation();
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                });
                // Touch support
                div.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent ghost clicks
                    e.stopPropagation();
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                }, { passive: false });

                container.appendChild(div);
            });
        }

        /**
         * Handle mouse down on the vehicle modal canvas.
         * @param {MouseEvent} event 
         */
        function onModalMouseDown(event) {
            if (event.target === vehicleModalClose) return;
            isDraggingModalCar = true;
            isPaintClick = true; // Assume click until moved
            lastDragX = event.clientX;
        }

        /**
         * Handle mouse move on the vehicle modal canvas for rotation.
         * @param {MouseEvent} event 
         */
        function onModalMouseMove(event) {
            if (!isDraggingModalCar) return;
            isPaintClick = false; // Movement detected, not a static click
            const deltaX = event.clientX - lastDragX;
            modalCarGroup.rotation.y += deltaX * 0.015;
            lastDragX = event.clientX;
        }

        /**
         * Handle mouse up on the vehicle modal canvas to finish drag or click.
         * @param {MouseEvent} event 
         */
        function onModalMouseUp(event) {
            if (isDraggingModalCar && isPaintClick) {
                // It was a click!
                handlePaintClick(event.clientX, event.clientY);
            }
            isDraggingModalCar = false;
        }

        /**
         * Handle touch start on the vehicle modal canvas.
         * @param {TouchEvent} event 
         */
        function onModalTouchStart(event) {
            if (event.target === vehicleModalClose) return;
            isDraggingModalCar = true;
            isPaintClick = true;
            lastDragX = event.touches[0].clientX;
            event.preventDefault();
        }

        /**
         * Handle touch move on the vehicle modal canvas.
         * @param {TouchEvent} event 
         */
        function onModalTouchMove(event) {
            if (!isDraggingModalCar) return;
            const currentX = event.touches[0].clientX;
            // Threshold for "movement" to avoid micro-jitters preventing clicks
            if (Math.abs(currentX - lastDragX) > 2) {
                isPaintClick = false;
            }
            const deltaX = currentX - lastDragX;
            modalCarGroup.rotation.y += deltaX * 0.015;
            lastDragX = currentX;
            event.preventDefault();
        }

        /**
         * Handle touch end on the vehicle modal canvas.
         * @param {TouchEvent} event 
         */
        function onModalTouchEnd(event) {
            if (isDraggingModalCar && isPaintClick) {
                // Use changedTouches for position
                const t = event.changedTouches[0];
                handlePaintClick(t.clientX, t.clientY);
            }
            isDraggingModalCar = false;
            event.preventDefault(); // Prevent double firing if browser synthesizes mouse events
        }

        /**
         * Process a painting click on the 3D model in the vehicle modal.
         * @param {number} clientX - X coordinate of the click
         * @param {number} clientY - Y coordinate of the click
         */
        function handlePaintClick(clientX, clientY) {
            // Raycast logic
            if (!modalRenderer || !modalCamera) return;

            const rect = modalRenderer.domElement.getBoundingClientRect();
            modalMouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            modalMouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            paintRaycaster.setFromCamera(modalMouse, modalCamera);

            // Intersect with modal car
            // Note: modalCarGroup has a child which is the car Group
            const intersects = paintRaycaster.intersectObjects(modalCarGroup.children, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const mesh = hit.object;

                if (mesh.isMesh) {
                    if (mesh.userData.paintable === false || mesh.userData.partGroup === 'light' || mesh.userData.partGroup === 'non-paintable') return; // Non-paintable parts like wheels, lights, etc.

                    if (mesh.userData.partType === 'glass') {
                        // For glass, create a new transparent material
                        mesh.material = new THREE.MeshStandardMaterial({
                            color: selectedColor,
                            transparent: true,
                            opacity: 0.6, // Adjust for desired transparency
                            metalness: 0.8,
                            roughness: 0.1
                        });
                        // Save glass color separately if needed, or assume it's not persistently customizable
                    } else if (mesh.userData.partGroup === 'body') {
                        // For body parts
                        mesh.material.color.setHex(selectedColor);
                        vehicleColors[carType].body = selectedColor; // Save body color
                    } else if (mesh.userData.partGroup === 'spoiler') {
                        // For spoiler parts
                        mesh.material.color.setHex(selectedColor);
                        vehicleColors[carType].spoiler = selectedColor; // Save spoiler color
                    }

                    // If emissive exists and is not black, update it too? 
                    // This part remains unchanged, typically emissive is for lights.
                    if (mesh.material.emissive && mesh.material.emissive.getHex() > 0) {
                        // Only if it's not a light component we probably shouldn't touch emissive
                        // For now just albedo.
                    }

                    // Sync with Player Car
                    // Find the index of this mesh in the modal hierarchy
                    // The structure is modalCarGroup -> carGroup -> [Mesh1, Mesh2, ...]
                    // We need to find which child index of carGroup matches `mesh`.

                    const carGroup = modalCarGroup.children[0];
                    if (!carGroup) return;

                    let foundIndex = -1;
                    for (let i = 0; i < carGroup.children.length; i++) {
                        if (carGroup.children[i] === mesh) {
                            foundIndex = i;
                            break;
                        }
                    }

                    if (foundIndex !== -1 && currentCarMesh) {
                        const playerMeshPart = currentCarMesh.children[foundIndex];
                        if (playerMeshPart && playerMeshPart.isMesh) {
                            if (playerMeshPart.userData.partType === 'glass') {
                                playerMeshPart.material = new THREE.MeshStandardMaterial({
                                    color: selectedColor,
                                    transparent: true,
                                    opacity: 0.6,
                                    metalness: 0.8,
                                    roughness: 0.1
                                });
                            } else {
                                playerMeshPart.material.color.setHex(selectedColor);
                            }
                        }
                    }
                }
                // Persistent save
                localStorage.setItem('vehicleColors', JSON.stringify(vehicleColors));
                if (socket) {
                    socket.emit('updatePlayerDetails', { vehicleColors: vehicleColors });
                }
            }
        }


        /**
         * Initialize the vehicle customization modal (scene, camera, renderer).
         */
        function initVehicleModal() {
            modalScene = new THREE.Scene();
            modalCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            modalCamera.position.set(0, 1.25, 3.5); // Adjusted Y and Z for smaller car and lower car
            modalCamera.lookAt(0, -1.05, 0); // Look lower to shift vehicle up

            const canvas = document.getElementById('modal-canvas');
            modalRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });

            const resSlider = document.getElementById('res-slider');
            const currentRes = resSlider ? parseFloat(resSlider.value) : 1.0;
            modalRenderer.setPixelRatio(currentRes);

            modalRenderer.setClearColor(0x000000, 0); // Transparent

            // Lights for modal
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            modalScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(5, 10, 5);
            modalScene.add(dir);
            const spot = new THREE.SpotLight(0xffffff, 0.8);
            spot.position.set(-5, 5, 5);
            modalScene.add(spot);

            modalCarGroup = new THREE.Group();
            modalScene.add(modalCarGroup);
        }

        /**
         * Open the vehicle customization modal and display the car.
         */
        function openVehicleModal() {
            vehicleModal.classList.add('active');
            vehicleModalOpen = true;

            const width = vehicleModal.clientWidth;
            const height = vehicleModal.clientHeight;
            modalRenderer.setSize(width, height, false);
            modalCamera.aspect = width / height;
            modalCamera.updateProjectionMatrix();

            // Clear previous
            while (modalCarGroup.children.length > 0) {
                modalCarGroup.remove(modalCarGroup.children[0]);
            }

            // Build current car for modal
            const mesh = createVehicle({
                type: carType,
                bodyColor: vehicleColors[carType].body, // Pass saved body color
                spoilerColor: vehicleColors[carType].spoiler, // Pass saved spoiler color
                addLights: true,
                scale: 0.25
            });

            // Rotate continuously in animate loop
            modalCarGroup.add(mesh);

            // Pause game? Maybe just set flag to ignore inputs
        }

        /**
         * Close the vehicle customization modal.
         */
        function closeVehicleModal() {
            vehicleModal.classList.remove('active');
            vehicleModalOpen = false;
        }

        function openSettingsModal() {
            settingsModal.classList.add('active');
        }

        function closeSettingsModal() {
            settingsModal.classList.remove('active');
            updatePlayerLabel();
        }

        /**
         * Create a username label sprite.
         * @param {string} name 
         * @returns {THREE.Sprite}
         */
        function createUsernameLabel(name) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 48;
            ctx.font = `bold ${fontSize}px sans-serif`;
            const textWidth = ctx.measureText(name).width;

            // Pad the canvas
            const width = textWidth + 40;
            const height = fontSize + 40;

            canvas.width = width;
            canvas.height = height;

            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Text Stroke (Outline)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 6;
            ctx.lineJoin = 'round';
            ctx.strokeText(name, width / 2, height / 2);

            // Text Fill
            ctx.fillStyle = 'white';
            ctx.fillText(name, width / 2, height / 2);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, sizeAttenuation: true, depthTest: false, depthWrite: false, transparent: true, opacity: 0.7 });

            const sprite = new THREE.Sprite(mat);
            // Adjust scale. Pixels to World Units ratio.
            const scaleFactor = 0.02;
            sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);
            sprite.renderOrder = 999;

            return sprite;
        }

        /**
         * Update the username label on player/vehicle.
         */
        function updatePlayerLabel() {
            const name = localStorage.getItem('playerUsername');



            // Refactored logic below:

            // 1. Vehicle Logic
            if (currentCarMesh) {
                // Remove any existing label first
                for (let i = currentCarMesh.children.length - 1; i >= 0; i--) {
                    if (currentCarMesh.children[i].userData.isNameLabel) {
                        currentCarMesh.remove(currentCarMesh.children[i]);
                    }
                }

                // If in vehicle mode AND name exists, add it
                if (controlMode === 'vehicle' && name && name.trim() !== '') {
                    const label = createUsernameLabel(name);
                    label.position.set(0, 3.5, 0); // Car height offset
                    label.userData.isNameLabel = true;
                    currentCarMesh.add(label);
                }
            }

            // 2. Pedestrian Logic
            if (userPedestrian && userPedestrian.mesh) {
                // Remove existing
                for (let i = userPedestrian.mesh.children.length - 1; i >= 0; i--) {
                    if (userPedestrian.mesh.children[i].userData.isNameLabel) {
                        userPedestrian.mesh.remove(userPedestrian.mesh.children[i]);
                    }
                }

                // Pedestrian always implies pedestrian mode, so add if name exists
                if (name && name.trim() !== '') {
                    const label = createUsernameLabel(name);
                    label.position.set(0, 2.5, 0); // Ped height offset
                    label.userData.isNameLabel = true;
                    userPedestrian.mesh.add(label);
                }
            }
        }

        // --- Pedestrian Modal Functions ---
        /**
         * Initialize the pedestrian color palette UI.
         */
        function initPedestrianColorPalette() {
            const container = document.getElementById('ped-color-palette');
            clothingColors.forEach((col, index) => {
                const div = document.createElement('div');
                div.className = 'color-swatch';
                div.style.backgroundColor = '#' + new THREE.Color(col).getHexString();
                div.dataset.color = col;
                if (index === 0) div.classList.add('selected');

                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('#ped-color-palette .color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                });
                div.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.querySelectorAll('#ped-color-palette .color-swatch').forEach(s => s.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedColor = parseInt(div.dataset.color);
                }, { passive: false });

                container.appendChild(div);
            });
        }

        /**
         * Initialize the pedestrian customization modal.
         */
        function initPedestrianModal() {
            pedModalScene = new THREE.Scene();
            pedModalCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            pedModalCamera.position.set(0, 1.0, 5.0);
            pedModalCamera.lookAt(0, 0, 0);

            const canvas = document.getElementById('ped-modal-canvas');
            pedModalRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });

            const resSlider = document.getElementById('res-slider');
            const currentRes = resSlider ? parseFloat(resSlider.value) : 1.0;
            pedModalRenderer.setPixelRatio(currentRes);
            pedModalRenderer.setClearColor(0x000000, 0);

            const amb = new THREE.AmbientLight(0xffffff, 0.8);
            pedModalScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(5, 10, 5);
            pedModalScene.add(dir);

            pedModalPedGroup = new THREE.Group();
            pedModalScene.add(pedModalPedGroup);

            // Canvas events
            canvas.addEventListener('mousedown', onPedModalMouseDown, false);
            canvas.addEventListener('mousemove', onPedModalMouseMove, false);
            canvas.addEventListener('mouseup', onPedModalMouseUp, false);
            canvas.addEventListener('mouseleave', onPedModalMouseUp, false);
            canvas.addEventListener('touchstart', onPedModalTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onPedModalTouchMove, { passive: false });
            canvas.addEventListener('touchend', onPedModalTouchEnd, { passive: false });

            pedestrianModalClose.addEventListener('click', closePedestrianModal);
            pedestrianModalClose.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); closePedestrianModal(); }, { passive: false });
        }

        /**
         * Open the pedestrian customization modal with current player settings.
         */
        function openPedestrianModal() {
            // Using existing userPedestrian colors or defaults if not spawned
            const sourceColors = userPedestrian ? userPedestrian.colors : defaultPedestrianColors;
            tempPedColors = { ...sourceColors };

            pedestrianModal.classList.add('active');
            pedestrianModalOpen = true;

            const width = pedestrianModal.clientWidth;
            const height = pedestrianModal.clientHeight;
            pedModalRenderer.setSize(width, height, false);
            pedModalCamera.aspect = width / height;
            pedModalCamera.updateProjectionMatrix();

            while (pedModalPedGroup.children.length > 0) {
                pedModalPedGroup.remove(pedModalPedGroup.children[0]);
            }

            // Create a copy of the user pedestrian for the modal using temp colors
            const dummyData = { isUser: true, ...(userPedestrian || {}), colors: tempPedColors };
            const mesh = buildPedestrianMesh(dummyData);
            mesh.scale.set(0.45, 0.45, 0.45);
            mesh.position.y = 0.4;
            mesh.position.x = -0.6; // Shift left to make room for pants
            pedModalPedGroup.add(mesh);

            // Add a pants preview group since robe hides them
            const pantsPreview = new THREE.Group();
            const pLegL = new THREE.Mesh(pedGeometries.leg, getCachedMaterial(tempPedColors.pants));
            pLegL.position.set(-0.25, 0, 0);
            pLegL.userData.partGroup = 'pants';
            const pLegR = new THREE.Mesh(pedGeometries.leg, getCachedMaterial(tempPedColors.pants));
            pLegR.position.set(0.25, 0, 0);
            pLegR.userData.partGroup = 'pants';
            pantsPreview.add(pLegL, pLegR);
            pantsPreview.position.set(0.8, 0.2, 0); // Positioned higher to the right
            pantsPreview.scale.set(0.45, 0.45, 0.45);
            pedModalPedGroup.add(pantsPreview);
        }

        /**
         * Close the pedestrian customization modal and save changes.
         */
        function closePedestrianModal() {
            if (tempPedColors) {
                // Apply temp colors to userPedestrian if active
                if (userPedestrian) {
                    userPedestrian.colors = { ...tempPedColors };

                    // Sync the world mesh
                    if (userPedestrian.mesh) {
                        userPedestrian.mesh.traverse(child => {
                            if (child.isMesh && child.userData.partGroup) {
                                const group = child.userData.partGroup;
                                if (userPedestrian.colors[group] !== undefined) {
                                    child.material = getCachedMaterial(userPedestrian.colors[group]);
                                }
                            }
                        });
                    }
                }
                // Persistent save
                localStorage.setItem('pedestrianColors', JSON.stringify(tempPedColors));
                // Update global default for next spawn
                Object.assign(defaultPedestrianColors, tempPedColors);
            }

            pedestrianModal.classList.remove('active');
            pedestrianModalOpen = false;
            updatePlayerLabel();

            if (socket) {
                const username = document.getElementById('player-username').value;
                socket.emit('updatePlayerDetails', { vehicleColors: vehicleColors, username: username, pedestrianColors: tempPedColors });
            }
        }

        /**
         * Handle mouse down on the pedestrian modal canvas.
         * @param {MouseEvent} event 
         */
        function onPedModalMouseDown(event) {
            isDraggingModalCar = true; // Reuse vehicle dragging state
            isPaintClick = true;
            lastDragX = event.clientX;
        }

        /**
         * Handle mouse move on the pedestrian modal canvas.
         * @param {MouseEvent} event 
         */
        function onPedModalMouseMove(event) {
            if (!isDraggingModalCar) return;
            isPaintClick = false;
            const deltaX = event.clientX - lastDragX;
            pedModalPedGroup.rotation.y += deltaX * 0.015;
            lastDragX = event.clientX;
        }

        /**
         * Handle mouse up on the pedestrian modal canvas.
         * @param {MouseEvent} event 
         */
        function onPedModalMouseUp(event) {
            if (isDraggingModalCar && isPaintClick) {
                handlePedestrianPaintClick(event.clientX, event.clientY);
            }
            isDraggingModalCar = false;
        }

        /**
         * Handle touch start on the pedestrian modal canvas.
         * @param {TouchEvent} event 
         */
        function onPedModalTouchStart(event) {
            isDraggingModalCar = true;
            isPaintClick = true;
            lastDragX = event.touches[0].clientX;
            event.preventDefault();
        }

        /**
         * Handle touch move on the pedestrian modal canvas.
         * @param {TouchEvent} event 
         */
        function onPedModalTouchMove(event) {
            if (!isDraggingModalCar) return;
            const currentX = event.touches[0].clientX;
            if (Math.abs(currentX - lastDragX) > 2) isPaintClick = false;
            const deltaX = currentX - lastDragX;
            pedModalPedGroup.rotation.y += deltaX * 0.015;
            lastDragX = currentX;
            event.preventDefault();
        }

        /**
         * Handle touch end on the pedestrian modal canvas.
         * @param {TouchEvent} event 
         */
        function onPedModalTouchEnd(event) {
            if (isDraggingModalCar && isPaintClick) {
                const t = event.changedTouches[0];
                handlePedestrianPaintClick(t.clientX, t.clientY);
            }
            isDraggingModalCar = false;
            event.preventDefault();
        }

        /**
         * Process a paint click for the pedestrian model.
         * @param {number} clientX 
         * @param {number} clientY 
         */
        function handlePedestrianPaintClick(clientX, clientY) {
            if (!pedModalRenderer || !pedModalCamera || !tempPedColors) return;
            const rect = pedModalRenderer.domElement.getBoundingClientRect();
            modalMouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            modalMouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            paintRaycaster.setFromCamera(modalMouse, pedModalCamera);
            const intersects = paintRaycaster.intersectObjects(pedModalPedGroup.children, true);

            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh.isMesh && mesh.userData.partGroup) {
                    const group = mesh.userData.partGroup;
                    if (group === 'skin') return; // Cannot edit skin color

                    // Update temp data independently
                    if (tempPedColors[group] !== undefined) {
                        tempPedColors[group] = selectedColor;
                    }

                    // Sync only modal mesh
                    pedModalPedGroup.traverse(child => {
                        if (child.isMesh && child.userData.partGroup === group) {
                            child.material = getCachedMaterial(selectedColor);
                        }
                    });
                }
            }
        }

        /**
         * Reset vehicle colors to factory defaults.
         */
        function resetVehicleDefaults() {
            const defaults = {
                supercar: { body: 0xffffff, spoiler: 0x000000 },
                hypercar: { body: 0xFFD700, spoiler: 0x111111 }
            };
            Object.assign(vehicleColors, JSON.parse(JSON.stringify(defaults)));
            localStorage.setItem('vehicleColors', JSON.stringify(vehicleColors));
            if (socket) {
                socket.emit('updatePlayerDetails', { vehicleColors: vehicleColors });
            }

            // Re-open/refresh the modal content to rebuild from new colors
            openVehicleModal();
            // Sync with player car
            loadCarModel(carType);
        }

        /**
         * Reset pedestrian clothing colors to defaults.
         */
        function resetPedestrianDefaults() {
            const defaults = {
                shirt: 0x111111, pants: 0x111111, skin: 0xffccaa, robe: 0x000000, hat: 0x555555
            };

            if (tempPedColors) {
                Object.assign(tempPedColors, JSON.parse(JSON.stringify(defaults)));

                // Sync only modal mesh immediately to show visual change
                pedModalPedGroup.traverse(child => {
                    if (child.isMesh && child.userData.partGroup) {
                        const group = child.userData.partGroup;
                        if (tempPedColors[group] !== undefined) {
                            child.material = getCachedMaterial(tempPedColors[group]);
                        }
                    }
                });
            }

            // Reset Username
            const usernameInput = document.getElementById('player-username');
            if (usernameInput) {
                usernameInput.value = '';
                localStorage.removeItem('playerUsername');
            }
        }

        // --- Share Modal Functions ---
        /**
         * Open the share modal.
         */
        function openShareModal() {
            shareModal.classList.add('active');
        }

        /**
         * Close the share modal.
         */
        function closeShareModal() {
            shareModal.classList.remove('active');
        }

        /**
         * Copy the share link to clipboard.
         */
        function copyShareLink() {
            const text = shareLinkInput.value;
            const showCopied = () => {
                copyLinkBtn.textContent = 'Copied!';
                setTimeout(() => { copyLinkBtn.textContent = 'Copy'; }, 1200);
            };
            const fallbackCopy = () => {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'fixed';
                    ta.style.top = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    showCopied();
                } catch (err) {
                    showCopied();
                }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(showCopied).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        }

        // --- Day/Night Toggle System (Updated for Brightness) ---

        /**
         * Toggle the visibility of the Heads-Up Display (HUD).
         */
        function toggleHUD() {
            document.body.classList.toggle('hud-hidden');
            const isHidden = document.body.classList.contains('hud-hidden');
            const collapseBtn = document.getElementById('collapse-btn');

            // Eye when hidden (click to show), Eye Slash when visible (click to hide)
            const iconEye = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
            const iconEyeSlash = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>`;

            if (collapseBtn) {
                collapseBtn.innerHTML = isHidden ? iconEye : iconEyeSlash;
            }
        }

        /**
         * Toggle between Day and Night modes, updating lighting and materials.
         */
        function toggleDayNight() {
            isNightMode = !isNightMode;

            if (isNightMode) {
                const duskColor = 0x1a1a2e;
                scene.background.setHex(duskColor);
                scene.fog.color.setHex(duskColor);
                scene.fog.near = 30;
                scene.fog.far = 180;

                // BRIGHTER NIGHT SETTINGS
                ambientLight.intensity = 0.55;
                sunLight.color.setHex(0xaaccff);
                sunLight.intensity = 0.6;

                const instr = document.querySelector('.instructions');
                if (instr) instr.innerHTML = "Night Run<br>Left Stick: Drive";
                timeBtn.innerText = "â˜€ï¸";

                roadMaterial.color.setHex(0x222222);
                lineMaterial.color.setHex(0xaa8800);
                grassMaterial.color.setHex(0x335533);
                lightBulbMaterial.emissiveIntensity = 3.0; // Very bright
                lightSpotMaterial.opacity = 0.8; // Turn on ground spots

                // Swap texture instantly
                groundMaterial.map = nightGroundTexture;

            } else {
                const dayColor = 0x87CEEB;
                scene.background.setHex(dayColor);
                scene.fog.color.setHex(0xa0d8ef);
                scene.fog.near = 50;
                scene.fog.far = 240;

                ambientLight.intensity = 0.6;
                sunLight.color.setHex(0xffffff);
                sunLight.intensity = 0.8;

                const instr = document.querySelector('.instructions');
                if (instr) instr.innerHTML = "Day Run<br>Left Stick: Drive";
                timeBtn.innerText = "ðŸŒ™";

                roadMaterial.color.setHex(0x333333);
                lineMaterial.color.setHex(0xffcc00);
                grassMaterial.color.setHex(0x44aa44);
                lightBulbMaterial.emissiveIntensity = 0.2; // Dim
                lightSpotMaterial.opacity = 0.0; // Hide ground spots

                // Swap texture instantly
                groundMaterial.map = dayGroundTexture;
            }

            // Update buildings to swap window textures
            activeChunks.forEach(chunk => {
                chunk.mesh.traverse(child => {
                    if (child.userData.isBuilding) {
                        const seed = child.userData.seed;
                        // Swap entire material reference to cached Day/Night material
                        child.material = getBuildingMaterial(seed, isNightMode);
                    }
                });
            });

            // Update traffic lights
            trafficVehicles.forEach(npc => {
                npc.mesh.traverse(child => {
                    if (child.isLight) {
                        // Only enable spotlights at night
                        child.visible = isNightMode;
                    }
                });
            });

            loadCarModel(carType);
        }

        // --- Miniature UI ---

        /**
         * Update the position of the 2D miniature UI element based on camera projection.
         */


        /**
         * Update the 3D model shown in the miniature UI.
         */
        function updateMiniatureModels() {
            // Update Supercar Miniature
            while (miniatureGroupSuper.children.length > 0) {
                miniatureGroupSuper.remove(miniatureGroupSuper.children[0]);
            }
            const meshSuper = createVehicle({
                type: 'supercar',
                color: vehicleColors['supercar'],
                addLights: false,
                scale: 0.4
            });
            meshSuper.position.y = -0.5;
            miniatureGroupSuper.add(meshSuper);

            // Update Hypercar Miniature
            while (miniatureGroupHyper.children.length > 0) {
                miniatureGroupHyper.remove(miniatureGroupHyper.children[0]);
            }
            const meshHyper = createVehicle({
                type: 'hypercar',
                color: vehicleColors['hypercar'],
                addLights: false,
                scale: 0.35
            });
            meshHyper.position.y = -0.5;
            miniatureGroupHyper.add(meshHyper);

            // Highlight selected
            const btnSuper = document.getElementById('miniature-container-supercar');
            const btnHyper = document.getElementById('miniature-container-hypercar');
            if (btnSuper && btnHyper) {
                if (carType === 'supercar') {
                    btnSuper.style.borderColor = 'rgba(255, 255, 255, 1.0)';
                    btnSuper.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.5)';
                    btnHyper.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    btnHyper.style.boxShadow = 'none';
                } else {
                    btnHyper.style.borderColor = 'rgba(255, 255, 255, 1.0)';
                    btnHyper.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.5)';
                    btnSuper.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    btnSuper.style.boxShadow = 'none';
                }
            }
        }

        function selectCarType(type) {
            if (carType === type) return;
            loadCarModel(type);
            velocity.y = 0.5;
            isAirborne = true;
            updateMiniatureModels();
        }

        /**
         * Check if a click coordinates intersect with the miniature UI.
         * @param {number} clientX 
         * @param {number} clientY 
         * @returns {boolean}
         */


        /**
         * Check if a click intersects with the player vehicle.
         * @param {number} clientX 
         * @param {number} clientY 
         * @returns {boolean}
         */
        function checkVehicleTap(clientX, clientY) {
            if (!player) return false;
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(player.children, true);
            return intersects.length > 0;
        }

        /**
         * Check if a click intersects with the user's pedestrian.
         * @param {number} clientX 
         * @param {number} clientY 
         * @returns {boolean}
         */
        function checkPedestrianTap(clientX, clientY) {
            if (controlMode !== 'pedestrian' || !userPedestrian || !userPedestrian.mesh) return false;
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(userPedestrian.mesh.children, true);
            return intersects.length > 0;
        }

        /**
         * Handle a tap on the vehicle (e.g., getting out).
         */
        function handleVehicleTap() {
            if (controlMode === 'vehicle') {
                velocity.set(0, 0, 0);
                spawnPedestrianBesidePlayer();
            } else if (controlMode === 'pedestrian') {
                enterVehicle();
            }
        }

        /**
         * Handle a tap on the user pedestrian (e.g., open customization).
         */
        function handlePedestrianTap() {
            openPedestrianModal();
        }

        /**
         * Transition from pedestrian mode back to vehicle mode.
         */
        function enterVehicle() {
            if (userPedestrian) {
                scene.remove(userPedestrian.mesh);
                userPedestrian = null;
            }
            controlMode = 'vehicle';
            controlMode = 'vehicle';
            centerCamera();
            updatePlayerLabel();
        }

        /**
         * Spawn a pedestrian character beside the player vehicle.
         */
        function spawnPedestrianBesidePlayer() {
            // Remove from allPedestrians if we are recycling createPedestrianData
            // But createPedestrianData adds to allPedestrians array.
            // We should create a separate pedestrian for the user.

            const angle = player.rotation.y + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
            const dist = 5.0;
            const pos = new THREE.Vector3(
                player.position.x + Math.sin(angle) * dist,
                2.0,
                player.position.z + Math.cos(angle) * dist
            );

            // Create user pedestrian data manually to avoid AI loop interference
            const colors = { ...defaultPedestrianColors };

            userPedestrian = {
                position: pos,
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: Math.atan2(player.position.x - pos.x, player.position.z - pos.z),
                animPhase: 0,
                mesh: null,
                colors: colors,
                isUser: true
            };

            userPedestrian.mesh = buildPedestrianMesh(userPedestrian);
            userPedestrian.mesh.position.copy(userPedestrian.position);
            userPedestrian.mesh.rotation.y = userPedestrian.rotation;

            controlMode = 'pedestrian';
            updatePlayerLabel();

            scene.add(userPedestrian.mesh);
        }

        // --- Infinite Map System ---

        /**
         * Create a texture for the fake light spot on the ground.
         * @returns {THREE.CanvasTexture}
         */
        function createLightSpotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, 'rgba(255, 255, 200, 0.8)'); // Bright warm center
            grd.addColorStop(0.3, 'rgba(255, 255, 220, 0.3)');
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        /**
         * Initialize geometries and materials for world objects (road, grass, poles).
         */
        function initWorldGeometries() {
            groundGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
            groundMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.9, metalness: 0.1, map: dayGroundTexture
            });

            roadTileGeometry = new THREE.PlaneGeometry(ROAD_TILE_SIZE, ROAD_TILE_SIZE);
            roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.2 });

            lineTileGeometry = new THREE.PlaneGeometry(2, 6);
            lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

            buildingGeometries.small = new THREE.BoxGeometry(10, 30, 10);
            buildingGeometries.tall = new THREE.BoxGeometry(15, 80, 15);
            buildingGeometries.wide = new THREE.BoxGeometry(30, 25, 20);

            // Grass Geometry
            grassGeometry = new THREE.PlaneGeometry(0.8, 2.0);
            grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x44aa44,
                roughness: 1.0,
                side: THREE.DoubleSide
            });

            // Streetlight Geometries - San Francisco Style
            const poleShaftH = 10;
            const poleBaseH = 2.5;

            // 1. Decorative Base
            const bGeo = new THREE.CylinderGeometry(0.6, 0.7, poleBaseH, 8);
            bGeo.translate(0, poleBaseH / 2, 0); // Sits on ground
            poleBaseGeometry = bGeo;

            // 2. Tapered Shaft
            const pGeo = new THREE.CylinderGeometry(0.2, 0.35, poleShaftH, 8);
            pGeo.translate(0, poleBaseH + poleShaftH / 2, 0); // Sits on top of base
            poleGeometry = pGeo;

            // Dark Green Iron look
            poleMaterial = new THREE.MeshStandardMaterial({ color: 0x1a2b1a, roughness: 0.4, metalness: 0.3 });

            // 3. Light Bulb (Spherical/Oval)
            lightBulbGeometry = new THREE.SphereGeometry(0.65, 16, 16);
            lightBulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xfffee0, // Off white yellow
                emissive: 0xffccaa,
                emissiveIntensity: 0.8,
                roughness: 0.1
            });

            // Light Spot on Road (Fake volumetric lighting)
            lightSpotTexture = createLightSpotTexture();

            // SIGNIFICANTLY WIDENED LIGHT SPOT
            lightSpotGeometry = new THREE.PlaneGeometry(70, 70);

            lightSpotMaterial = new THREE.MeshBasicMaterial({
                map: lightSpotTexture,
                transparent: true,
                opacity: 0,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
        }

        /**
         * Generate a procedural ground texture.
         * @param {boolean} isNight - Whether to generate night version
         * @returns {THREE.CanvasTexture}
         */
        function createGroundTexture(isNight) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            if (isNight) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#e0e0e0';
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#e0e0e0';
            }

            ctx.lineWidth = 4;
            const cells = 4;
            const step = 256 / cells;
            for (let i = 0; i <= cells; i++) {
                ctx.beginPath(); ctx.moveTo(i * step, 0); ctx.lineTo(i * step, 256); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * step); ctx.lineTo(256, i * step); ctx.stroke();
            }

            ctx.fillStyle = isNight ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const w = Math.random() * 10 + 2;
                ctx.fillRect(x, y, w, w);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Generate a building texture with windows
        /**
         * Generate a procedural building texture with windows.
         * @param {number} seed - Random seed for building style
         * @param {boolean} isNight - Whether to generate night version
         * @returns {THREE.CanvasTexture}
         */
        function createBuildingTexture(seed, isNight) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Base Color
            const baseColor = isNight
                ? (seed > 0.5 ? '#222233' : '#111122')
                : (seed > 0.5 ? '#cccccc' : '#99aadd');

            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 128, 128);

            // Windows
            const rows = 8;
            const cols = 4;
            const pW = 128 / cols;
            const pH = 128 / rows;
            const gap = 6;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Chance for light to be on/off
                    const lightOn = Math.random() > 0.4;

                    if (isNight) {
                        if (lightOn) {
                            ctx.fillStyle = Math.random() > 0.5 ? '#ffcc66' : '#ffeeaa'; // Yellow/Warm light
                        } else {
                            ctx.fillStyle = '#000000'; // Dark
                        }
                    } else {
                        // Day windows (reflection)
                        ctx.fillStyle = '#334455';
                    }

                    ctx.fillRect((c * pW) + gap, (r * pH) + gap, pW - (gap * 2), pH - (gap * 2));
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        /**
         * Generate a pseudo-random number based on x, z coordinates.
         * @param {number} x 
         * @param {number} z 
         * @returns {number} Value between 0 and 1
         */
        function pseudoRandom(x, z) {
            const val = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
            return val - Math.floor(val);
        }

        // Raw Road Function for flow calculations
        /**
         * Calculate raw noise value for road generation.
         * @param {number} x
         * @param {number} z
         * @returns {number} Raw noise value (can be negative)
         */
        function getRawRoadValue(x, z) {
            const scale = 0.005;
            const v1 = Math.sin(x * scale) + Math.cos(z * scale);
            const v2 = Math.sin(x * scale * 0.5 + z * scale * 0.2) * 0.5;
            return v1 + v2;
        }

        // Visual Road Value (Absolute)
        /**
         * Calculate absolute road value (0 is center of road).
         * @param {number} x
         * @param {number} z
         * @returns {number}
         */
        function getRoadValue(x, z) {
            return Math.abs(getRawRoadValue(x, z));
        }

        // Calculate tangent of the road isoline for smooth traffic flow
        /**
         * Calculate the direction (tangent) of the road at a point.
         * @param {number} x
         * @param {number} z
         * @returns {THREE.Vector3} Normalized tangent vector
         */
        function getRoadTangent(x, z) {
            const scale = 0.005;
            // Function f = sin(xs) + cos(zs) + 0.5*sin(xs0.5 + zs0.2)
            // Derivative wrt x:
            const dx = scale * Math.cos(x * scale) + 0.5 * scale * 0.5 * Math.cos(x * scale * 0.5 + z * scale * 0.2);
            // Derivative wrt z:
            const dz = -scale * Math.sin(z * scale) + 0.5 * scale * 0.2 * Math.cos(x * scale * 0.5 + z * scale * 0.2);

            // Tangent is perpendicular to gradient (dx, dz).
            // T = (-dz, dx) or (dz, -dx).
            const t = new THREE.Vector3(-dz, 0, dx);
            t.normalize();
            return t;
        }

        /**
         * Clean up resources for a map chunk.
         * @param {Object} chunkData
         */
        function disposeChunk(chunkData) {
            if (!chunkData) return;
            const group = chunkData.mesh;
            // Iterate and dispose geometries/materials
            group.traverse(child => {
                if (child.isMesh) {
                    // Don't dispose shared geometries
                }
            });
            scene.remove(group);
        }

        /**
         * Get the current active position (player or pedestrian).
         * @returns {THREE.Vector3}
         */
        function getActivePosition() {
            if (controlMode === 'pedestrian' && userPedestrian) {
                return userPedestrian.position;
            }
            return player.position;
        }

        /**
         * Update loop to create new map chunks and remove old ones.
         */
        function updateChunks() {
            if (!player) return;
            const centerPos = getActivePosition();
            if (centerPos.distanceToSquared(lastChunkUpdatePos) < 2500) return;
            lastChunkUpdatePos.copy(centerPos);
            const px = centerPos.x;
            const pz = centerPos.z;
            const currentChunkX = Math.floor(px / CHUNK_SIZE + 0.5);
            const currentChunkZ = Math.floor(pz / CHUNK_SIZE + 0.5);

            const newKeys = new Set();

            // Generate valid keys
            for (let x = -CHUNK_RENDER_DIST; x <= CHUNK_RENDER_DIST; x++) {
                for (let z = -CHUNK_RENDER_DIST; z <= CHUNK_RENDER_DIST; z++) {
                    const cx = currentChunkX + x;
                    const cz = currentChunkZ + z;
                    const key = `${cx},${cz}`;
                    newKeys.add(key);
                    if (!activeChunks.has(key)) createChunk(cx, cz);
                }
            }

            // Garbage Collection
            for (const [key, chunkData] of activeChunks) {
                if (!newKeys.has(key)) {
                    disposeChunk(chunkData);
                    activeChunks.delete(key);
                }
            }
        }

        /**
         * Get or create a cached material for a building.
         * @param {number} seed 
         * @param {boolean} isNight 
         * @returns {THREE.Material}
         */
        function getBuildingMaterial(seed, isNight) {
            // Bucket seed into 3 types to reduce material count
            let type = 0;
            if (seed < 0.3) type = 1;
            else if (seed < 0.6) type = 2;
            else type = 3;

            const key = `${type}_${isNight}`;
            if (!buildingMaterialCache.has(key)) {
                // Generate texture for this bucket
                const map = createBuildingTexture(seed, isNight);
                const mat = new THREE.MeshStandardMaterial({
                    map: map,
                    roughness: 0.3,
                    metalness: 0.1
                });
                if (isNight) {
                    mat.emissive = new THREE.Color(0x222222); // Slight glow for windows visibility
                    mat.emissiveMap = map;
                    mat.emissiveIntensity = 0.5;
                }
                buildingMaterialCache.set(key, mat);
            }
            return buildingMaterialCache.get(key);
        }

        /**
         * Create a new map chunk at grid coordinates (cx, cz).
         * @param {number} cx 
         * @param {number} cz 
         */
        function createChunk(cx, cz) {
            const group = new THREE.Group();
            const chunkX = cx * CHUNK_SIZE;
            const chunkZ = cz * CHUNK_SIZE;
            group.position.set(chunkX, 0, chunkZ);

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.frustumCulled = false;
            group.add(ground);

            const roadMatrices = [];
            const lineMatrices = [];
            const poleMatrices = [];
            const armMatrices = [];
            const bulbMatrices = [];
            const spotMatrices = [];

            const obstacles = [];
            const roadMapPositions = [];
            const roadSet = new Set();
            const halfSize = CHUNK_SIZE / 2;

            // Pre-allocate Objects to avoid GC
            const dummy = new THREE.Object3D();

            for (let lx = -halfSize; lx < halfSize; lx += ROAD_TILE_SIZE) {
                for (let lz = -halfSize; lz < halfSize; lz += ROAD_TILE_SIZE) {
                    const wx = chunkX + lx + ROAD_TILE_SIZE / 2;
                    const wz = chunkZ + lz + ROAD_TILE_SIZE / 2;

                    const rawVal = getRawRoadValue(wx, wz);
                    const val = Math.abs(rawVal);

                    if (val < ROAD_WIDTH_THRESHOLD) {
                        // IT IS ROAD
                        dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.1, lz + ROAD_TILE_SIZE / 2);
                        dummy.rotation.x = -Math.PI / 2;
                        dummy.rotation.y = 0;
                        dummy.rotation.z = 0;
                        dummy.scale.set(1, 1, 1);
                        dummy.updateMatrix();

                        roadMatrices.push(dummy.matrix.clone());
                        roadSet.add(`${lx + ROAD_TILE_SIZE / 2},${lz + ROAD_TILE_SIZE / 2}`);
                        roadMapPositions.push({ x: wx, z: wz });

                        if (val < 0.03) {
                            dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.15, lz + ROAD_TILE_SIZE / 2);
                            dummy.updateMatrix();
                            lineMatrices.push(dummy.matrix.clone());
                        }

                        // --- NPC TRAFFIC SPAWNING ---
                        // Only spawn on valid "lanes" (between center and edge)
                        // Lanes are approx 0.05 to 0.20
                        if (val > 0.05 && val < 0.20) {
                            if (Math.random() < 0.01) { // 1% chance per road tile
                                spawnTrafficCar(wx, 0.5, wz, rawVal > 0);
                            }
                        }

                    } else {
                        // IT IS GRASS/GROUND
                        // CHECK IF WE ARE NEXT TO A ROAD (EDGE DETECTION)
                        // Check neighbors
                        const nRightVal = getRoadValue(wx + ROAD_TILE_SIZE, wz);
                        const nLeftVal = getRoadValue(wx - ROAD_TILE_SIZE, wz);
                        const nTopVal = getRoadValue(wx, wz + ROAD_TILE_SIZE);
                        const nBottomVal = getRoadValue(wx, wz - ROAD_TILE_SIZE);

                        let placeLight = false;
                        let rotY = 0;

                        const LIGHT_SPACING = 60; // Units apart
                        const FREQ_CHECK = (Math.abs(wx) + Math.abs(wz)) % LIGHT_SPACING < ROAD_TILE_SIZE;

                        if (FREQ_CHECK) {
                            if (nRightVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = Math.PI / 2; // Face Right
                            } else if (nLeftVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = -Math.PI / 2; // Face Left
                            } else if (nTopVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = 0; // Face Top (Z+)
                            } else if (nBottomVal < ROAD_WIDTH_THRESHOLD) {
                                placeLight = true; rotY = Math.PI; // Face Bottom
                            }
                        }

                        if (placeLight) {
                            const pX = lx + ROAD_TILE_SIZE / 2;
                            const pZ = lz + ROAD_TILE_SIZE / 2;

                            // 1. Pole Shaft
                            dummy.position.set(pX, 0, pZ);
                            dummy.rotation.set(0, rotY, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            poleMatrices.push(dummy.matrix.clone());

                            // 2. Base (using armMatrices container)
                            dummy.position.set(pX, 0, pZ);
                            dummy.rotation.set(0, rotY, 0); // Rotation doesn't matter much for cylinder
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            armMatrices.push(dummy.matrix.clone());

                            // 3. Bulb (Top of pole)
                            // Height = base 2.5 + shaft 10 = 12.5
                            dummy.position.set(pX, 12.5, pZ);
                            dummy.rotation.set(0, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            bulbMatrices.push(dummy.matrix.clone());

                            // 4. Light Spot (Ground Glare) - Centered
                            dummy.position.set(pX, 0.16, pZ);
                            dummy.rotation.set(-Math.PI / 2, 0, 0); // Flat on ground
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            spotMatrices.push(dummy.matrix.clone());

                            obstacles.push({ x: chunkX + pX, z: chunkZ + pZ, radiusSq: 1.0, isLightpost: true, height: 13 });
                        }
                    }
                }
            }

            if (roadMatrices.length > 0) {
                const roadMesh = new THREE.InstancedMesh(roadTileGeometry, roadMaterial, roadMatrices.length);
                roadMesh.receiveShadow = true;
                for (let i = 0; i < roadMatrices.length; i++) roadMesh.setMatrixAt(i, roadMatrices[i]);
                group.add(roadMesh);
            }
            if (lineMatrices.length > 0) {
                const lineMesh = new THREE.InstancedMesh(lineTileGeometry, lineMaterial, lineMatrices.length);
                for (let i = 0; i < lineMatrices.length; i++) lineMesh.setMatrixAt(i, lineMatrices[i]);
                group.add(lineMesh);
            }
            if (poleMatrices.length > 0) {
                const poleMesh = new THREE.InstancedMesh(poleGeometry, poleMaterial, poleMatrices.length);
                poleMesh.castShadow = true;
                for (let i = 0; i < poleMatrices.length; i++) poleMesh.setMatrixAt(i, poleMatrices[i]);
                group.add(poleMesh);
            }
            if (bulbMatrices.length > 0) {
                const bulbMesh = new THREE.InstancedMesh(lightBulbGeometry, lightBulbMaterial, bulbMatrices.length);
                for (let i = 0; i < bulbMatrices.length; i++) bulbMesh.setMatrixAt(i, bulbMatrices[i]);
                group.add(bulbMesh);
            }
            if (armMatrices.length > 0) {
                // RENDER AS POLE BASE
                const armMesh = new THREE.InstancedMesh(poleBaseGeometry, poleMaterial, armMatrices.length);
                armMesh.receiveShadow = true;
                armMesh.castShadow = true;
                for (let i = 0; i < armMatrices.length; i++) armMesh.setMatrixAt(i, armMatrices[i]);
                group.add(armMesh);
            }
            if (spotMatrices.length > 0) {
                const spotMesh = new THREE.InstancedMesh(lightSpotGeometry, lightSpotMaterial, spotMatrices.length);
                for (let i = 0; i < spotMatrices.length; i++) spotMesh.setMatrixAt(i, spotMatrices[i]);
                group.add(spotMesh);
            }

            let seed = pseudoRandom(cx, cz);
            // obstacles array already initialized above
            const numObjects = seed > 0.8 ? 15 : (seed > 0.4 ? 4 : 2);

            for (let i = 0; i < numObjects; i++) {
                seed = pseudoRandom(seed, i);
                const bx = (pseudoRandom(seed * 10, i) - 0.5) * (CHUNK_SIZE - 20);
                const bz = (pseudoRandom(seed * 20, i) - 0.5) * (CHUNK_SIZE - 20);
                const snapX = Math.round(bx / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;
                const snapZ = Math.round(bz / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;

                let onRoad = false;
                if (roadSet.has(`${snapX},${snapZ}`)) onRoad = true;
                if (!onRoad) {
                    const worldX = chunkX + bx;
                    const worldZ = chunkZ + bz;
                    if (getRoadValue(worldX, worldZ) < ROAD_WIDTH_THRESHOLD + 0.1) onRoad = true;
                }

                if (onRoad) continue;

                let geo, radius, height, width, depth;
                if (seed < 0.3) { geo = buildingGeometries.small; radius = 8; height = 30; width = 10; depth = 10; }
                else if (seed < 0.6) { geo = buildingGeometries.tall; radius = 10; height = 80; width = 15; depth = 15; }
                else { geo = buildingGeometries.wide; radius = 15; height = 25; width = 30; depth = 20; }

                const mat = getBuildingMaterial(seed, isNightMode);
                const mesh = new THREE.Mesh(geo, mat);
                const rot = (pseudoRandom(seed * 30, i) * Math.PI * 4);
                mesh.position.set(bx, geo.parameters.height / 2, bz);
                mesh.rotation.y = rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.matrixAutoUpdate = false;
                mesh.updateMatrix();

                mesh.userData = { isBuilding: true, seed: seed };

                group.add(mesh);
                obstacles.push({ x: chunkX + bx, z: chunkZ + bz, radiusSq: radius * radius, isBuilding: true, rotation: rot, height: height, width: width, depth: depth });
            }



            scene.add(group);
            activeChunks.set(`${cx},${cz}`, { mesh: group, obstacles: obstacles, roads: roadMapPositions });
        }

        // --- Entities ---
        /**
         * Initialize geometries for pedestrian parts.
         */
        function initPedestrianGeometries() {
            pedGeometries.head = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            pedGeometries.body = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            pedGeometries.arm = new THREE.BoxGeometry(0.25, 1.0, 0.25);
            pedGeometries.arm.translate(0, -0.4, 0);
            pedGeometries.leg = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            pedGeometries.leg.translate(0, -0.6, 0);
            pedGeometries.robe = new THREE.BoxGeometry(0.9, 2.4, 0.6);
            pedGeometries.cape = new THREE.BoxGeometry(1.0, 2.2, 0.1);
            pedGeometries.turban = new THREE.BoxGeometry(0.68, 0.35, 0.68);
        }
        /**
         * Generate a random pedestrian data object and add to pool.
         */
        function createPedestrianData() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 200 + 50;
            const pedData = {
                position: new THREE.Vector3(Math.sin(angle) * dist, 2.0, Math.cos(angle) * dist),
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.2),
                rotation: Math.random() * Math.PI * 2,
                animPhase: Math.random() * 100,
                isActive: false, mesh: null,
                colors: { shirt: Math.random() * 0xffffff, pants: Math.random() * 0xffffff, skin: 0xffccaa }
            };
            allPedestrians.push(pedData);
        }
        /**
         * Get or create a material for a specific color hex.
         * @param {number} colorHex 
         * @returns {THREE.Material}
         */
        function getCachedMaterial(colorHex) {
            const hex = Math.floor(colorHex);
            if (!materialCache.has(hex)) materialCache.set(hex, new THREE.MeshStandardMaterial({ color: hex }));
            return materialCache.get(hex);
        }
        /**
         * Build a 3D mesh group for a pedestrian based on its data.
         * @param {Object} data 
         * @returns {THREE.Group}
         */
        function buildPedestrianMesh(data) {
            const group = new THREE.Group();
            const skinMat = getCachedMaterial(data.colors.skin);
            const shirtMat = getCachedMaterial(data.colors.shirt);
            const pantsMat = getCachedMaterial(data.colors.pants);
            const head = new THREE.Mesh(pedGeometries.head, skinMat); head.position.y = 0.9; head.castShadow = true; group.add(head);
            const body = new THREE.Mesh(pedGeometries.body, shirtMat); body.position.y = 0; body.castShadow = true; group.add(body);
            const armL = new THREE.Mesh(pedGeometries.arm, shirtMat); armL.position.set(-0.55, 0.4, 0); armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(pedGeometries.arm, shirtMat); armR.position.set(0.55, 0.4, 0); armR.castShadow = true; group.add(armR);
            const legL = new THREE.Mesh(pedGeometries.leg, pantsMat); legL.position.set(-0.25, -0.6, 0); legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(pedGeometries.leg, pantsMat); legR.position.set(0.25, -0.6, 0); legR.castShadow = true; group.add(legR);

            if (data.isUser) {
                const robeMat = getCachedMaterial(data.colors.robe || 0x000000);
                const robe = new THREE.Mesh(pedGeometries.robe, robeMat);
                robe.position.y = -0.6;
                robe.castShadow = true;
                robe.userData.partGroup = "robe";
                group.add(robe);


                const hatMat = getCachedMaterial(data.colors.hat || 0x555555);
                const turban = new THREE.Mesh(pedGeometries.turban, hatMat);
                turban.position.y = 1.35;
                turban.castShadow = true;
                turban.userData.partGroup = "hat";
                group.add(turban);
            }

            // Tag parts for painting
            head.userData.partGroup = 'skin';
            body.userData.partGroup = 'shirt';
            armL.userData.partGroup = 'shirt';
            armR.userData.partGroup = 'shirt';
            legL.userData.partGroup = 'pants';
            legR.userData.partGroup = 'pants';

            // Assign limbs to userData, preserving existing properties if any
            if (!group.userData) group.userData = {};
            group.userData.limbs = { head, body, armL, armR, legL, legR };
            return group;
        }

        /**
         * Update the material colors of an existing pedestrian mesh from the pool.
         * @param {THREE.Group} mesh 
         * @param {Object} colors 
         */
        function applyPedestrianColors(mesh, colors) {
            const skinMat = getCachedMaterial(colors.skin);
            const shirtMat = getCachedMaterial(colors.shirt);
            const pantsMat = getCachedMaterial(colors.pants);

            if (mesh.userData.limbs) {
                mesh.userData.limbs.head.material = skinMat;
                mesh.userData.limbs.body.material = shirtMat;
                mesh.userData.limbs.armL.material = shirtMat;
                mesh.userData.limbs.armR.material = shirtMat;
                mesh.userData.limbs.legL.material = pantsMat;
                mesh.userData.limbs.legR.material = pantsMat;
            }
        }

        // --- CAR MODELS & HEADLIGHTS ---

        /**
         * Create headlight spotlights and add them to a vehicle group.
         * @param {THREE.Group} group
         * @param {number} xOffset
         * @param {number} y
         * @param {number} z
         * @param {number} [intensity=2]
         */
        function createHeadlights(group, xOffset, y, z, intensity = 2) {
            // NPC lights only visible at night, controlled by toggle
            const spotL = new THREE.SpotLight(0xffffdd, intensity);
            spotL.position.set(-xOffset, y, z);
            spotL.angle = Math.PI / 6;
            spotL.penumbra = 0.3;
            spotL.decay = 1.5;
            spotL.distance = 60;
            spotL.castShadow = false;
            spotL.target.position.set(-xOffset, 0, z + 20);
            spotL.visible = isNightMode;
            spotL.isLight = true;
            group.add(spotL);
            group.add(spotL.target);

            const spotR = new THREE.SpotLight(0xffffdd, intensity);
            spotR.position.set(xOffset, y, z);
            spotR.angle = Math.PI / 6;
            spotR.penumbra = 0.3;
            spotR.decay = 1.5;
            spotR.distance = 60;
            spotR.target.position.set(xOffset, 0, z + 20);
            spotR.visible = isNightMode;
            spotR.isLight = true;
            group.add(spotR);
            group.add(spotR.target);
        }

        // --- Vehicle Abstraction ---
        /**
         * Factory function to create a vehicle mesh.
         * @param {Object} config - Configuration object (type, color, lights, scale)
         * @returns {THREE.Group}
         */
        function createVehicle(config) {
            const type = config.type || 'supercar';
            const bodyColor = config.bodyColor || null; // Use bodyColor
            const spoilerColor = config.spoilerColor || null; // Use spoilerColor
            const addLights = config.addLights !== undefined ? config.addLights : true;
            const scale = config.scale || 1.0;

            let mesh;
            if (type === 'supercar') {
                mesh = buildSupercarMesh(addLights, bodyColor, spoilerColor); // Pass body and spoiler colors
            } else if (type === 'hypercar') {
                mesh = buildHypercarMesh(addLights, bodyColor, spoilerColor); // Pass body and spoiler colors
            } else {
                mesh = buildSupercarMesh(addLights, bodyColor, spoilerColor); // Default to supercar
            }

            if (scale !== 1.0) {
                mesh.scale.set(scale, scale, scale);
            }

            return mesh;
        }

        /**
         * Build a "Supercar" style vehicle mesh.
         * @param {boolean} [addLights=true]
         * @param {number|null} [bodyColor]
         * @param {number|null} [spoilerColor]
         * @returns {THREE.Group}
         */
        function buildSupercarMesh(addLights = true, bodyColor = null, spoilerColor = null) {
            const group = new THREE.Group();

            // Materials
            const currentBodyColor = bodyColor ? bodyColor : vehicleColors.supercar.body;
            const currentSpoilerColor = spoilerColor ? spoilerColor : vehicleColors.supercar.spoiler;

            const bodyMat = new THREE.MeshStandardMaterial({ color: currentBodyColor, roughness: 0.3, metalness: 0.2 });
            const spoilerMat = new THREE.MeshStandardMaterial({ color: currentSpoilerColor, roughness: 0.3, metalness: 0.2 }); // Uses provided spoilerColor
            const secondaryMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.6 }); // Glossy black accents
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x223344, // Dark bluish tint
                roughness: 0.1,
                metalness: 0.7,
                transparent: true,
                opacity: 0.7 // Slightly transparent
            });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.2 });

            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity * 1.5 });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xaaccff, emissive: 0xaaccff, emissiveIntensity: lightIntensity });

            // Main Body (Split into Rear and Hood)
            // Rear Body (Chassis under cabin and rear)
            const mainBodyGeo = new THREE.BoxGeometry(2.1, 0.5, 3.6);
            const mainBody = new THREE.Mesh(mainBodyGeo, bodyMat);
            mainBody.position.set(0, 0.5, -0.5);
            mainBody.userData.partGroup = 'body'; // Mark as body part
            group.add(mainBody);

            // Side Skirts
            const skirtGeo = new THREE.BoxGeometry(0.2, 0.2, 3.0); // Depth, Height, Length
            const skirtL = new THREE.Mesh(skirtGeo, spoilerMat);
            skirtL.position.set(-1.15, 0.15, -0.5); // Positioned to the left side
            skirtL.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(skirtL);

            const skirtR = new THREE.Mesh(skirtGeo, spoilerMat);
            skirtR.position.set(1.15, 0.15, -0.5); // Positioned to the right side
            skirtR.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(skirtR);

            // Hood (Front nose)
            const hoodGeo = new THREE.BoxGeometry(2.1, 0.5, 1.0);
            const hood = new THREE.Mesh(hoodGeo, bodyMat);
            hood.position.set(0, 0.5, 1.8);
            hood.userData.partGroup = 'body'; // Mark as body part
            group.add(hood);

            // Cabin (Teardrop style)
            const cabinGeo = new THREE.BoxGeometry(1.3, 0.4, 2.2);
            const cabin = new THREE.Mesh(cabinGeo, glassMat);
            cabin.position.set(0, 0.9, 0.2);
            cabin.userData = { partType: 'glass', partGroup: 'glass' }; // Mark as glass part
            group.add(cabin);

            // Fenders (Wide arches)
            const fenderGeo = new THREE.BoxGeometry(0.6, 0.65, 1.2);
            const fl = new THREE.Mesh(fenderGeo, bodyMat); fl.position.set(-1.1, 0.525, 1.6); fl.userData.partGroup = 'body'; group.add(fl); // Mark as body part
            const fr = new THREE.Mesh(fenderGeo, bodyMat); fr.position.set(1.1, 0.525, 1.6); fr.userData.partGroup = 'body'; group.add(fr); // Mark as body part

            const rearFenderGeo = new THREE.BoxGeometry(0.7, 0.7, 1.4);
            const rl = new THREE.Mesh(rearFenderGeo, bodyMat); rl.position.set(-1.15, 0.55, -1.4); rl.userData.partGroup = 'body'; group.add(rl); // Mark as body part
            const rr = new THREE.Mesh(rearFenderGeo, bodyMat); rr.position.set(1.15, 0.55, -1.4); rr.userData.partGroup = 'body'; group.add(rr); // Mark as body part

            // Spoiler (Aggressive Wing)
            const wingPillarGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
            const pL = new THREE.Mesh(wingPillarGeo, spoilerMat); pL.position.set(-0.6, 0.9, -2.0); pL.userData.partGroup = 'spoiler'; group.add(pL); // Mark as spoiler part
            const pR = new THREE.Mesh(wingPillarGeo, spoilerMat); pR.position.set(0.6, 0.9, -2.0); pR.userData.partGroup = 'spoiler'; group.add(pR); // Mark as spoiler part

            const wingGeo = new THREE.BoxGeometry(2.8, 0.05, 0.8);
            const wing = new THREE.Mesh(wingGeo, spoilerMat);
            wing.position.set(0, 1.15, -2.1);
            wing.userData.partGroup = 'spoiler'; // Mark as spoiler part
            group.add(wing);

            // Lights
            // Rear light strip (Cyberpunk style)
            const stripGeo = new THREE.BoxGeometry(2.0, 0.1, 0.1);
            const strip = new THREE.Mesh(stripGeo, tailLightMat);
            strip.position.set(0, 0.6, -2.35);
            strip.userData.partGroup = 'light'; // Mark as light
            group.add(strip);

            // Headlights (Angled slits)
            const hlGeo = new THREE.BoxGeometry(0.5, 0.05, 0.2);
            const hlL = new THREE.Mesh(hlGeo, headLightMat); hlL.position.set(-0.9, 0.5, 2.3); hlL.rotation.y = 0.2; hlL.userData.partGroup = 'light'; group.add(hlL); // Mark as light
            const hlR = new THREE.Mesh(hlGeo, headLightMat); hlR.position.set(0.9, 0.5, 2.3); hlR.rotation.y = -0.2; hlR.userData.partGroup = 'light'; group.add(hlR); // Mark as light
            // Wheels
            const wheelGeo = new THREE.BoxGeometry(0.6, 0.8, 0.8); // Using box for style consistency with low poly
            const positions = [
                { x: -1.15, z: 1.6 }, { x: 1.15, z: 1.6 }, // Front
                { x: -1.25, z: -1.4 }, { x: 1.25, z: -1.4 } // Rear (Wider)
            ];

            positions.forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, secondaryMat);
                w.position.set(pos.x, 0.4, pos.z);
                w.userData = { paintable: false };
                group.add(w);

                // Rim detail
                const rim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.5), rimMat);
                rim.position.set(pos.x + (pos.x > 0 ? 0.26 : -0.26), 0.4, pos.z);
                rim.userData = { paintable: false };
                group.add(rim);
            });

            if (addLights) {
                // Cooler blue-ish headlights for the black car
                createHeadlights(group, 0.9, 0.5, 2.4, 12.0);
            }

            return group;
        }

        /**
         * Build a "Hypercar" style vehicle mesh.
         * @param {boolean} [addLights=true] 
         * @param {number|null} [bodyColor] 
         * @param {number|null} [spoilerColor] 
         * @returns {THREE.Group}
         */
        function buildHypercarMesh(addLights = true, bodyColor = null, spoilerColor = null) {
            const group = new THREE.Group();
            const currentBodyColor = bodyColor ? bodyColor : vehicleColors.hypercar.body;
            const currentSpoilerColor = spoilerColor ? spoilerColor : vehicleColors.hypercar.spoiler;
            const bodyMat = new THREE.MeshStandardMaterial({ color: currentBodyColor, roughness: 0.2, metalness: 0.6 });
            const carbonMat = new THREE.MeshStandardMaterial({ color: currentSpoilerColor, roughness: 0.5, metalness: 0.5 }); // Carbon mat for spoiler is now paintable
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x223344, // Dark bluish tint
                roughness: 0.1,
                metalness: 0.7,
                transparent: true,
                opacity: 0.7 // Slightly transparent
            });

            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: lightIntensity });
            const exhaustMat = new THREE.MeshStandardMaterial({ color: 0x8888ff, metalness: 1.0, roughness: 0.2, emissive: 0x2222ff, emissiveIntensity: isNightMode ? 2.0 : 0.5 });

            const chassisGeo = new THREE.BoxGeometry(2.0, 0.5, 4.4);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat); chassis.position.y = 0.5; chassis.userData.partGroup = 'body'; group.add(chassis);
            const cabinGeo = new THREE.BoxGeometry(1.4, 0.5, 2.0);
            const cabin = new THREE.Mesh(cabinGeo, glassMat); cabin.position.set(0, 1.0, 0.2);
            cabin.userData = { partType: 'glass', partGroup: 'glass' };
            group.add(cabin);
            const fenderGeoFront = new THREE.BoxGeometry(0.8, 0.65, 1.2);
            const fenderGeoRear = new THREE.BoxGeometry(0.9, 0.72, 1.4);
            const fl = new THREE.Mesh(fenderGeoFront, bodyMat); fl.position.set(-1.2, 0.525, 1.4); fl.userData.partGroup = 'body'; group.add(fl);
            const fr = new THREE.Mesh(fenderGeoFront, bodyMat); fr.position.set(1.2, 0.525, 1.4); fr.userData.partGroup = 'body'; group.add(fr);
            const rl = new THREE.Mesh(fenderGeoRear, bodyMat); rl.position.set(-1.25, 0.6, -1.2); rl.userData.partGroup = 'body'; group.add(rl);
            const rr = new THREE.Mesh(fenderGeoRear, bodyMat); rr.position.set(1.25, 0.6, -1.2); rr.userData.partGroup = 'body'; group.add(rr);
            const skirtGeo = new THREE.BoxGeometry(0.4, 0.2, 2.0);
            const skirtL = new THREE.Mesh(skirtGeo, carbonMat); skirtL.position.set(-1.1, 0.3, 0.1); skirtL.userData.partGroup = 'spoiler'; group.add(skirtL);
            const skirtR = new THREE.Mesh(skirtGeo, carbonMat); skirtR.position.set(1.1, 0.3, 0.1); skirtR.userData.partGroup = 'spoiler'; group.add(skirtR);
            const wingPillarGeo = new THREE.BoxGeometry(0.2, 0.6, 0.4);
            const wpL = new THREE.Mesh(wingPillarGeo, carbonMat); wpL.position.set(-0.5, 0.8, -1.8); wpL.userData.partGroup = 'spoiler'; group.add(wpL);
            const wpR = new THREE.Mesh(wingPillarGeo, carbonMat); wpR.position.set(0.5, 0.8, -1.8); wpR.userData.partGroup = 'spoiler'; group.add(wpR);
            const wingBladeGeo = new THREE.BoxGeometry(2.6, 0.1, 0.8);
            const wing = new THREE.Mesh(wingBladeGeo, carbonMat); wing.position.set(0, 1.1, -1.9); wing.userData.partGroup = 'spoiler'; group.add(wing);
            const exhaustBoxGeo = new THREE.BoxGeometry(0.6, 0.4, 0.1);
            const exhaustBox = new THREE.Mesh(exhaustBoxGeo, carbonMat); exhaustBox.position.set(0, 0.6, -2.25); group.add(exhaustBox);
            const pipeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            [[-0.15, 0.1], [0.15, 0.1], [-0.15, -0.1], [0.15, -0.1]].forEach(off => {
                const pipe = new THREE.Mesh(pipeGeo, exhaustMat); pipe.position.set(off[0], 0.6 + off[1], -2.31); group.add(pipe);
            });
            const tlGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const tlL = new THREE.Mesh(tlGeo, tailLightMat); tlL.position.set(-1.4, 0.7, -1.9); group.add(tlL);
            const tlR = new THREE.Mesh(tlGeo, tailLightMat); tlR.position.set(1.4, 0.7, -1.9); group.add(tlR);
            const hlGeo = new THREE.BoxGeometry(0.6, 0.1, 0.2);
            const hlL = new THREE.Mesh(hlGeo, headLightMat); hlL.position.set(-1.0, 0.5, 2.0); group.add(hlL);
            const hlR = new THREE.Mesh(hlGeo, headLightMat); hlR.position.set(1.0, 0.5, 2.0); group.add(hlR);

            // Wheels
            const wheelGeo = new THREE.BoxGeometry(0.9, 0.8, 0.8);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });

            const flWheel = new THREE.Mesh(wheelGeo, wheelMat); flWheel.position.set(-1.25, 0.4, 1.4); flWheel.userData = { paintable: false }; group.add(flWheel);
            const frWheel = new THREE.Mesh(wheelGeo, wheelMat); frWheel.position.set(1.25, 0.4, 1.4); frWheel.userData = { paintable: false }; group.add(frWheel);
            const rlWheel = new THREE.Mesh(wheelGeo, wheelMat); rlWheel.position.set(-1.35, 0.45, -1.2); rlWheel.userData = { paintable: false }; group.add(rlWheel);
            const rrWheel = new THREE.Mesh(wheelGeo, wheelMat); rrWheel.position.set(1.35, 0.45, -1.2); rrWheel.userData = { paintable: false }; group.add(rrWheel);

            if (addLights) {
                createHeadlights(group, 1.0, 0.5, 2.0, 10.0);
            }
            return group;
        }

        // --- NPC TRAFFIC SYSTEM ---

        /**
         * Spawn an NPC traffic car at a specific position.
         * @param {number} x 
         * @param {number} y 
         * @param {number} z 
         * @param {boolean} isPositiveLane - Direction of travel (based on road raw map)
         */
        function spawnTrafficCar(x, y, z, isPositiveLane) {
            // Random color
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffaa00, 0xaa00aa, 0xffffff, 0x222222];
            const col = colors[Math.floor(Math.random() * colors.length)];

            let mesh;
            if (trafficPool.length > 0) {
                mesh = trafficPool.pop();
                mesh.visible = true;
                // Update color of existing mesh
                mesh.traverse(child => {
                    if (child.isMesh && (child.userData.partGroup === 'body' || child.userData.partGroup === 'spoiler')) {
                        child.material.color.setHex(col);
                    }
                    // Spoiler usually matches body or default black for traffic? 
                    // createVehicle uses defaults. Let's assume traffic cars have body=spoiler or defaults.
                    // For logic simplicity, just update body.
                });
            } else {
                // Reuse supercar mesh but scaled down slightly
                mesh = createVehicle({
                    type: 'supercar',
                    color: col,
                    addLights: true,
                    scale: 1.6
                });
            }
            mesh.position.set(x, y, z);
            scene.add(mesh);

            trafficVehicles.push({
                mesh: mesh,
                speed: 0.4 + Math.random() * 0.2, // Random speed
                laneDir: isPositiveLane ? 1 : -1, // +1 for positive raw road value, -1 for negative
                velocity: new THREE.Vector3(),
                color: col // Store color for explosion
            });
        }

        /**
         * Update loop for all traffic vehicles (movement, rotation, cleanup).
         * @param {number} time 
         */
        function updateTraffic(time) {
            if (!player) return;
            const pPos = getActivePosition();

            for (let i = trafficVehicles.length - 1; i >= 0; i--) {
                const car = trafficVehicles[i];
                const mesh = car.mesh;

                // 1. Move
                const tangent = getRoadTangent(mesh.position.x, mesh.position.z);

                // If laneDir is -1 (negative raw value side), we inverse the tangent flow
                if (car.laneDir < 0) {
                    tangent.negate();
                }

                car.velocity.copy(tangent).multiplyScalar(car.speed);
                mesh.position.add(car.velocity);

                // 2. Rotate to face velocity
                const angle = Math.atan2(car.velocity.x, car.velocity.z);
                mesh.rotation.y = angle;

                // 3. Keep on ground / simple bounce
                // Use passed time or fallback
                const t = time || performance.now();
                mesh.position.y = PLAYER_BASE_Y + Math.sin(t * 0.02 + i) * 0.03;

                // 4. Culling (Remove if too far)
                const dx = mesh.position.x - pPos.x;
                const dz = mesh.position.z - pPos.z;
                if (dx * dx + dz * dz > CULL_DIST_SQ * 1.5) { // Slightly larger cull dist to prevent pop-in on edges
                    scene.remove(mesh);
                    trafficPool.push(mesh);
                    trafficVehicles.splice(i, 1);
                }
            }
        }

        /**
         * Create the main player object (container for vehicle).
         */
        function createPlayer() {
            player = new THREE.Group();

            // Find a valid spawn point on the road
            let spawnX = 0, spawnZ = 0;
            // Search nearby for a road
            for (let i = 0; i < 5000; i += 10) {
                if (getRoadValue(i, 0) < 0.1) { spawnX = i; break; }
                if (getRoadValue(-i, 0) < 0.1) { spawnX = -i; break; }
                if (getRoadValue(0, i) < 0.1) { spawnZ = i; break; }
                if (getRoadValue(0, -i) < 0.1) { spawnZ = -i; break; }
            }

            player.position.set(spawnX, PLAYER_BASE_Y, spawnZ);
            initialSpawnX = spawnX;
            initialSpawnZ = spawnZ;
            scene.add(player);
            // Default to hypercar
            loadCarModel('hypercar');
            centerCamera(); // Center camera after spawning
        }

        /**
         * Load the 3D model for the player's car into the player group.
         * @param {string} type - 'supercar' or 'hypercar'
         */
        function loadCarModel(type) {
            if (currentCarMesh) {
                player.remove(currentCarMesh);
                // Dispose logic for car would go here if we were generating new geoms constantly,
                // but we are rebuilding small groups. 
            }
            carType = type;
            currentCarMesh = createVehicle({
                type: type,
                color: vehicleColors[type],
                addLights: true,
                scale: 1.8
            });

            if (type === 'supercar') {
                ACCELERATION = 0.1; MAX_SPEED = 3.4;
            } else if (type === 'hypercar') {
                ACCELERATION = 0.1; MAX_SPEED = 3.4;
            }
            currentCarMesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            player.add(currentCarMesh);
            updatePlayerLabel();
        }

        /**
         * Switch between vehicle models (Supercar/Hypercar) and trigger jump animation.
         */
        function toggleCarModel() {
            const newType = (carType === 'supercar') ? 'hypercar' : 'supercar';
            selectCarType(newType);
        }

        /**
         * Handle manual camera movement via mouse.
         * @param {MouseEvent} e 
         */
        function onMouseMoveCam(e) {
            const dx = e.clientX - camLastPos.x;
            const dy = e.clientY - camLastPos.y;
            updateCameraAngle(dx, dy);
            camLastPos = { x: e.clientX, y: e.clientY };
        }

        /**
         * Handle global mouse down events (game interactions).
         * @param {MouseEvent} e 
         */
        function onMouseDown(e) {
            // Check if clicking inside settings modal or any active modal
            if (settingsModal.classList.contains('active')) {
                const rect = settingsModal.querySelector('.modal-content').getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    return; // Ignore clicks inside modal
                }
            } else if (vehicleModalOpen || pedestrianModalOpen) {
                return; // Usually these have their own overlay handling, but safety first
            }

            // Check miniature hold/click




            if (checkVehicleTap(e.clientX, e.clientY)) {
                handleVehicleTap();
                return;
            }

            if (e.target === timeBtn || e.target === shareBtn) return;
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            if (e.clientX < window.innerWidth / 2) {
            } else {
                isManualCamera = true;
                manualCamTimer = 120;
                camLastPos = { x: e.clientX, y: e.clientY };
                document.addEventListener('mousemove', onMouseMoveCam);
                document.addEventListener('mouseup', () => { document.removeEventListener('mousemove', onMouseMoveCam); });
            }
        }

        /**
         * Handle global touch start events (joystick, interactions).
         * @param {TouchEvent} e 
         */
        function onTouchStart(e) {
            // If share modal is open and the touch is inside the modal content,
            // allow default behavior so clicks/taps work as expected.
            if (shareModal.classList.contains('active')) {
                if (e.target === shareModal) {
                    // Tapping on backdrop closes the modal
                    closeShareModal();
                    return;
                }
                if (e.target.closest && e.target.closest('#share-modal-content')) {
                    return;
                }
            }
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];


                if (checkVehicleTap(t.clientX, t.clientY)) {
                    handleVehicleTap();
                    continue;
                }
                if (t.target === timeBtn) {
                    toggleDayNight();
                    continue;
                }
                if (t.target === shareBtn) {
                    openShareModal();
                    continue;
                }

                // Check for modal interactions to prevent pass-through
                if (settingsModal.classList.contains('active') || vehicleModalOpen || pedestrianModalOpen || shareModal.classList.contains('active')) {
                    continue; // Skip game logic touches if modals are open
                }

                const dx = t.clientX - zoneCenter.x;
                const dy = t.clientY - zoneCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (moveTouchId === null && dist < joystickRadius * 1.5) {
                    moveTouchId = t.identifier;
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (camTouchId === null) {
                    camTouchId = t.identifier;
                    isManualCamera = true;
                    manualCamTimer = 120;
                    camLastPos = { x: t.clientX, y: t.clientY };
                }
            }
        }

        /**
         * Handle global touch move events (joystick drag).
         * @param {TouchEvent} e 
         */
        function onTouchMove(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];
                if (t.identifier === moveTouchId) {
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (t.identifier === camTouchId) {
                    const dx = t.clientX - camLastPos.x;
                    const dy = t.clientY - camLastPos.y;
                    updateCameraAngle(dx, dy);
                    camLastPos = { x: t.clientX, y: t.clientY };
                    isManualCamera = true;
                    manualCamTimer = 120;
                }
            }
        }

        /**
         * Handle global touch end events.
         * @param {TouchEvent} e 
         */
        function onTouchEnd(e) {
            e.preventDefault();

            // Check if we are releasing the miniature button
            if (isHolding || holdTimer) {
                clearTimeout(holdTimer);
                if (isHolding) {
                    toggleCarModel();
                    isHolding = false;
                }
                // If we were holding, we don't want to process other touch ends potentially?
                // Actually, we should process others just in case.
            }

            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === moveTouchId) {
                    moveTouchId = null;
                    updateMoveInputFromKeys();
                }
                if (touches[i].identifier === camTouchId) camTouchId = null;
            }
        }

        /**
         * Update the virtual joystick UI and input values.
         * @param {number} clientX 
         * @param {number} clientY 
         * @param {{x:number, y:number}} center - Joystick center coordinates
         */
        function updateJoystick(clientX, clientY, center) {
            let dx = clientX - center.x;
            let dy = clientY - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > joystickRadius) {
                const ratio = joystickRadius / distance;
                dx *= ratio;
                dy *= ratio;
            }
            stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            moveInput.x = dx / joystickRadius;
            moveInput.y = dy / joystickRadius;
        }

        /**
         * Update camera angles based on input delta.
         * @param {number} dx 
         * @param {number} dy 
         */
        function updateCameraAngle(dx, dy) {
            const sensitivity = 0.005;
            cameraAngle -= dx * sensitivity;
            cameraVerticalAngle -= dy * sensitivity;
            cameraVerticalAngle = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraVerticalAngle));
        }

        /**
         * Reset camera to follow behind the player.
         */
        function centerCamera() {
            if (!player) return;
            cameraAngle = player.rotation.y + Math.PI;
            cameraVerticalAngle = 0.5;
            isManualCamera = false;
            manualCamTimer = 0;
        }

        /**
         * Update the on-screen arrow pointing to the car's heading relative to camera.
         */
        function updateHeadingIndicator() {
            if (!player) return;
            const carRot = player.rotation.y;
            const camRot = cameraAngle;
            const diff = carRot - camRot;
            const screenX = Math.sin(diff);
            const screenY = -Math.cos(diff);
            const angleRad = Math.atan2(screenX, screenY);
            const angleDeg = angleRad * (180 / Math.PI);
            headingArrow.style.transform = `rotate(${angleDeg}deg)`;
        }

        /**
         * Calculate the shortest distance between two angles (in radians).
         * @param {number} a 
         * @param {number} b 
         * @returns {number} Angle difference
         */
        function shortestAngleDist(a, b) {
            let diff = b - a;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }

        /**
         * Main physics update loop for player and collisions.
         */
        function updatePhysics() {
            if (isGameOver) return;

            if (controlMode === 'pedestrian' && userPedestrian) {
                // Pedestrian Control Logic
                const PED_SPEED = 0.25;
                const turnSpeed = 0.15;

                // Input vector from joystick/keys
                const dx = moveInput.x;
                const dy = moveInput.y; // -1 is up (forward) usually in 2D screen coords, but let's check input logic
                // In updateMoveInputFromKeys: 'w' (up) -> dy = -1. 's' (down) -> dy = 1.
                // In joystick: up -> dy negative.

                // Movement relative to camera
                // Camera looks at player.
                // We want "Up" to be "Away from camera".
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                camDir.y = 0;
                camDir.normalize();

                const camRight = new THREE.Vector3();
                camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0));

                // dy is negative for UP/Forward input.
                // dx is positive for Right input.

                const moveDir = new THREE.Vector3();
                moveDir.addScaledVector(camDir, -dy); // -(-1) = +1 (Forward along camera view)
                moveDir.addScaledVector(camRight, dx);

                if (moveDir.lengthSq() > 0.01) {
                    moveDir.normalize();
                    userPedestrian.position.addScaledVector(moveDir, PED_SPEED);

                    // Only rotate to face movement if not moving backwards relative to camera
                    if (dy <= 0.2) {
                        const targetRot = Math.atan2(moveDir.x, moveDir.z);
                        let rotDiff = shortestAngleDist(userPedestrian.rotation, targetRot);
                        userPedestrian.rotation += rotDiff * turnSpeed;
                    }

                    // Animation: reverse if backing up
                    const animSpeed = dy > 0.2 ? -0.4 : 0.4;
                    userPedestrian.animPhase += animSpeed;
                    const swing = Math.sin(userPedestrian.animPhase) * 0.6;
                    userPedestrian.mesh.userData.limbs.legL.rotation.x = swing;
                    userPedestrian.mesh.userData.limbs.legR.rotation.x = -swing;
                    userPedestrian.mesh.userData.limbs.armL.rotation.x = -swing;
                    userPedestrian.mesh.userData.limbs.armR.rotation.x = swing;
                } else {
                    // Idle pose
                    userPedestrian.mesh.userData.limbs.legL.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.legR.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.armL.rotation.x = 0;
                    userPedestrian.mesh.userData.limbs.armR.rotation.x = 0;
                }

                userPedestrian.mesh.position.copy(userPedestrian.position);
                userPedestrian.mesh.rotation.y = userPedestrian.rotation;

                // Keep player (car) updating slightly for collisions logic if we wanted, 
                // but for now just stop it.
                velocity.set(0, 0, 0);
                return;
            }

            let appliedFriction = FRICTION;

            if (Math.abs(moveInput.x) > 0.1) {
                // Scaling turn speed with speed for realism (slower turn at high speeds? or low speeds?)
                // Arcade style: constant turn usually feels better, but let's keep it simple.
                const turnFactor = carType === 'hypercar' ? 0.05 : 0.04;
                player.rotation.y -= moveInput.x * turnFactor;
                if (Math.abs(moveInput.x) > 0.85 && Math.random() < 0.25) emitWheelSmoke();
            }
            if (Math.abs(moveInput.y) > 0.1) {
                const throttle = -moveInput.y;
                const rotation = player.rotation.y;

                // Detect Braking: Moving forward but input is backward (or vice versa)
                // We project velocity onto the car's forward vector
                const vx = velocity.x;
                const vz = velocity.z;
                const forwardX = Math.sin(rotation);
                const forwardZ = Math.cos(rotation);
                const dot = vx * forwardX + vz * forwardZ;

                // If moving reasonably fast and input opposes movement
                if ((dot > 0.5 && throttle < -0.1) || (dot < -0.5 && throttle > 0.1)) {
                    appliedFriction = BRAKING_FRICTION;
                    // Add red brake light effect? (Optional visual polish)
                }

                const accelX = Math.sin(rotation) * throttle * ACCELERATION;
                const accelZ = Math.cos(rotation) * throttle * ACCELERATION;
                velocity.x += accelX;
                velocity.z += accelZ;
            }

            velocity.x *= appliedFriction;
            velocity.z *= appliedFriction;
            velocity.y -= GRAVITY;

            const hSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
            if (hSpeed > MAX_SPEED) {
                const ratio = MAX_SPEED / hSpeed;
                velocity.x *= ratio;
                velocity.z *= ratio;
            }
            player.position.add(velocity);

            if (player.position.y < PLAYER_BASE_Y) {
                player.position.y = PLAYER_BASE_Y;
                velocity.y = 0;
                isAirborne = false;
            } else {
                isAirborne = true;
            }

            const pRadiusSq = 4.0;

            // --- Building Collisions ---
            for (const chunk of activeChunks.values()) {
                if (!chunk.obstacles) continue;
                for (let i = 0; i < chunk.obstacles.length; i++) {
                    const obs = chunk.obstacles[i];
                    const dx = player.position.x - obs.x;
                    const dz = player.position.z - obs.z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < obs.radiusSq + pRadiusSq && player.position.y < obs.height) {
                        explode(player.position, 0xff4400);
                        explode(player.position, 0xffee00);
                        triggerGameOver();
                        return;
                    }
                }
            }

            // --- Traffic Collisions ---
            const trafficCollisionDistSq = 12.0; // Approx 3.5^2
            for (let i = 0; i < trafficVehicles.length; i++) {
                const npc = trafficVehicles[i];
                const dx = player.position.x - npc.mesh.position.x;
                const dz = player.position.z - npc.mesh.position.z;
                const distSq = dx * dx + dz * dz;

                if (distSq < trafficCollisionDistSq) {
                    explode(player.position, 0xff4400);
                    explode(npc.mesh.position, npc.color); // Use NPC color
                    npc.mesh.visible = false;
                    triggerGameOver();
                    return;
                }
            }
        }

        /**
         * Trigger the Game Over state and UI.
         */
        function triggerGameOver() {
            isGameOver = true;
            player.visible = false;
            velocity.set(0, 0, 0);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }

            // Show Game Over Modal
            const modal = document.getElementById('game-over-modal');
            const scoreText = document.getElementById('go-top-score');
            if (modal && scoreText) {
                scoreText.innerText = "Top Score: " + highScore;
                modal.classList.add('active');
            }

            // Hide instructions temporarily if needed
            const instr = document.querySelector('.instructions');
            if (instr) instr.style.opacity = 0;

            setTimeout(() => resetGame(), 2000);
        }

        /**
         * Reset the game state to start a new run.
         */
        function resetGame() {
            isGameOver = false;

            // Ensure we return to vehicle mode
            if (controlMode === 'pedestrian') {
                if (userPedestrian && userPedestrian.mesh) {
                    scene.remove(userPedestrian.mesh);
                }
                userPedestrian = null;
                controlMode = 'vehicle';
            }

            player.visible = true;
            player.position.set(initialSpawnX, PLAYER_BASE_Y, initialSpawnZ);
            player.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0);
            moveInput = { x: 0, y: 0 };
            score = 0;
            scoreElement.innerText = "Score: 0";
            centerCamera();

            // Force chunk update just in case
            lastChunkUpdatePos.set(99999, 99999, 99999);

            // Hide Game Over Modal
            const modal = document.getElementById('game-over-modal');
            if (modal) modal.classList.remove('active');

            // Clear traffic
            trafficVehicles.forEach(c => {
                scene.remove(c.mesh);
                trafficPool.push(c.mesh);
            });
            trafficVehicles.length = 0;

            const instr = document.querySelector('.instructions');
            if (instr) {
                // Restore instructions
                instr.innerHTML = isNightMode ? "Night Run<br>Left Stick: Drive" : "Day Run<br>Left Stick: Drive";
                instr.style.opacity = 1;
                instr.style.animation = 'none';
                instr.offsetHeight; // Trigger reflow
                instr.style.animation = 'fadeOut 5s forwards';
                instr.style.animationDelay = '2s';
            }
        }

        /**
         * Update pedestrian positions and animation state.
         */
        function updatePedestrians() {
            if (isGameOver) return;
            const time = Date.now() * 0.005;
            const playerPos = player.position;
            const SPAWN_RANGE = 250;
            activeObstacles.length = 0;

            // Reusable loop vars to reduce GC
            let ped, dx, dz, distSq, phase, swing;

            for (let i = 0; i < allPedestrians.length; i++) {
                ped = allPedestrians[i];
                if (!ped.isStationary) {
                    ped.position.add(ped.velocity);
                }

                // Wrap around logic
                if (ped.position.x > playerPos.x + SPAWN_RANGE) ped.position.x -= SPAWN_RANGE * 2;
                if (ped.position.x < playerPos.x - SPAWN_RANGE) ped.position.x += SPAWN_RANGE * 2;
                if (ped.position.z > playerPos.z + SPAWN_RANGE) ped.position.z -= SPAWN_RANGE * 2;
                if (ped.position.z < playerPos.z - SPAWN_RANGE) ped.position.z += SPAWN_RANGE * 2;

                dx = ped.position.x - playerPos.x;
                dz = ped.position.z - playerPos.z;
                distSq = dx * dx + dz * dz;

                if (distSq < CULL_DIST_SQ) {
                    if (!ped.mesh) {
                        // Get from pool or create new
                        if (pedestrianPool.length > 0) {
                            ped.mesh = pedestrianPool.pop();
                            ped.mesh.visible = true;
                            // Apply colors to reused mesh
                            applyPedestrianColors(ped.mesh, ped.colors);
                        } else {
                            ped.mesh = buildPedestrianMesh(ped);
                        }
                    }
                    if (!ped.isActive) {
                        scene.add(ped.mesh);
                        ped.isActive = true;
                    }
                    ped.mesh.position.copy(ped.position);
                    ped.mesh.rotation.y = ped.rotation;

                    // Simple animation
                    if (!ped.isStationary) {
                        phase = time + ped.animPhase;
                        swing = Math.sin(phase) * 0.6;
                        ped.mesh.userData.limbs.legL.rotation.x = swing;
                        ped.mesh.userData.limbs.legR.rotation.x = -swing;
                        ped.mesh.userData.limbs.armL.rotation.x = -swing;
                        ped.mesh.userData.limbs.armR.rotation.x = swing;
                    } else {
                        ped.mesh.userData.limbs.legL.rotation.x = 0;
                        ped.mesh.userData.limbs.legR.rotation.x = 0;
                        ped.mesh.userData.limbs.armL.rotation.x = 0;
                        ped.mesh.userData.limbs.armR.rotation.x = 0;
                    }

                    activeObstacles.push(ped);
                } else {
                    if (ped.isActive) {
                        scene.remove(ped.mesh);
                        ped.isActive = false;
                        // Return to pool
                        if (ped.mesh) {
                            pedestrianPool.push(ped.mesh);
                            ped.mesh = null;
                        }
                    }
                }
            }
        }

        /**
         * Check and handle collisions between player and active pedestrians.
         */
        function checkCollisions() {
            if (isGameOver) return;
            const collisionThresholdSq = 16.0;
            for (let i = activeObstacles.length - 1; i >= 0; i--) {
                const pedData = activeObstacles[i];
                const dx = player.position.x - pedData.position.x;
                const dz = player.position.z - pedData.position.z;
                const distSq = dx * dx + dz * dz;
                if (distSq < collisionThresholdSq) {
                    explode(pedData.position);
                    spawnVoxelScore(pedData.position);
                    pedData.position.x = player.position.x + (Math.random() - 0.5) * 300;
                    pedData.position.z = player.position.z + (Math.random() - 0.5) * 300;
                    if (pedData.isActive) {
                        scene.remove(pedData.mesh);
                        pedData.isActive = false;
                    }
                    score++;
                    scoreElement.innerText = "Score: " + score;
                }
            }
        }

        /**
         * Spawn smoke particles for drifting wheels.
         */
        function emitWheelSmoke() {
            if (!player) return;
            let wheelOffsets = [];
            if (carType === 'supercar') {
                wheelOffsets = [{ x: -1.2, z: 1.6 }, { x: 1.2, z: 1.6 }, { x: -1.25, z: -1.4 }, { x: 1.25, z: -1.4 }];
            } else {
                wheelOffsets = [{ x: -1.32, z: 1.4 }, { x: 1.32, z: 1.4 }, { x: -1.38, z: -1.2 }, { x: 1.38, z: -1.2 }];
            }
            const carRot = player.rotation.y;
            const cos = Math.cos(carRot);
            const sin = Math.sin(carRot);
            wheelOffsets.forEach(offset => {
                const rx = offset.x * cos + offset.z * sin;
                const rz = -offset.x * sin + offset.z * cos;
                const pos = new THREE.Vector3(player.position.x + rx, player.position.y + 0.2, player.position.z + rz);
                spawnSmokeParticle(pos); // Reduced to 1 particle per wheel for speed
            });
        }

        /**
         * Get or create a cached material for debris particles.
         * @param {number} color 
         * @returns {THREE.MeshBasicMaterial}
         */
        function getDebrisMaterial(color) {
            if (!debrisMaterialCache.has(color)) {
                debrisMaterialCache.set(color, new THREE.MeshBasicMaterial({ color: color }));
            }
            return debrisMaterialCache.get(color);
        }

        /**
         * Retrieve a particle mesh from the object pool if available.
         * @returns {THREE.Mesh|null}
         */
        function getParticleFromPool() {
            if (particlePool.length > 0) {
                return particlePool.pop();
            }
            return null; // Pool empty, create new or skip
        }

        /**
         * Spawn a smoke particle at the given position.
         * @param {THREE.Vector3} pos 
         */
        function spawnSmokeParticle(pos) {
            let p = getParticleFromPool();
            if (!p) {
                // Create new if pool empty
                const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.4 });
                p = new THREE.Mesh(smokeBaseGeometry, mat);
            } else {
                // Reset existing
                p.geometry = smokeBaseGeometry;
                // For smoke we might want a fresh material or reuse one? 
                // Smoke fades out, so it modifies opacity. Cloning material is safer or handling it carefully.
                // For simplicity, let's reuse a standard smoke material but we need to reset opacity.
                // Actually, if we share materials, fading one fades all.
                // So each smoke particle needs its own material clone or instance.
                // Check if we can reuse the material. 
                // We can reuse if it is a dedicated smoke material (indicated by previous usage as smoke).
                // Debris materials are shared and opaque, so we cannot reuse them for smoke.
                if (p.userData && p.userData.type === 'smoke' && p.material && p.material.isMeshBasicMaterial) {
                    p.material.opacity = 0.4;
                    p.material.color.setHex(0xdddddd);
                } else {
                    p.material = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.4 });
                }
            }

            p.scale.setScalar(Math.random() * 0.4 + 0.2);
            p.position.copy(pos);
            p.position.x += (Math.random() - 0.5) * 0.5;
            p.position.z += (Math.random() - 0.5) * 0.5;
            p.rotation.set(0, 0, 0);

            p.userData = {
                type: 'smoke', life: 1.0,
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.05, 0.05 + Math.random() * 0.05, (Math.random() - 0.5) * 0.05)
            };

            scene.add(p);
            particles.push(p);
        }

        /**
         * Trigger an explosion effect with debris.
         * @param {THREE.Vector3} pos 
         * @param {number} [color=0xFF0000] 
         */
        function explode(pos, color = 0xFF0000) {
            const mat = getDebrisMaterial(color);
            const debrisCount = 3; // Unified for mobile and desktop

            for (let k = 0; k < debrisCount; k++) {
                let p = getParticleFromPool();
                if (!p) {
                    p = new THREE.Mesh(debrisGeometry, mat);
                } else {
                    p.geometry = debrisGeometry;
                    p.material = mat;
                }

                p.scale.set(1, 1, 1);
                p.position.copy(pos);
                p.position.y += 1.5;
                p.rotation.set(0, 0, 0);

                p.userData = {
                    type: 'debris', life: 1.0,
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 1.0, Math.random() * 1.0 + 0.2, (Math.random() - 0.5) * 1.0)
                };
                scene.add(p);
                particles.push(p);
            }
        }

        /**
         * Initialize the snow particle system using a custom shader.
         */
        function createSnow() {
            const positions = [];
            const velocities = [];

            // Spawn locally around (0,0,0)
            for (let i = 0; i < snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * snowRange,
                    Math.random() * 60 - 20, // Height variation
                    (Math.random() - 0.5) * snowRange
                );
                velocities.push(
                    (Math.random() - 0.5) * 2.0, // x drift (increased for shader visual)
                    -Math.random() * 5.0 - 2.0, // y fall speed (needs to be faster in this math model)
                    (Math.random() - 0.5) * 2.0  // z drift
                );
            }

            snowGeo = new THREE.BufferGeometry();
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            snowGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const snowVertexShader = `
                uniform float uTime;
                uniform vec3 uPlayerPos;
                uniform vec3 uRange;
                
                attribute vec3 velocity;
                
                void main() {
                    // 1. Simulate continuous movement based on time
                    vec3 movedPos = position + velocity * uTime;
                    
                    // 2. Relative position to player
                    vec3 relPos = movedPos - uPlayerPos;
                    
                    // 3. Wrap around (Infinite box)
                    vec3 halfRange = uRange * 0.5;
                    vec3 wrapped = mod(relPos + halfRange, uRange);
                    vec3 localPos = wrapped - halfRange;
                    
                    // 4. Final world position
                    vec3 finalPos = uPlayerPos + localPos;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    
                    // Size attenuation
                    gl_PointSize = 120.0 / -mvPosition.z; 
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const snowFragmentShader = `
                void main() {
                    // Simple circular particle
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if(length(coord) > 0.5) discard;
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.7);
                }
            `;

            const snowMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPlayerPos: { value: new THREE.Vector3() },
                    uRange: { value: new THREE.Vector3(snowRange, 80, snowRange) }
                },
                vertexShader: snowVertexShader,
                fragmentShader: snowFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            // We do NOT set snowSystem.position anymore, the shader handles world placement.
            // But Three.js frustum culling relies on bounding sphere.
            // Since particles can be anywhere around player, we must ensure it's not culled.
            snowSystem.frustumCulled = false;

            scene.add(snowSystem);
        }

        /**
         * Update the snow system uniforms (time, player position).
         */
        function updateSnow() {
            if (!player || !snowSystem) return;

            // Update Uniforms
            snowSystem.material.uniforms.uPlayerPos.value.copy(getActivePosition());
            // Use globalFrame or a time accumulator. 
            // frameCount resets every second, so use performance.now
            snowSystem.material.uniforms.uTime.value = performance.now() * 0.001;
        }

        /**
         * Update physics and lifecycle of all active particles (smoke, debris).
         */
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'smoke') {
                    p.rotation.x += 0.05; p.rotation.y += 0.05; p.scale.addScalar(0.04); p.userData.life -= 0.025;
                    if (p.material.opacity > 0) p.material.opacity = p.userData.life * 0.4;
                } else {
                    p.userData.velocity.y -= 0.03; p.rotation.x += 0.1; p.rotation.y += 0.1;
                    if (p.position.y < 0) { p.userData.velocity.y *= -0.5; p.position.y = 0; }
                    p.userData.life -= 0.05; p.scale.setScalar(p.userData.life);
                }
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    // Do NOT dispose geometry/material here as we recycle or use cached ones
                    // Reset heavy properties if needed, but mostly just push to pool
                    particles.splice(i, 1);
                    if (particlePool.length < 100) { // Limit pool size
                        particlePool.push(p);
                    }
                }
            }
        }

        /**
         * Spawn floating +1 voxel text for score.
         * @param {THREE.Vector3} pos 
         */
        function spawnVoxelScore(pos) {
            const group = new THREE.Group();

            // Construct "+1" out of voxels
            // Offsets for "+"
            const plusOffsets = [
                { x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: -1, y: 0 }
            ];
            // Offsets for "1" (shifted right by ~3 units)
            const oneOffsets = [
                { x: 3, y: 1 }, { x: 3, y: 0 }, { x: 3, y: -1 }, { x: 2.2, y: 0.8 }
            ];

            const allOffsets = [...plusOffsets, ...oneOffsets];

            allOffsets.forEach(off => {
                const mesh = new THREE.Mesh(voxelScoreGeometry, voxelScoreMaterial);
                mesh.position.set(off.x * 0.5, off.y * 0.5, 0); // Scale spacing by voxel size
                group.add(mesh);
            });

            group.position.copy(pos);
            group.position.y += 3.0;
            // Face camera roughly or just face same as car?
            // Let's face the camera initially
            group.lookAt(camera.position);
            // But we want it upright, lookAt might tilt x/z. 
            // Simple billboarding Y rotation:
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            const angle = Math.atan2(camPos.x - pos.x, camPos.z - pos.z);
            group.rotation.set(0, angle, 0);

            scene.add(group);

            const dx = pos.x - player.position.x;
            const dz = pos.z - player.position.z;
            const length = Math.sqrt(dx * dx + dz * dz) || 1;

            const velocity = new THREE.Vector3(dx / length * 0.3, 0.4, dz / length * 0.3);

            floatingTexts.push({
                type: 'voxel',
                mesh: group,
                velocity: velocity,
                life: 1.0
            });
        }

        /**
         * Update physics/animation of floating text elements.
         */
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.mesh.position.add(ft.velocity);
                ft.velocity.y -= 0.015; // Gravity

                ft.life -= 0.015;

                // Scale out animation
                const scale = Math.max(0, ft.life);
                ft.mesh.scale.setScalar(scale);

                if (ft.life <= 0) {
                    scene.remove(ft.mesh);
                    // Geometries are shared, do not dispose
                    floatingTexts.splice(i, 1);
                }
            }
        }

        /**
         * Update the main camera position to follow the target (player or pedestrian).
         */
        function updateCamera() {
            let targetObj = player;
            if (controlMode === 'pedestrian' && userPedestrian) {
                targetObj = userPedestrian; // Use object with .position and .rotation (if we want camera to rotate with ped)
                // Pedestrian rotation might jitter, maybe keep camera angle independent or smooth follow?
            }

            if (isManualCamera) {
                manualCamTimer--;
                if (manualCamTimer <= 0) isManualCamera = false;
            } else {
                if (controlMode === 'vehicle' && velocity.length() > 0.1) {
                    const targetAngle = player.rotation.y + Math.PI;
                    const dist = shortestAngleDist(cameraAngle, targetAngle);
                    cameraAngle += dist * 0.05;
                    const targetPitch = 0.5;
                    cameraVerticalAngle += (targetPitch - cameraVerticalAngle) * 0.02;
                } else if (controlMode === 'pedestrian' && userPedestrian) {
                    // Only auto-align if NOT moving backwards
                    if (moveInput.y <= 0.2) {
                        const targetAngle = userPedestrian.rotation + Math.PI;
                        const dist = shortestAngleDist(cameraAngle, targetAngle);
                        cameraAngle += dist * 0.1; // Slightly faster follow for pedestrian
                    }
                    const targetPitch = 0.4; // Lower pitch for pedestrian
                    cameraVerticalAngle += (targetPitch - cameraVerticalAngle) * 0.02;
                }
            }
            const hDist = CAMERA_DIST * Math.cos(cameraVerticalAngle);
            const vDist = CAMERA_DIST * Math.sin(cameraVerticalAngle);
            const offsetX = hDist * Math.sin(cameraAngle);
            const offsetZ = hDist * Math.cos(cameraAngle);
            const targetPos = new THREE.Vector3(
                targetObj.position.x + offsetX,
                targetObj.position.y + vDist,
                targetObj.position.z + offsetZ
            );
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(targetObj.position);
        }

        /**
         * Calculate and display FPS.
         */
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsElement.innerText = "FPS: " + frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        /**
         * Main animation loop.
         */
        function animate() {
            requestAnimationFrame(animate);
            updateFPS();
            globalFrame++;
            const nowTime = performance.now();

            if (player && !vehicleModalOpen && !pedestrianModalOpen) {
                updatePhysics();
                if (globalFrame % 15 === 0) updateChunks();
                // Mobile optimization: skip frames for heavy operations
                if (globalFrame % PEDESTRIAN_UPDATE_INTERVAL === 0) updatePedestrians();
                if (globalFrame % COLLISION_CHECK_INTERVAL === 0) checkCollisions();
                if (globalFrame % PARTICLE_UPDATE_INTERVAL === 0) updateParticles();
                updateFloatingTexts();
                updateSnow();
                updateCamera();
                updateHeadingIndicator();
                if (globalFrame % TRAFFIC_UPDATE_INTERVAL === 0) updateTraffic(nowTime); // Pass time

                // Multiplayer Updates
                if (socket && player) {
                    if (globalFrame % 3 === 0) {
                        const activePos = getActivePosition();
                        const activeRot = controlMode === 'pedestrian' && userPedestrian ? userPedestrian.rotation : player.rotation.y;

                        let vehicleData = null;
                        if (controlMode === 'pedestrian') {
                            vehicleData = {
                                x: player.position.x,
                                y: player.position.y,
                                z: player.position.z,
                                rotation: player.rotation.y,
                                type: carType
                            };
                        }

                        socket.emit('playerMovement', {
                            x: activePos.x,
                            y: activePos.y,
                            z: activePos.z,
                            rotation: activeRot,
                            vehicleType: carType,
                            isPedestrian: controlMode === 'pedestrian',
                            vehicleData: vehicleData
                        });
                    }
                }
                updateRemotePlayers();

                const activePos = getActivePosition();
                if (sunLight && activePos.distanceToSquared(lastLightUpdatePos) > 1600) { // 40^2 = 1600
                    lastLightUpdatePos.copy(activePos);
                    sunLight.position.set(activePos.x + 50, 100, activePos.z + 50);
                    sunLight.target.position.copy(activePos);
                    sunLight.target.updateMatrixWorld();
                }
                if (!isAirborne) {
                    const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                    if (speed > 0.01) {
                        const bounceFreq = carType === 'hypercar' ? 0.03 : 0.015;
                        const bounceAmp = carType === 'hypercar' ? 0.02 : 0.05;
                        player.position.y = PLAYER_BASE_Y + Math.sin(nowTime * bounceFreq) * bounceAmp;
                    }
                }
            }
            renderer.clear();
            renderer.render(scene, camera);
            if (miniatureGroupSuper) miniatureGroupSuper.rotation.y += 0.02;
            if (miniatureGroupHyper) miniatureGroupHyper.rotation.y += 0.02;

            if (settingsModal.classList.contains('active')) {
                if (settingsMiniatureRendererSuper) settingsMiniatureRendererSuper.render(settingsMiniatureSceneSuper, settingsMiniatureCameraSuper);
                if (settingsMiniatureRendererHyper) settingsMiniatureRendererHyper.render(settingsMiniatureSceneHyper, settingsMiniatureCameraHyper);
            }

            if (vehicleModalOpen) {
                // if (modalCarGroup) modalCarGroup.rotation.y += 0.01; // Removed automatic rotation
                // Render modal scene on top (using separate renderer)
                modalRenderer.render(modalScene, modalCamera);
            }

            if (pedestrianModalOpen) {
                pedModalRenderer.render(pedModalScene, pedModalCamera);
            }
        }

        /**
         * Update movement vector based on currently pressed keys.
         */
        function updateMoveInputFromKeys() {
            let dx = 0;
            let dy = 0;
            if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= 1;
            if (keysPressed['s'] || keysPressed['ArrowDown']) dy += 1;
            if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= 1;
            if (keysPressed['d'] || keysPressed['ArrowRight']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                // Normalize for consistent speed diagonally
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
            }

            moveInput.x = dx;
            moveInput.y = dy;

            // Visual feedback on joystick
            const joyX = dx * joystickRadius;
            const joyY = dy * joystickRadius;
            if (stickKnob) stickKnob.style.transform = `translate(calc(-50% + ${joyX}px), calc(-50% + ${joyY}px))`;
        }

        /**
         * Handle window resize events to update camera aspect ratios and renderer size.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            // uiCamera removed
            renderer.setSize(window.innerWidth, window.innerHeight);

            if (vehicleModalOpen && modalRenderer) {
                const width = vehicleModal.clientWidth;
                const height = vehicleModal.clientHeight;
                modalRenderer.setSize(width, height, false);
                modalCamera.aspect = width / height;
                modalCamera.updateProjectionMatrix();
            }

            if (pedestrianModalOpen && pedModalRenderer) {
                const width = pedestrianModal.clientWidth;
                const height = pedestrianModal.clientHeight;
                pedModalRenderer.setSize(width, height, false);
                pedModalCamera.aspect = width / height;
                pedModalCamera.updateProjectionMatrix();
            }
        }

        // --- Multiplayer Functions ---
        function initSocket() {
            // Updated to use local LAN IP or custom user IP
            let serverIP = localStorage.getItem('serverIP');
            if (!serverIP) {
                serverIP = '172.16.1.218'; // Default
            }

            let connectionUrl = serverIP;
            // If it doesn't start with http/https, add http by default.
            if (!connectionUrl.startsWith('http')) {
                connectionUrl = 'http://' + connectionUrl;
            }
            // If no port is specified (no colon followed by digits at end), add default :3000 for http
            if (!/:\d+$/.test(connectionUrl) && !connectionUrl.startsWith('https')) {
                connectionUrl += ':3000';
            }

            // Mixed Content Warning
            if (location.protocol === 'https:' && connectionUrl.startsWith('http:')) {
                console.warn("Mixed Content Warning: Connecting to HTTP server from HTTPS page.");
                // We won't alert immediately to avoid annoying the user if they have a workaround,
                // but we will show it if connection fails.
            }

            console.log("Attempting to connect to:", connectionUrl);
            socket = io(connectionUrl);

            const joinBtn = document.getElementById('settings-join-server-btn');
            const originalBtnText = joinBtn ? joinBtn.innerText : 'Join Server';

            if (joinBtn) {
                joinBtn.innerText = `Connecting to...`;
            }

            socket.on('connect', () => {
                console.log('Connected to server');
                if (joinBtn) {
                    joinBtn.innerText = `Connected: ${serverIP}`;
                    joinBtn.style.background = '#228822'; // Green
                    joinBtn.style.borderColor = '#44aa44';
                }

                // Send current vehicle colors and username
                const username = localStorage.getItem('playerUsername') || "";
                socket.emit('updatePlayerDetails', {
                    vehicleColors: vehicleColors,
                    username: username,
                    pedestrianColors: defaultPedestrianColors // Send current pedestrian colors
                });
            });

            socket.on('connect_error', (err) => {
                console.error('Connection failed', err);
                if (joinBtn) {
                    joinBtn.innerText = `Connection Failed`;
                    joinBtn.style.background = '#882222'; // Red
                    joinBtn.style.borderColor = '#aa4444';
                }

                // Detailed error for user
                let msg = `Could not connect to ${connectionUrl}.\n`;
                if (location.protocol === 'https:' && connectionUrl.startsWith('http:')) {
                    msg += `\nPOSSIBLE CAUSE: You are playing on HTTPS but the server is HTTP. Browsers block this ("Mixed Content").\nTry using ngrok to get an HTTPS url for your server, or play the game via HTTP (if possible).`;
                } else {
                    msg += `\nCheck:\n1. Server is running (port 3000)\n2. Correct IP address (Public IP if over internet)\n3. Port Forwarding is set up correctly in your router.\n4. Windows Firewall is allowing Node.js connections.`;
                }

                // Only alert once to prevent loop
                if (!window.hasAlertedError) {
                    alert(msg);
                    window.hasAlertedError = true;
                }
            });

            socket.on('disconnect', () => {
                if (joinBtn) {
                    joinBtn.innerText = 'Disconnected - Click to Rejoin';
                    joinBtn.style.background = '#444';
                    joinBtn.style.borderColor = '#666';
                }
            });

            socket.on('currentPlayers', (players) => {
                Object.keys(players).forEach((id) => {
                    if (id !== socket.id) {
                        addOtherPlayer(players[id]);
                    }
                });
            });

            socket.on('newPlayer', (playerInfo) => {
                addOtherPlayer(playerInfo);
            });

            socket.on('playerDisconnected', (id) => {
                removeOtherPlayer(id);
            });

            socket.on('playerMoved', (playerInfo) => {
                if (otherPlayers[playerInfo.id]) {
                    otherPlayers[playerInfo.id].targetPos = {
                        x: playerInfo.x,
                        y: playerInfo.y,
                        z: playerInfo.z,
                        rotation: playerInfo.rotation
                    };

                    // Handle Mode Change (Vehicle <-> Pedestrian)
                    const wasPed = otherPlayers[playerInfo.id].isPedestrian;
                    const isPed = playerInfo.isPedestrian;

                    if (wasPed !== isPed) {
                        removeOtherPlayer(playerInfo.id);
                        addOtherPlayer(playerInfo);
                        return; // addOtherPlayer handles the rest
                    }

                    // Handle Vehicle Type Change (only if still vehicle)
                    if (!isPed && playerInfo.vehicleType && otherPlayers[playerInfo.id].vehicleType !== playerInfo.vehicleType) {
                        // Re-create vehicle
                        removeOtherPlayer(playerInfo.id);
                        addOtherPlayer(playerInfo);
                    }
                } else {
                    addOtherPlayer(playerInfo);
                }
            });

            socket.on('playerDetailsUpdated', (data) => {
                if (otherPlayers[data.id]) {
                    if (data.vehicleColors) {
                        otherPlayers[data.id].vehicleColors = data.vehicleColors;
                        // Only update visual if currently a vehicle
                        if (!otherPlayers[data.id].isPedestrian) {
                            updateRemotePlayerVisuals(data.id);
                        }
                    }
                    if (data.pedestrianColors) {
                        otherPlayers[data.id].pedestrianColors = data.pedestrianColors;
                        // Only update visual if currently a pedestrian
                        if (otherPlayers[data.id].isPedestrian) {
                            // Re-apply colors to pedestrian mesh
                            if (otherPlayers[data.id].mesh) {
                                // Since pedestrian mesh structure is a group with userData.limbs,
                                // we can use applyPedestrianColors but we need to pass the group.
                                // addOtherPlayer stores the group in .mesh.
                                // However, applyPedestrianColors expects a mesh with userData.limbs.
                                // buildPedestrianMesh returns the group which has userData.limbs.
                                applyPedestrianColors(otherPlayers[data.id].mesh, data.pedestrianColors);
                            }
                        }
                    }
                    if (data.username !== undefined) {
                        otherPlayers[data.id].username = data.username;
                        updateRemoteUsername(data.id, data.username);
                    }
                }
            });
        }

        function addOtherPlayer(playerInfo) {
            if (otherPlayers[playerInfo.id]) return;

            let meshGroup;
            let parkedCarMesh = null;

            if (playerInfo.isPedestrian) {
                // PEDESTRIAN SPAWN
                const colors = playerInfo.pedestrianColors || { shirt: 0x111111, pants: 0x111111, skin: 0xffccaa, robe: 0x000000, hat: 0x555555 };

                // Construct data object expected by buildPedestrianMesh
                const pedData = {
                    isUser: true, // Use user style (with robe/hat if applicable)
                    colors: colors
                };

                meshGroup = buildPedestrianMesh(pedData);

                // SPAWN PARKED VEHICLE IF DATA EXISTS
                if (playerInfo.vehicleData) {
                    const vData = playerInfo.vehicleData;
                    const vType = vData.type || 'hypercar';
                    let vBody = 0xff0000;
                    let vSpoiler = 0x000000;

                    if (playerInfo.vehicleColors && playerInfo.vehicleColors[vType]) {
                        vBody = playerInfo.vehicleColors[vType].body;
                        vSpoiler = playerInfo.vehicleColors[vType].spoiler;
                    }

                    parkedCarMesh = createVehicle({
                        type: vType,
                        bodyColor: vBody,
                        spoilerColor: vSpoiler,
                        addLights: false,
                        scale: 1.8
                    });

                    parkedCarMesh.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    parkedCarMesh.position.set(vData.x, vData.y, vData.z);
                    parkedCarMesh.rotation.y = vData.rotation;
                    scene.add(parkedCarMesh);
                }

            } else {
                // VEHICLE SPAWN
                const type = playerInfo.vehicleType || 'hypercar';
                let bodyColor = 0xff0000;
                let spoilerColor = 0x000000;

                if (playerInfo.vehicleColors && playerInfo.vehicleColors[type]) {
                    bodyColor = playerInfo.vehicleColors[type].body;
                    spoilerColor = playerInfo.vehicleColors[type].spoiler;
                }

                const otherCar = createVehicle({
                    type: type,
                    bodyColor: bodyColor,
                    spoilerColor: spoilerColor,
                    addLights: false,
                    scale: 1.8
                });

                // Enable shadows
                otherCar.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                meshGroup = new THREE.Group();
                meshGroup.add(otherCar);
            }

            meshGroup.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
            meshGroup.rotation.y = playerInfo.rotation;

            otherPlayers[playerInfo.id] = {
                mesh: meshGroup,
                parkedCar: parkedCarMesh,
                targetPos: { x: playerInfo.x, y: playerInfo.y, z: playerInfo.z, rotation: playerInfo.rotation },
                vehicleType: playerInfo.vehicleType,
                vehicleColors: playerInfo.vehicleColors,
                username: playerInfo.username,
                isPedestrian: playerInfo.isPedestrian,
                pedestrianColors: playerInfo.pedestrianColors
            };

            if (playerInfo.username) {
                updateRemoteUsername(playerInfo.id, playerInfo.username);
            }

            scene.add(meshGroup);
        }

        function removeOtherPlayer(id) {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id].mesh);
                if (otherPlayers[id].parkedCar) {
                    scene.remove(otherPlayers[id].parkedCar);
                }
                delete otherPlayers[id];
            }
        }

        function updateRemotePlayerVisuals(id) {
            const p = otherPlayers[id];
            if (!p || !p.mesh || !p.vehicleColors || !p.vehicleType) return;

            const colors = p.vehicleColors[p.vehicleType];
            if (!colors) return;

            // p.mesh is the playerGroup wrapper
            // p.mesh.children[0] is the vehicle model (otherCar)
            const carMesh = p.mesh.children[0];
            if (!carMesh) return;

            carMesh.traverse(child => {
                if (child.isMesh && child.userData.partGroup) {
                    if (child.userData.partGroup === 'body') {
                        child.material.color.setHex(colors.body);
                    } else if (child.userData.partGroup === 'spoiler') {
                        child.material.color.setHex(colors.spoiler);
                    }
                }
            });
        }

        function updateRemotePlayers() {
            Object.keys(otherPlayers).forEach((id) => {
                const p = otherPlayers[id];
                if (p.targetPos) {
                    p.mesh.position.lerp(new THREE.Vector3(p.targetPos.x, p.targetPos.y, p.targetPos.z), 0.2);

                    // Simple rotation interpolation
                    p.mesh.rotation.y += (p.targetPos.rotation - p.mesh.rotation.y) * 0.2;
                }
            });
        }

        function updateRemoteUsername(id, name) {
            const p = otherPlayers[id];
            if (!p || !p.mesh) return;

            // Remove existing label if any
            const existingLabel = p.mesh.getObjectByName('usernameLabel');
            if (existingLabel) {
                p.mesh.remove(existingLabel);
            }

            if (name && name.trim() !== "") {
                const sprite = createUsernameLabel(name);
                sprite.name = 'usernameLabel';
                sprite.position.set(0, 3.5, 0); // Position above the vehicle
                p.mesh.add(sprite);
            }
        }


    </script>
    <script>
        // Load the SDK asynchronously
        (function (d, s, id) {
            var js,
                sjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s);
            js.id = id;
            js.src = 'https://sdk.snapkit.com/js/v1/create.js';
            sjs.parentNode.insertBefore(js, sjs);

            // Add touch event handling for mobile after SDK loads
            js.onload = function () {
                setTimeout(function () {
                    const snapButton = document.querySelector('.snapchat-creative-kit-share');
                    if (snapButton) {
                        // Enable touch events for mobile
                        snapButton.style.touchAction = 'auto';
                        snapButton.style.webkitTouchCallout = 'default';

                        // Add explicit touch handler that delegates to click
                        snapButton.addEventListener('touchstart', function (e) {
                            e.stopPropagation();
                        }, { passive: true });

                        snapButton.addEventListener('touchend', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            // Find and trigger the actual SDK button inside
                            const sdkButton = snapButton.querySelector('button, a, [role="button"]');
                            if (sdkButton) {
                                sdkButton.click();
                            } else {
                                snapButton.click();
                            }
                        }, { passive: false });
                    }
                }, 500); // Wait for SDK to inject the button
            };
        })(document, 'script', 'snapkit-creative-kit-sdk');
    </script>
</body>

</html>
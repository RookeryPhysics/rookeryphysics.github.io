<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Infinite Voxel Driver - Turbo Optimized</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            font-size: 14px;
            pointer-events: none;
            backdrop-filter: blur(4px);
            animation: fadeOut 5s forwards;
            animation-delay: 5s;
            width: 80%;
            max-width: 400px;
            z-index: 15;
        }

        /* --- Controls Layout --- */

        #movement-zone {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 180px;
            height: 180px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #stick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #heading-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: center center;
            z-index: 10;
        }

        #heading-arrow::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 14px;
            background-color: #ff3366;
            left: -3px;
            bottom: 2px;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #heading-arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 16px solid #ff3366;
            left: -10px;
            bottom: 14px;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.3));
        }

        #center-cam-btn {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
        }

        #center-cam-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* --- Day/Night Toggle Button --- */
        #time-btn {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 20;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        #time-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffcc00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
        }

        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-family: monospace;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            left: 130px; 
            width: 80px; 
            height: 80px; 
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: #000;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="fps-counter">FPS: 60</div>
        <div id="score-board">Score: 0</div>
        <div id="time-btn">üåô</div>
        <div id="minimap-container">
            <canvas id="minimap" width="200" height="200"></canvas>
        </div>
        <div class="instructions">Day Run<br>Left Stick: Drive</div>
        <div id="movement-zone">
            <div id="stick-knob">
                <div id="heading-arrow"></div>
            </div>
        </div>
        <div id="center-cam-btn">‚óé</div>
    </div>

    <div id="game-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Variables ---
        let scene, camera, renderer;
        let uiScene, uiCamera;
        let miniatureGroup;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        let player;
        let carType = 'hypercar';
        let currentCarMesh = null;
        let ambientLight, sunLight;

        let isNightMode = false;

        let score = 0;
        const scoreElement = document.getElementById('score-board');
        const fpsElement = document.getElementById('fps-counter');

        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d', { alpha: false }); // Opt for speed

        const allPedestrians = [];
        const activeObstacles = [];
        const particles = [];
        
        // Cache materials to reduce draw calls
        const materialCache = new Map();
        const buildingMaterialCache = new Map();
        
        // Pre-computed Textures
        let dayGroundTexture, nightGroundTexture;

        let lastChunkUpdatePos = new THREE.Vector3(99999, 99999, 99999);

        const pedGeometries = {};
        const buildingGeometries = {};
        let groundGeometry, groundMaterial;
        let roadTileGeometry, roadMaterial;
        let lineTileGeometry, lineMaterial;

        const CULL_DIST = 220; // Reduced slightly for speed
        const CULL_DIST_SQ = CULL_DIST * CULL_DIST;
        const CHUNK_SIZE = 200;
        const CHUNK_RENDER_DIST = 1; // 1 = 3x3 chunks (9 total), 2 = 5x5 chunks (25 total). 1 is MUCH faster.
        const activeChunks = new Map(); 
        const ROAD_TILE_SIZE = 10; 
        const ROAD_WIDTH_THRESHOLD = 0.25; 

        // Physics
        let PLAYER_SPEED = 0.25;
        const FRICTION = 0.80;
        let MAX_SPEED = 2.0;
        const PLAYER_BASE_Y = 0.05;
        const GRAVITY = 0.02;
        let isGameOver = false;
        let isAirborne = false;

        // Movement
        const velocity = new THREE.Vector3(); 
        let moveInput = { x: 0, y: 0 }; 

        // Camera
        let cameraAngle = 0;
        let cameraVerticalAngle = 0.5;
        const CAMERA_DIST = 25;
        let isManualCamera = false;
        let manualCamTimer = 0;

        // Input
        let moveTouchId = null;
        let camTouchId = null;
        let camLastPos = { x: 0, y: 0 };
        const joystickRadius = 90;
        let lastTapTime = 0;

        // FPS
        let lastTime = performance.now();
        let frameCount = 0;
        let globalFrame = 0; // For throttling minimap

        // Elements
        const stickKnob = document.getElementById('stick-knob');
        const headingArrow = document.getElementById('heading-arrow');
        const movementZone = document.getElementById('movement-zone');
        const centerBtn = document.getElementById('center-cam-btn');
        const timeBtn = document.getElementById('time-btn');

        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');

            scene = new THREE.Scene();
            
            // Initial Day Mode Setup
            const dayColor = 0x87CEEB; 
            scene.background = new THREE.Color(dayColor);
            scene.fog = new THREE.Fog(0xa0d8ef, 50, 240); // Tighter fog for performance

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 800);

            // Optimization: Limit pixel ratio to 1.5. Mobile screens don't need native 4k.
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            // Optimization: Use PCF or Basic ShadowMap instead of Soft for speed
            renderer.shadowMap.type = THREE.PCFShadowMap; 
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            // Optimization: Smaller shadow map texture
            sunLight.shadow.mapSize.width = 512;
            sunLight.shadow.mapSize.height = 512;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            const d = 100;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            scene.add(sunLight);

            // UI Scene
            uiScene = new THREE.Scene();
            uiCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            uiCamera.position.z = 10;

            const uiAmb = new THREE.AmbientLight(0xffffff, 0.8);
            uiScene.add(uiAmb);
            const uiDir = new THREE.DirectionalLight(0xffffff, 1.0);
            uiDir.position.set(2, 5, 5);
            uiScene.add(uiDir);

            miniatureGroup = new THREE.Group();
            updateMiniaturePosition();
            uiScene.add(miniatureGroup);

            // PRE-GENERATE TEXTURES (Speed Boost)
            dayGroundTexture = createGroundTexture(false);
            nightGroundTexture = createGroundTexture(true);

            // Geometry Init
            initPedestrianGeometries();
            initWorldGeometries();

            // Player Init
            createPlayer();
            updateMiniatureModel(); 

            // Entities - Reduced count slightly for mobile optimization
            for (let i = 0; i < 350; i++) {
                createPedestrianData();
            }

            // Events
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            document.addEventListener('mousedown', onMouseDown); 

            centerBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); centerCamera(); }, { passive: false });
            centerBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); centerCamera(); });

            timeBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); toggleDayNight(); });
            timeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleDayNight(); }, { passive: false });
        }

        // --- Day/Night Toggle System (Optimized) ---

        function toggleDayNight() {
            isNightMode = !isNightMode;

            if (isNightMode) {
                const duskColor = 0x1a1a2e;
                scene.background.setHex(duskColor);
                scene.fog.color.setHex(duskColor);
                scene.fog.near = 30;
                scene.fog.far = 180;
                
                ambientLight.intensity = 0.2;
                sunLight.color.setHex(0xaaccff);
                sunLight.intensity = 0.5;
                
                document.querySelector('.instructions').innerHTML = "Night Run<br>Left Stick: Drive";
                timeBtn.innerText = "‚òÄÔ∏è";

                roadMaterial.color.setHex(0x222222);
                lineMaterial.color.setHex(0xaa8800);
                
                // Swap texture instantly
                groundMaterial.map = nightGroundTexture;
                
            } else {
                const dayColor = 0x87CEEB;
                scene.background.setHex(dayColor);
                scene.fog.color.setHex(0xa0d8ef);
                scene.fog.near = 50;
                scene.fog.far = 240;
                
                ambientLight.intensity = 0.6;
                sunLight.color.setHex(0xffffff);
                sunLight.intensity = 0.8;
                
                document.querySelector('.instructions').innerHTML = "Day Run<br>Left Stick: Drive";
                timeBtn.innerText = "üåô";

                roadMaterial.color.setHex(0x333333);
                lineMaterial.color.setHex(0xffcc00);
                
                // Swap texture instantly
                groundMaterial.map = dayGroundTexture;
            }

            // Efficient Material Update
            buildingMaterialCache.forEach((mat, key) => {
                 // key structure: "seed_isNight" - wait, we just need to update colors of existing mats
                 // Actually, simpler: iterate all cached mats and update their color
                 // But colors depend on seed.
                 // OPTIMIZATION: Just have 2 sets of materials (Day/Night) or update all.
                 // Let's just update colors. We need to store original color intent in userData or implied.
                 // Actually, simpler approach: Update the specific building meshes in chunks.
            });

            // Updating buildings by traversing chunks
            activeChunks.forEach(chunk => {
                chunk.mesh.traverse(child => {
                    if (child.userData.isBuilding) {
                        const seed = child.userData.seed;
                        // Use Cached Materials
                        const colorHex = isNightMode ? 
                             (seed > 0.5 ? 0x333344 : 0x111122) : 
                             (seed > 0.5 ? 0xcccccc : 0xa0d8ef);
                        
                        // We need to update the material property, but since materials are shared,
                        // we need to be careful. 
                        // STRATEGY: We will just set the color on the material.
                        // Since we are caching by "type" (seed bucket), we can just update the cache.
                        child.material = getBuildingMaterial(seed, isNightMode);
                    }
                });
            });

            loadCarModel(carType);
        }

        // --- Miniature UI ---

        function updateMiniaturePosition() {
            const aspect = window.innerWidth / window.innerHeight;
            const visibleHeight = 2 * Math.tan((uiCamera.fov * Math.PI / 180) / 2) * uiCamera.position.z;
            const visibleWidth = visibleHeight * aspect;
            const unitsPerPixel = visibleHeight / window.innerHeight;
            const yOffsetPixels = 160;
            const xOffsetPixels = 70;
            const x = visibleWidth / 2 - (xOffsetPixels * unitsPerPixel);
            const y = -visibleHeight / 2 + (yOffsetPixels * unitsPerPixel);
            miniatureGroup.position.set(x, y, 0);
        }

        function updateMiniatureModel() {
            while (miniatureGroup.children.length > 0) {
                miniatureGroup.remove(miniatureGroup.children[0]);
            }
            const targetType = (carType === 'truck') ? 'hypercar' : 'truck';
            let mesh;
            if (targetType === 'truck') {
                mesh = buildTruckMesh(false); 
                mesh.scale.set(0.4, 0.4, 0.4);
            } else {
                mesh = buildHypercarMesh(false);
                mesh.scale.set(0.35, 0.35, 0.35);
            }
            mesh.position.y = -0.5;
            miniatureGroup.add(mesh);
            miniatureGroup.userData.targetType = targetType;
        }

        function checkMiniatureClick(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, uiCamera);
            const intersects = raycaster.intersectObjects(miniatureGroup.children, true);
            if (intersects.length > 0) {
                toggleCarModel();
                return true;
            }
            return false;
        }

        // --- Infinite Map System ---

        function initWorldGeometries() {
            groundGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
            groundMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.9, metalness: 0.1, map: dayGroundTexture
            });

            roadTileGeometry = new THREE.PlaneGeometry(ROAD_TILE_SIZE, ROAD_TILE_SIZE);
            roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.2 });

            lineTileGeometry = new THREE.PlaneGeometry(2, 6);
            lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

            buildingGeometries.small = new THREE.BoxGeometry(10, 30, 10);
            buildingGeometries.tall = new THREE.BoxGeometry(15, 80, 15);
            buildingGeometries.wide = new THREE.BoxGeometry(30, 25, 20);
        }

        function createGroundTexture(isNight) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; // Reduced texture size for speed
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            if (isNight) {
                ctx.fillStyle = '#223322';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#1a2a1a';
            } else {
                ctx.fillStyle = '#66aa66';
                ctx.fillRect(0, 0, 256, 256);
                ctx.strokeStyle = '#559955';
            }

            ctx.lineWidth = 4;
            const cells = 4;
            const step = 256 / cells;
            for (let i = 0; i <= cells; i++) {
                ctx.beginPath(); ctx.moveTo(i * step, 0); ctx.lineTo(i * step, 256); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * step); ctx.lineTo(256, i * step); ctx.stroke();
            }

            ctx.fillStyle = isNight ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const w = Math.random() * 10 + 2;
                ctx.fillRect(x, y, w, w);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function pseudoRandom(x, z) {
            const val = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
            return val - Math.floor(val);
        }

        function getRoadValue(x, z) {
            const scale = 0.005;
            const v1 = Math.sin(x * scale) + Math.cos(z * scale);
            const v2 = Math.sin(x * scale * 0.5 + z * scale * 0.2) * 0.5;
            return Math.abs(v1 + v2);
        }

        function disposeChunk(chunkData) {
            if(!chunkData) return;
            const group = chunkData.mesh;
            // Iterate and dispose geometries/materials
            group.traverse(child => {
                if (child.isMesh) {
                    // Don't dispose shared geometries (like groundGeometry), only instances if unique
                    // In this case, most geometries are shared, which is good.
                    // If we had unique geometries, we'd dispose them here.
                    
                    // Materials: We are caching them now, so we DO NOT dispose them here
                    // unless we want to clear the cache.
                }
            });
            scene.remove(group);
        }

        function updateChunks() {
            if (!player) return;
            if (player.position.distanceTo(lastChunkUpdatePos) < 50) return;
            lastChunkUpdatePos.copy(player.position);
            const px = player.position.x;
            const pz = player.position.z;
            const currentChunkX = Math.floor(px / CHUNK_SIZE + 0.5);
            const currentChunkZ = Math.floor(pz / CHUNK_SIZE + 0.5);
            
            const newKeys = new Set();
            
            // Generate valid keys
            for (let x = -CHUNK_RENDER_DIST; x <= CHUNK_RENDER_DIST; x++) {
                for (let z = -CHUNK_RENDER_DIST; z <= CHUNK_RENDER_DIST; z++) {
                    const cx = currentChunkX + x;
                    const cz = currentChunkZ + z;
                    const key = `${cx},${cz}`;
                    newKeys.add(key);
                    if (!activeChunks.has(key)) createChunk(cx, cz);
                }
            }

            // Garbage Collection
            for (const [key, chunkData] of activeChunks) {
                if (!newKeys.has(key)) {
                    disposeChunk(chunkData);
                    activeChunks.delete(key);
                }
            }
        }

        function getBuildingMaterial(seed, isNight) {
            // Bucket seed into 3 types to reduce material count
            let type = 0;
            if (seed < 0.3) type = 1;
            else if (seed < 0.6) type = 2;
            else type = 3;

            const key = `${type}_${isNight}`;
            if (!buildingMaterialCache.has(key)) {
                let matColor;
                if (isNight) {
                    matColor = seed > 0.5 ? 0x333344 : 0x111122;
                } else {
                    matColor = seed > 0.5 ? 0xcccccc : 0xa0d8ef;
                }
                const mat = new THREE.MeshStandardMaterial({ color: matColor });
                buildingMaterialCache.set(key, mat);
            }
            return buildingMaterialCache.get(key);
        }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            const chunkX = cx * CHUNK_SIZE;
            const chunkZ = cz * CHUNK_SIZE;
            group.position.set(chunkX, 0, chunkZ);

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            // Prevent ground from being frustum culled erroneously if camera is low
            ground.frustumCulled = false; 
            group.add(ground);

            const roadMatrices = [];
            const lineMatrices = [];
            const roadMapPositions = [];
            const roadSet = new Set();
            const halfSize = CHUNK_SIZE / 2;
            
            // Pre-allocate Objects to avoid GC
            const dummy = new THREE.Object3D();
            
            for (let lx = -halfSize; lx < halfSize; lx += ROAD_TILE_SIZE) {
                for (let lz = -halfSize; lz < halfSize; lz += ROAD_TILE_SIZE) {
                    const wx = chunkX + lx + ROAD_TILE_SIZE / 2;
                    const wz = chunkZ + lz + ROAD_TILE_SIZE / 2;
                    const val = getRoadValue(wx, wz);
                    if (val < ROAD_WIDTH_THRESHOLD) {
                        dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.1, lz + ROAD_TILE_SIZE / 2);
                        dummy.rotation.x = -Math.PI / 2;
                        dummy.rotation.y = 0;
                        dummy.rotation.z = 0;
                        dummy.scale.set(1,1,1);
                        dummy.updateMatrix();
                        
                        roadMatrices.push(dummy.matrix.clone());
                        roadSet.add(`${lx + ROAD_TILE_SIZE / 2},${lz + ROAD_TILE_SIZE / 2}`);
                        // Reduce array push for minimap to save memory - only push every other node? 
                        // No, minimap needs precision. Kept.
                        roadMapPositions.push({ x: wx, z: wz });
                        
                        if (val < 0.03) {
                            dummy.position.set(lx + ROAD_TILE_SIZE / 2, 0.15, lz + ROAD_TILE_SIZE / 2);
                            dummy.updateMatrix();
                            lineMatrices.push(dummy.matrix.clone());
                        }
                    }
                }
            }

            if (roadMatrices.length > 0) {
                const roadMesh = new THREE.InstancedMesh(roadTileGeometry, roadMaterial, roadMatrices.length);
                roadMesh.receiveShadow = true;
                for (let i = 0; i < roadMatrices.length; i++) roadMesh.setMatrixAt(i, roadMatrices[i]);
                group.add(roadMesh);
            }
            if (lineMatrices.length > 0) {
                const lineMesh = new THREE.InstancedMesh(lineTileGeometry, lineMaterial, lineMatrices.length);
                for (let i = 0; i < lineMatrices.length; i++) lineMesh.setMatrixAt(i, lineMatrices[i]);
                group.add(lineMesh);
            }

            let seed = pseudoRandom(cx, cz);
            const obstacles = [];
            const numObjects = seed > 0.8 ? 15 : (seed > 0.4 ? 4 : 2);

            for (let i = 0; i < numObjects; i++) {
                seed = pseudoRandom(seed, i);
                const bx = (pseudoRandom(seed * 10, i) - 0.5) * (CHUNK_SIZE - 20);
                const bz = (pseudoRandom(seed * 20, i) - 0.5) * (CHUNK_SIZE - 20);
                const snapX = Math.round(bx / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;
                const snapZ = Math.round(bz / ROAD_TILE_SIZE) * ROAD_TILE_SIZE + ROAD_TILE_SIZE / 2;
                
                let onRoad = false;
                if (roadSet.has(`${snapX},${snapZ}`)) onRoad = true;
                if (!onRoad) {
                     // Check world coordinates for road function
                    const worldX = chunkX + bx;
                    const worldZ = chunkZ + bz;
                    if (getRoadValue(worldX, worldZ) < ROAD_WIDTH_THRESHOLD + 0.1) onRoad = true;
                }
                
                if (onRoad) continue;

                let geo, radius, height, width, depth;
                if (seed < 0.3) { geo = buildingGeometries.small; radius = 8; height = 30; width = 10; depth = 10; } 
                else if (seed < 0.6) { geo = buildingGeometries.tall; radius = 10; height = 80; width = 15; depth = 15; } 
                else { geo = buildingGeometries.wide; radius = 15; height = 25; width = 30; depth = 20; }

                // OPTIMIZATION: Use shared material from cache
                const mat = getBuildingMaterial(seed, isNightMode);
                const mesh = new THREE.Mesh(geo, mat);
                const rot = (pseudoRandom(seed * 30, i) * Math.PI * 4);
                mesh.position.set(bx, geo.parameters.height / 2, bz);
                mesh.rotation.y = rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.matrixAutoUpdate = false; // Static object optimization
                mesh.updateMatrix();
                
                mesh.userData = { isBuilding: true, seed: seed };
                
                group.add(mesh);
                obstacles.push({ x: chunkX + bx, z: chunkZ + bz, radiusSq: radius * radius, isBuilding: true, rotation: rot, height: height, width: width, depth: depth });
            }

            scene.add(group);
            activeChunks.set(`${cx},${cz}`, { mesh: group, obstacles: obstacles, roads: roadMapPositions });
        }

        // --- Entities ---
        function initPedestrianGeometries() {
            pedGeometries.head = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            pedGeometries.body = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            pedGeometries.arm = new THREE.BoxGeometry(0.25, 1.0, 0.25);
            pedGeometries.arm.translate(0, -0.4, 0);
            pedGeometries.leg = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            pedGeometries.leg.translate(0, -0.6, 0);
        }
        function createPedestrianData() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 200 + 50;
            const pedData = {
                position: new THREE.Vector3(Math.sin(angle) * dist, 2.0, Math.cos(angle) * dist),
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.2),
                rotation: Math.random() * Math.PI * 2,
                animPhase: Math.random() * 100,
                isActive: false, mesh: null,
                colors: { shirt: Math.random() * 0xffffff, pants: Math.random() * 0xffffff, skin: 0xffccaa }
            };
            allPedestrians.push(pedData);
        }
        function getCachedMaterial(colorHex) {
            const hex = Math.floor(colorHex);
            if (!materialCache.has(hex)) materialCache.set(hex, new THREE.MeshStandardMaterial({ color: hex }));
            return materialCache.get(hex);
        }
        function buildPedestrianMesh(data) {
            const group = new THREE.Group();
            const skinMat = getCachedMaterial(data.colors.skin);
            const shirtMat = getCachedMaterial(data.colors.shirt);
            const pantsMat = getCachedMaterial(data.colors.pants);
            const head = new THREE.Mesh(pedGeometries.head, skinMat); head.position.y = 0.9; head.castShadow = true; group.add(head);
            const body = new THREE.Mesh(pedGeometries.body, shirtMat); body.position.y = 0; body.castShadow = true; group.add(body);
            const armL = new THREE.Mesh(pedGeometries.arm, shirtMat); armL.position.set(-0.55, 0.4, 0); armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(pedGeometries.arm, shirtMat); armR.position.set(0.55, 0.4, 0); armR.castShadow = true; group.add(armR);
            const legL = new THREE.Mesh(pedGeometries.leg, pantsMat); legL.position.set(-0.25, -0.6, 0); legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(pedGeometries.leg, pantsMat); legR.position.set(0.25, -0.6, 0); legR.castShadow = true; group.add(legR);
            group.userData = { limbs: { armL, armR, legL, legR } };
            return group;
        }

        // --- CAR MODELS & HEADLIGHTS ---

        function createHeadlights(group, xOffset, y, z, intensity = 2) {
            if (!isNightMode) return;

            const spotL = new THREE.SpotLight(0xffffdd, intensity);
            spotL.position.set(-xOffset, y, z);
            spotL.angle = Math.PI / 6;
            spotL.penumbra = 0.3;
            spotL.decay = 1.5;
            spotL.distance = 80; // Reduced distance for performance
            spotL.castShadow = false; 
            spotL.target.position.set(-xOffset, 0, z + 20);
            group.add(spotL);
            group.add(spotL.target);

            const spotR = new THREE.SpotLight(0xffffdd, intensity);
            spotR.position.set(xOffset, y, z);
            spotR.angle = Math.PI / 6;
            spotR.penumbra = 0.3;
            spotR.decay = 1.5;
            spotR.distance = 80;
            spotR.target.position.set(xOffset, 0, z + 20);
            group.add(spotR);
            group.add(spotR.target);
        }

        function buildTruckMesh(addLights = true) {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3, metalness: 0.8 });
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.0, metalness: 0.9, emissive: 0x002244, emissiveIntensity: 0.2 });
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x00ffcc, emissiveIntensity: 0.5 });
            
            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: lightIntensity });

            const chassisGeo = new THREE.BoxGeometry(2.2, 0.8, 4);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat); chassis.position.y = 0.6; group.add(chassis);
            const cabinGeo = new THREE.BoxGeometry(1.6, 0.6, 2);
            const cabin = new THREE.Mesh(cabinGeo, cabinMat); cabin.position.set(0, 1.2, 0); group.add(cabin);
            const spoilerStalkGeo = new THREE.BoxGeometry(0.2, 0.5, 0.5);
            const spoilerWingGeo = new THREE.BoxGeometry(2.4, 0.1, 0.8);
            const stalkL = new THREE.Mesh(spoilerStalkGeo, bodyMat); stalkL.position.set(-0.8, 1.1, -1.8); group.add(stalkL);
            const stalkR = new THREE.Mesh(spoilerStalkGeo, bodyMat); stalkR.position.set(0.8, 1.1, -1.8); group.add(stalkR);
            const wing = new THREE.Mesh(spoilerWingGeo, bodyMat); wing.position.set(0, 1.4, -1.8); group.add(wing);
            const wheelGeo = new THREE.BoxGeometry(0.4, 0.8, 0.8);
            const positions = [{ x: -1.2, z: 1.2 }, { x: 1.2, z: 1.2 }, { x: -1.2, z: -1.2 }, { x: 1.2, z: -1.2 }];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat); wheel.position.set(pos.x, 0.4, pos.z); group.add(wheel);
                const rim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.4), rimMat); rim.position.set(pos.x + (pos.x > 0 ? 0.2 : -0.2), 0.4, pos.z); group.add(rim);
            });
            const headLightGeo = new THREE.BoxGeometry(0.6, 0.2, 0.1);
            const headL = new THREE.Mesh(headLightGeo, headLightMat); headL.position.set(-0.6, 0.7, 2.0); group.add(headL);
            const headR = new THREE.Mesh(headLightGeo, headLightMat); headR.position.set(0.6, 0.7, 2.0); group.add(headR);
            const tailGeo = new THREE.BoxGeometry(2.0, 0.2, 0.1);
            const tail = new THREE.Mesh(tailGeo, tailLightMat); tail.position.set(0, 0.8, -2.0); group.add(tail);

            if (addLights) {
                createHeadlights(group, 0.6, 0.7, 2.1, 8.0);
            }

            return group;
        }

        function buildHypercarMesh(addLights = true) {
            const group = new THREE.Group();
            const bodyColor = 0xFFD700;
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.2, metalness: 0.6 });
            const carbonMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5, metalness: 0.5 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.9 });
            
            const lightIntensity = isNightMode ? 5.0 : 0.5;
            const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: lightIntensity });
            const headLightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: lightIntensity });
            const exhaustMat = new THREE.MeshStandardMaterial({ color: 0x8888ff, metalness: 1.0, roughness: 0.2, emissive: 0x2222ff, emissiveIntensity: isNightMode ? 2.0 : 0.5 });

            const chassisGeo = new THREE.BoxGeometry(2.0, 0.5, 4.4);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat); chassis.position.y = 0.5; group.add(chassis);
            const cabinGeo = new THREE.BoxGeometry(1.4, 0.5, 2.0);
            const cabin = new THREE.Mesh(cabinGeo, glassMat); cabin.position.set(0, 1.0, 0.2); group.add(cabin);
            const fenderGeoFront = new THREE.BoxGeometry(0.8, 0.6, 1.2);
            const fenderGeoRear = new THREE.BoxGeometry(0.9, 0.7, 1.4);
            const fl = new THREE.Mesh(fenderGeoFront, bodyMat); fl.position.set(-1.2, 0.5, 1.4); group.add(fl);
            const fr = new THREE.Mesh(fenderGeoFront, bodyMat); fr.position.set(1.2, 0.5, 1.4); group.add(fr);
            const rl = new THREE.Mesh(fenderGeoRear, bodyMat); rl.position.set(-1.25, 0.6, -1.2); group.add(rl);
            const rr = new THREE.Mesh(fenderGeoRear, bodyMat); rr.position.set(1.25, 0.6, -1.2); group.add(rr);
            const skirtGeo = new THREE.BoxGeometry(0.4, 0.2, 2.0);
            const skirtL = new THREE.Mesh(skirtGeo, carbonMat); skirtL.position.set(-1.1, 0.3, 0.1); group.add(skirtL);
            const skirtR = new THREE.Mesh(skirtGeo, carbonMat); skirtR.position.set(1.1, 0.3, 0.1); group.add(skirtR);
            const wingPillarGeo = new THREE.BoxGeometry(0.2, 0.6, 0.4);
            const wpL = new THREE.Mesh(wingPillarGeo, carbonMat); wpL.position.set(-0.5, 0.8, -1.8); group.add(wpL);
            const wpR = new THREE.Mesh(wingPillarGeo, carbonMat); wpR.position.set(0.5, 0.8, -1.8); group.add(wpR);
            const wingBladeGeo = new THREE.BoxGeometry(2.6, 0.1, 0.8);
            const wing = new THREE.Mesh(wingBladeGeo, carbonMat); wing.position.set(0, 1.1, -1.9); group.add(wing);
            const exhaustBoxGeo = new THREE.BoxGeometry(0.6, 0.4, 0.1);
            const exhaustBox = new THREE.Mesh(exhaustBoxGeo, carbonMat); exhaustBox.position.set(0, 0.6, -2.25); group.add(exhaustBox);
            const pipeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            [[-0.15, 0.1], [0.15, 0.1], [-0.15, -0.1], [0.15, -0.1]].forEach(off => {
                const pipe = new THREE.Mesh(pipeGeo, exhaustMat); pipe.position.set(off[0], 0.6 + off[1], -2.31); group.add(pipe);
            });
            const tlGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const tlL = new THREE.Mesh(tlGeo, tailLightMat); tlL.position.set(-1.4, 0.7, -1.9); group.add(tlL);
            const tlR = new THREE.Mesh(tlGeo, tailLightMat); tlR.position.set(1.4, 0.7, -1.9); group.add(tlR);
            const hlGeo = new THREE.BoxGeometry(0.6, 0.1, 0.2);
            const hlL = new THREE.Mesh(hlGeo, headLightMat); hlL.position.set(-1.0, 0.5, 2.0); group.add(hlL);
            const hlR = new THREE.Mesh(hlGeo, headLightMat); hlR.position.set(1.0, 0.5, 2.0); group.add(hlR);
            const wheelGeo = new THREE.BoxGeometry(0.6, 0.8, 0.8);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x000000 }); 
            [{ x: -1.3, z: 1.4 }, { x: 1.3, z: 1.4 }, { x: -1.35, z: -1.2 }, { x: 1.35, z: -1.2 }].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat); wheel.position.set(pos.x, 0.4, pos.z); group.add(wheel);
                const rim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.5), rimMat); rim.position.set(pos.x + (pos.x > 0 ? 0.3 : -0.3), 0.4, pos.z); group.add(rim);
            });

            if(addLights) {
                createHeadlights(group, 1.0, 0.5, 2.0, 10.0);
            }
            return group;
        }

        function createPlayer() {
            player = new THREE.Group();
            player.position.set(0, PLAYER_BASE_Y, 0);
            scene.add(player);
            // Default to hypercar
            loadCarModel('hypercar');
        }

        function loadCarModel(type) {
            if (currentCarMesh) {
                player.remove(currentCarMesh);
                // Dispose logic for car would go here if we were generating new geoms constantly,
                // but we are rebuilding small groups. 
            }
            carType = type;
            if (type === 'truck') {
                currentCarMesh = buildTruckMesh(true);
                currentCarMesh.scale.set(2.1, 1.5, 1.5);
                PLAYER_SPEED = 0.25; MAX_SPEED = 2.0;
            } else if (type === 'hypercar') {
                currentCarMesh = buildHypercarMesh(true);
                currentCarMesh.scale.set(1.8, 1.8, 1.8);
                PLAYER_SPEED = 0.45; MAX_SPEED = 3.5;
            }
            currentCarMesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            player.add(currentCarMesh);
        }

        function toggleCarModel() {
            const newType = (carType === 'truck') ? 'hypercar' : 'truck';
            loadCarModel(newType);
            velocity.y = 0.5;
            isAirborne = true;
            updateMiniatureModel();
        }

        function onMouseMoveCam(e) {
            const dx = e.clientX - camLastPos.x;
            const dy = e.clientY - camLastPos.y;
            updateCameraAngle(dx, dy);
            camLastPos = { x: e.clientX, y: e.clientY };
        }

        function onMouseDown(e) {
            if (checkMiniatureClick(e.clientX, e.clientY)) return;
            if (e.target === centerBtn || e.target === timeBtn) return;
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            if (e.clientX < window.innerWidth / 2) {
            } else {
                isManualCamera = true;
                manualCamTimer = 120;
                camLastPos = { x: e.clientX, y: e.clientY };
                document.addEventListener('mousemove', onMouseMoveCam);
                document.addEventListener('mouseup', () => { document.removeEventListener('mousemove', onMouseMoveCam); });
            }
        }

        function onTouchStart(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            const now = Date.now();
            if (now - lastTapTime < 250) emitWheelSmoke();
            lastTapTime = now;
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];
                if (checkMiniatureClick(t.clientX, t.clientY)) continue;
                if (t.target === timeBtn) {
                     toggleDayNight();
                     continue;
                }
                const dx = t.clientX - zoneCenter.x;
                const dy = t.clientY - zoneCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (moveTouchId === null && dist < joystickRadius * 1.5) {
                    moveTouchId = t.identifier;
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (camTouchId === null && t.target !== centerBtn) {
                    camTouchId = t.identifier;
                    isManualCamera = true;
                    manualCamTimer = 120;
                    camLastPos = { x: t.clientX, y: t.clientY };
                }
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            const zoneRect = movementZone.getBoundingClientRect();
            const zoneCenter = { x: zoneRect.left + zoneRect.width / 2, y: zoneRect.top + zoneRect.height / 2 };
            for (let i = 0; i < touches.length; i++) {
                const t = touches[i];
                if (t.identifier === moveTouchId) {
                    updateJoystick(t.clientX, t.clientY, zoneCenter);
                } else if (t.identifier === camTouchId) {
                    const dx = t.clientX - camLastPos.x;
                    const dy = t.clientY - camLastPos.y;
                    updateCameraAngle(dx, dy);
                    camLastPos = { x: t.clientX, y: t.clientY };
                    isManualCamera = true;
                    manualCamTimer = 120;
                }
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === moveTouchId) {
                    moveTouchId = null;
                    moveInput = { x: 0, y: 0 };
                    stickKnob.style.transform = `translate(-50%, -50%)`;
                }
                if (touches[i].identifier === camTouchId) camTouchId = null;
            }
        }

        function updateJoystick(clientX, clientY, center) {
            let dx = clientX - center.x;
            let dy = clientY - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > joystickRadius) {
                const ratio = joystickRadius / distance;
                dx *= ratio;
                dy *= ratio;
            }
            stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            moveInput.x = dx / joystickRadius;
            moveInput.y = dy / joystickRadius;
        }

        function updateCameraAngle(dx, dy) {
            const sensitivity = 0.005;
            cameraAngle -= dx * sensitivity;
            cameraVerticalAngle -= dy * sensitivity;
            cameraVerticalAngle = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraVerticalAngle));
        }

        function centerCamera() {
            if (!player) return;
            cameraAngle = player.rotation.y + Math.PI;
            cameraVerticalAngle = 0.5;
            isManualCamera = false;
            manualCamTimer = 0;
        }

        function updateHeadingIndicator() {
            if (!player) return;
            const carRot = player.rotation.y;
            const camRot = cameraAngle;
            const diff = carRot - camRot;
            const screenX = Math.sin(diff);
            const screenY = -Math.cos(diff);
            const angleRad = Math.atan2(screenX, screenY);
            const angleDeg = angleRad * (180 / Math.PI);
            headingArrow.style.transform = `rotate(${angleDeg}deg)`;
        }

        function shortestAngleDist(a, b) {
            let diff = b - a;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }

        function updatePhysics() {
            if (isGameOver) return;
            if (Math.abs(moveInput.x) > 0.1) {
                const turnFactor = carType === 'hypercar' ? 0.05 : 0.04;
                player.rotation.y -= moveInput.x * turnFactor;
                if (Math.abs(moveInput.x) > 0.85 && Math.random() < 0.25) emitWheelSmoke();
            }
            if (Math.abs(moveInput.y) > 0.1) {
                const throttle = -moveInput.y;
                const rotation = player.rotation.y;
                const accelX = Math.sin(rotation) * throttle * PLAYER_SPEED;
                const accelZ = Math.cos(rotation) * throttle * PLAYER_SPEED;
                velocity.x += accelX;
                velocity.z += accelZ;
            }
            velocity.x *= FRICTION;
            velocity.z *= FRICTION;
            velocity.y -= GRAVITY;

            const hSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
            if (hSpeed > MAX_SPEED) {
                const ratio = MAX_SPEED / hSpeed;
                velocity.x *= ratio;
                velocity.z *= ratio;
            }
            player.position.add(velocity);

            if (player.position.y < PLAYER_BASE_Y) {
                player.position.y = PLAYER_BASE_Y;
                velocity.y = 0;
                isAirborne = false;
            } else {
                isAirborne = true;
            }

            const pRadiusSq = 4.0; 
            for (const chunk of activeChunks.values()) {
                if (!chunk.obstacles) continue;
                for (let i = 0; i < chunk.obstacles.length; i++) {
                    const obs = chunk.obstacles[i];
                    if (player.position.y > obs.height) continue;
                    const dx = player.position.x - obs.x;
                    const dz = player.position.z - obs.z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < obs.radiusSq + pRadiusSq) {
                        explode(player.position, 0xff4400);
                        explode(player.position, 0xffee00);
                        isGameOver = true;
                        player.visible = false;
                        velocity.set(0, 0, 0);
                        const instr = document.querySelector('.instructions');
                        const oldText = instr.innerHTML;
                        instr.innerHTML = "<span style='color:red; font-size:20px; font-weight:bold;'>CRASHED!</span>";
                        instr.style.opacity = 1;
                        instr.style.animation = 'none';
                        setTimeout(() => resetGame(oldText), 3000);
                        return;
                    }
                }
            }
        }

        function resetGame(oldText) {
            isGameOver = false;
            player.visible = true;
            player.position.set(0, PLAYER_BASE_Y, 0);
            player.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0);
            moveInput = { x: 0, y: 0 }; 
            score = 0;
            scoreElement.innerText = "Score: 0";
            centerCamera();
            const instr = document.querySelector('.instructions');
            instr.innerHTML = oldText || (isNightMode ? "Night Run<br>Left Stick: Drive" : "Day Run<br>Left Stick: Drive");
            instr.style.animation = 'none';
            instr.offsetHeight; 
            instr.style.animation = 'fadeOut 5s forwards';
            instr.style.animationDelay = '2s';
        }

        function updatePedestrians() {
            if (isGameOver) return; 
            const time = Date.now() * 0.005;
            const playerPos = player.position;
            const SPAWN_RANGE = 250; 
            activeObstacles.length = 0;
            
            // Reusable loop vars to reduce GC
            let ped, dx, dz, distSq, phase, swing;

            for (let i = 0; i < allPedestrians.length; i++) {
                ped = allPedestrians[i];
                ped.position.add(ped.velocity);
                
                // Wrap around logic
                if (ped.position.x > playerPos.x + SPAWN_RANGE) ped.position.x -= SPAWN_RANGE * 2;
                if (ped.position.x < playerPos.x - SPAWN_RANGE) ped.position.x += SPAWN_RANGE * 2;
                if (ped.position.z > playerPos.z + SPAWN_RANGE) ped.position.z -= SPAWN_RANGE * 2;
                if (ped.position.z < playerPos.z - SPAWN_RANGE) ped.position.z += SPAWN_RANGE * 2;
                
                dx = ped.position.x - playerPos.x;
                dz = ped.position.z - playerPos.z;
                distSq = dx * dx + dz * dz;

                if (distSq < CULL_DIST_SQ) {
                    if (!ped.mesh) {
                        ped.mesh = buildPedestrianMesh(ped);
                        ped.mesh.rotation.y = ped.rotation;
                        // Manual matrix update for static-ish objects (even though they move, we can control it)
                        // Actually, peds move every frame, so we leave matrixAutoUpdate true for them.
                    }
                    if (!ped.isActive) {
                        scene.add(ped.mesh);
                        ped.isActive = true;
                    }
                    ped.mesh.position.copy(ped.position);
                    
                    // Simple animation
                    phase = time + ped.animPhase;
                    swing = Math.sin(phase) * 0.6;
                    ped.mesh.userData.limbs.legL.rotation.x = swing;
                    ped.mesh.userData.limbs.legR.rotation.x = -swing;
                    ped.mesh.userData.limbs.armL.rotation.x = -swing;
                    ped.mesh.userData.limbs.armR.rotation.x = swing;
                    
                    activeObstacles.push(ped);
                } else {
                    if (ped.isActive) {
                        scene.remove(ped.mesh);
                        ped.isActive = false;
                    }
                }
            }
        }

        function checkCollisions() {
            if (isGameOver) return;
            const collisionThresholdSq = 16.0;
            for (let i = activeObstacles.length - 1; i >= 0; i--) {
                const pedData = activeObstacles[i];
                const dx = player.position.x - pedData.position.x;
                const dz = player.position.z - pedData.position.z;
                const distSq = dx * dx + dz * dz;
                if (distSq < collisionThresholdSq) {
                    explode(pedData.position);
                    pedData.position.x = player.position.x + (Math.random() - 0.5) * 300;
                    pedData.position.z = player.position.z + (Math.random() - 0.5) * 300;
                    if (pedData.isActive) {
                        scene.remove(pedData.mesh);
                        pedData.isActive = false;
                    }
                    score++;
                    scoreElement.innerText = "Score: " + score;
                }
            }
        }
        
        function emitWheelSmoke() {
            if (!player) return;
            let wheelOffsets = [];
            if (carType === 'truck') {
                wheelOffsets = [{x: -1.2, z: 1.2}, {x: 1.2, z: 1.2}, {x: -1.2, z: -1.2}, {x: 1.2, z: -1.2}];
            } else {
                wheelOffsets = [{x: -1.3, z: 1.4}, {x: 1.3, z: 1.4}, {x: -1.35, z: -1.2}, {x: 1.35, z: -1.2}];
            }
            const carRot = player.rotation.y;
            const cos = Math.cos(carRot);
            const sin = Math.sin(carRot);
            wheelOffsets.forEach(offset => {
                const rx = offset.x * cos + offset.z * sin;
                const rz = -offset.x * sin + offset.z * cos;
                const pos = new THREE.Vector3(player.position.x + rx, player.position.y + 0.2, player.position.z + rz);
                spawnSmokeParticle(pos); // Reduced to 1 particle per wheel for speed
            });
        }
        
        function spawnSmokeParticle(pos) {
            const size = Math.random() * 0.4 + 0.2;
            const geo = new THREE.BoxGeometry(size, size, size);
            // Optimization: Reuse smoke material? Transparency makes sorting expensive though.
            // Keeping unique materials for fading, but could be improved with instances and a shader.
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.4 });
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            p.position.x += (Math.random() - 0.5) * 0.5;
            p.position.z += (Math.random() - 0.5) * 0.5;
            p.userData = {
                type: 'smoke', life: 1.0,
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.05, 0.05 + Math.random() * 0.05, (Math.random() - 0.5) * 0.05)
            };
            scene.add(p);
            particles.push(p);
        }

        function explode(pos, color = 0xffffff) {
            const pGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const pMat = new THREE.MeshBasicMaterial({ color: color });
            for (let k = 0; k < 5; k++) { // Reduced particle count
                const p = new THREE.Mesh(pGeo, pMat);
                p.position.copy(pos);
                p.position.y += 1.5;
                p.userData = {
                    type: 'debris', life: 1.0,
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 1.0, Math.random() * 1.0 + 0.2, (Math.random() - 0.5) * 1.0)
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'smoke') {
                    p.rotation.x += 0.05; p.rotation.y += 0.05; p.scale.addScalar(0.04); p.userData.life -= 0.025;
                    if(p.material.opacity > 0) p.material.opacity = p.userData.life * 0.4;
                } else {
                    p.userData.velocity.y -= 0.03; p.rotation.x += 0.1; p.rotation.y += 0.1;
                    if (p.position.y < 0) { p.userData.velocity.y *= -0.5; p.position.y = 0; }
                    p.userData.life -= 0.05; p.scale.setScalar(p.userData.life);
                }
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    if(p.material) p.material.dispose();
                    if(p.geometry) p.geometry.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        function updateCamera() {
            if (isManualCamera) {
                manualCamTimer--;
                if (manualCamTimer <= 0) isManualCamera = false;
            } else {
                if (velocity.length() > 0.1) {
                    const targetAngle = player.rotation.y + Math.PI;
                    const dist = shortestAngleDist(cameraAngle, targetAngle);
                    cameraAngle += dist * 0.05;
                    const targetPitch = 0.5;
                    cameraVerticalAngle += (targetPitch - cameraVerticalAngle) * 0.02;
                }
            }
            const hDist = CAMERA_DIST * Math.cos(cameraVerticalAngle);
            const vDist = CAMERA_DIST * Math.sin(cameraVerticalAngle);
            const offsetX = hDist * Math.sin(cameraAngle);
            const offsetZ = hDist * Math.cos(cameraAngle);
            const targetPos = new THREE.Vector3(
                player.position.x + offsetX,
                player.position.y + vDist,
                player.position.z + offsetZ
            );
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);
        }

        function updateMinimap() {
            if (!player) return;
            // Throttle minimap updates: only update every 3rd frame
            if (globalFrame % 3 !== 0) return;

            const w = minimapCanvas.width;
            const h = minimapCanvas.height;
            minimapCtx.clearRect(0, 0, w, h);

            minimapCtx.fillStyle = isNightMode ? 'rgba(10, 20, 30, 0.9)' : 'rgba(68, 119, 68, 0.8)';
            minimapCtx.fillRect(0, 0, w, h);

            minimapCtx.save();
            minimapCtx.translate(w / 2, h / 2);
            minimapCtx.rotate(player.rotation.y + Math.PI);
            minimapCtx.scale(0.8, 0.8); // Zoom out slightly
            minimapCtx.translate(-player.position.x, -player.position.z);

            minimapCtx.fillStyle = isNightMode ? '#333' : '#222';
            for (const chunk of activeChunks.values()) {
                if (chunk.roads) {
                    // Optimization: batch fillRect calls? Canvas is state machine.
                    // Just raw loop is usually fine for this count.
                    for (const road of chunk.roads) {
                        minimapCtx.fillRect(road.x - ROAD_TILE_SIZE/2, road.z - ROAD_TILE_SIZE/2, ROAD_TILE_SIZE + 1, ROAD_TILE_SIZE + 1);
                    }
                }
            }

            minimapCtx.fillStyle = isNightMode ? '#445566' : '#87CEEB';
            for (const chunk of activeChunks.values()) {
                if (chunk.obstacles) {
                    for (const obs of chunk.obstacles) {
                        if (obs.isBuilding) {
                            // Don't rotate individual buildings on minimap for performance, just rects
                            minimapCtx.fillRect(obs.x - obs.width/2, obs.z - obs.depth/2, obs.width, obs.depth);
                        }
                    }
                }
            }
            minimapCtx.restore();

            // Draw arrow
            minimapCtx.save();
            minimapCtx.translate(w / 2, h / 2);
            minimapCtx.fillStyle = '#ff3366';
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, -10); 
            minimapCtx.lineTo(8, 10);  
            minimapCtx.lineTo(0, 6);   
            minimapCtx.lineTo(-8, 10); 
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.stroke();
            minimapCtx.restore();
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsElement.innerText = "FPS: " + frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateFPS();
            globalFrame++;

            if (player) {
                updatePhysics();
                updateChunks(); 
                updatePedestrians();
                checkCollisions();
                updateParticles();
                updateCamera();
                updateHeadingIndicator();
                updateMinimap(); 
                if (sunLight) {
                    sunLight.position.set(player.position.x + 50, 100, player.position.z + 50);
                    sunLight.target.position.copy(player.position);
                    sunLight.target.updateMatrixWorld();
                }
                if (!isAirborne) {
                    const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                    if (speed > 0.01) {
                        const bounceFreq = carType === 'hypercar' ? 0.03 : 0.015; 
                        const bounceAmp = carType === 'hypercar' ? 0.02 : 0.05;
                        player.position.y = PLAYER_BASE_Y + Math.sin(Date.now() * bounceFreq) * bounceAmp;
                    }
                }
            }
            renderer.clear();
            renderer.render(scene, camera);
            if (miniatureGroup) miniatureGroup.rotation.y += 0.02;
            renderer.clearDepth(); 
            renderer.render(uiScene, uiCamera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            uiCamera.aspect = window.innerWidth / window.innerHeight;
            uiCamera.updateProjectionMatrix();
            updateMiniaturePosition();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinewhoop Drone Game</title>
    <meta name="description" content="A Three.js cinewhoop drone model with interactive grass physics.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://rookeryphysics.github.io/drone">
    <meta property="og:title" content="Cinewhoop Drone Game">
    <meta property="og:description" content="A Three.js cinewhoop drone model with interactive grass physics.">
    <meta property="og:image" content="https://rookeryphysics.github.io/drone/game.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://rookeryphysics.github.io/drone">
    <meta property="twitter:title" content="Cinewhoop Drone Game">
    <meta property="twitter:description" content="A Three.js cinewhoop drone model with interactive physics.">
    <meta property="twitter:image" content="https://rookeryphysics.github.io/drone/game.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #87CEEB;
        }

        canvas {
            display: block;
        }

        .joystick-zone {
            position: fixed;
            bottom: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(4px);
            transition: opacity 0.3s, background 0.3s;
        }

        .joystick-zone:active {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        #joystick-zone-right {
            right: 40px;
        }

        #joystick-zone-left {
            left: 40px;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }



        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: sans-serif;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #fps-counter {
            position: fixed;
            top: 12px;
            left: 12px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 200;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
            background: rgba(0, 0, 0, 0.35);
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 70px;
        }

        #game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 500;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 24px;
        }

        #game-over-overlay.active {
            display: flex;
        }

        #game-over-overlay h1 {
            color: #ff3300;
            font-family: 'Courier New', monospace;
            font-size: 48px;
            text-shadow: 0 0 30px rgba(255, 50, 0, 0.8);
            letter-spacing: 4px;
            animation: pulseText 1.5s ease-in-out infinite;
        }

        #game-over-overlay p {
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 18px;
        }

        #restart-btn {
            padding: 14px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #ff4400, #cc2200);
            color: white;
            border: 2px solid #ff6600;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 68, 0, 0.6);
        }

        @keyframes pulseText {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        #warning-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3300;
            font-family: 'Courier New', monospace;
            font-size: 28px;
            font-weight: bold;
            z-index: 300;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(255, 50, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>

<body>
    <div id="fps-counter">FPS: --</div>
    <div id="warning-text">⚠ INCOMING MISSILE ⚠</div>
    <div id="loading">Generating Grass...</div>

    <div id="game-over-overlay">
        <h1>SHOT DOWN</h1>
        <p>Your drone was destroyed by anti-aircraft fire</p>
        <button id="restart-btn">RESTART</button>
    </div>

    <div id="joystick-zone-left" class="joystick-zone">
        <div id="joystick-knob-left" class="joystick-knob"></div>
    </div>

    <div id="joystick-zone-right" class="joystick-zone">
        <div id="joystick-knob-right" class="joystick-knob"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x9DD5F0, 0.004);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 600);
        camera.position.set(0, 8.0, 16.0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.minDistance = 2;
        controls.maxDistance = 20;
        controls.target.set(0, 1.5, 0);
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.enabled = false;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envScene = new THREE.Scene();
        envScene.background = new THREE.Color(0x87CEEB);

        const envGeo = new THREE.SphereGeometry(50, 16, 16);
        const envMat = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            uniforms: {
                colorTop: { value: new THREE.Color(0x4A90D9) },
                colorBottom: { value: new THREE.Color(0xC8E6FF) },
            },
            vertexShader: `
                varying vec3 vWorldPos;
                void main() {
                    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 colorTop;
                uniform vec3 colorBottom;
                varying vec3 vWorldPos;
                void main() {
                    float t = clamp(normalize(vWorldPos).y * 0.5 + 0.5, 0.0, 1.0);
                    gl_FragColor = vec4(mix(colorBottom, colorTop, t), 1.0);
                }
            `,
        });
        envScene.add(new THREE.Mesh(envGeo, envMat));
        const envMap = pmremGenerator.fromScene(envScene, 0.04).texture;
        scene.environment = envMap;

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const hemi = new THREE.HemisphereLight(0x87CEEB, 0x44aa44, 0.8);
        scene.add(hemi);

        const moonLight = new THREE.DirectionalLight(0xFFF5E0, 1.8);
        moonLight.position.set(-10, 20, -10);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.set(2048, 2048);
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 100;
        moonLight.shadow.camera.left = -40;
        moonLight.shadow.camera.right = 40;
        moonLight.shadow.camera.top = 40;
        moonLight.shadow.camera.bottom = -40;
        moonLight.shadow.bias = -0.0001;
        moonLight.shadow.normalBias = 0.02;
        scene.add(moonLight);
        scene.add(moonLight.target);

        const rimLight = new THREE.DirectionalLight(0xFFE8C0, 0.8);
        rimLight.position.set(15, 10, 5);
        scene.add(rimLight);

        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({
            color: 0x3A7D2A,
            roughness: 0.8,
            metalness: 0.1,
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const grassCount = 10000;

        const grassGeo = new THREE.PlaneGeometry(0.15, 1.6, 1, 4);
        grassGeo.translate(0, 0.8, 0);

        const positions = grassGeo.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            if (y > 1.2) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.05);
            } else if (y > 0.8) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.25);
            } else if (y > 0.4) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.6);
            }
        }
        grassGeo.computeVertexNormals();

        const grassMat = new THREE.MeshStandardMaterial({
            color: 0x4CAF50,
            emissive: 0x1B5E20,
            roughness: 0.7,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        grassMat.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = { value: 0 };
            shader.uniforms.uDronePos = { value: new THREE.Vector3(0, 10, 0) };

            grassMat.userData.shader = shader;

            shader.vertexShader = `
                uniform float uTime;
                uniform vec3 uDronePos;
                ${shader.vertexShader}
            `;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                
                vec4 worldInstancePos = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                
                float dist = distance(worldInstancePos.xz, uDronePos.xz);
                float radius = 3.0;
                
                float bendStrength = 0.0;
                
                if(dist < radius){
                    bendStrength = (1.0 - dist/radius) * (1.0 - dist/radius);
                }
                
                vec2 pushDir = normalize(worldInstancePos.xz - uDronePos.xz);
                
                float heightFactor = smoothstep(0.0, 1.6, position.y);
                
                float wind = sin(uTime * 1.5 + worldInstancePos.x * 0.5 + worldInstancePos.z * 0.3) * 0.1;
                
                transformed.x += wind * heightFactor;
                
                float pushForce = 2.5;
                transformed.x += pushDir.x * bendStrength * pushForce * heightFactor;
                transformed.z += pushDir.y * bendStrength * pushForce * heightFactor;
                
                transformed.y -= bendStrength * heightFactor * 0.5;
                `
            );
        };

        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        grassMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const dummy = new THREE.Object3D();
        const spread = 200;

        for (let i = 0; i < grassCount; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * spread,
                0,
                (Math.random() - 0.5) * spread
            );

            dummy.rotation.y = Math.random() * Math.PI * 2;

            const scale = 0.9 + Math.random() * 0.7;
            dummy.scale.set(scale, scale, scale);

            dummy.rotation.x = (Math.random() - 0.5) * 0.2;
            dummy.rotation.z = (Math.random() - 0.5) * 0.2;

            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);
        }

        scene.add(grassMesh);
        document.getElementById('loading').style.opacity = 0;

        /* ── Chain-link baseball fence (merged geometry for performance) ── */
        const FENCE_HALF = 98;
        const fencePostHeight = 6.0;
        const fencePostRadius = 0.06;
        const fenceSpacing = 5;
        const topRailRadius = 0.05;

        const fenceMetalMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.35,
            metalness: 0.9,
            envMapIntensity: 1.5,
        });

        const chainLinkMat = new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.4,
            metalness: 0.85,
            transparent: true,
            opacity: 0.45,
            side: THREE.DoubleSide,
            depthWrite: false,
        });
        chainLinkMat.onBeforeCompile = (shader) => {
            shader.vertexShader = `
                varying vec2 vUvMesh;
                ${shader.vertexShader}
            `.replace('#include <uv_vertex>', `
                #include <uv_vertex>
                vUvMesh = uv;
            `);
            shader.fragmentShader = `
                varying vec2 vUvMesh;
                ${shader.fragmentShader}
            `.replace('#include <color_fragment>', `
                #include <color_fragment>
                float scaleU = 12.0;
                float scaleV = 24.0;
                vec2 st = vec2(vUvMesh.x * scaleU, vUvMesh.y * scaleV);
                float diamond = abs(fract(st.x) - 0.5) + abs(fract(st.y + st.x * 0.5) - 0.5);
                float wire = 1.0 - smoothstep(0.06, 0.12, abs(diamond - 0.5));
                if (wire < 0.1) discard;
                diffuseColor.a *= wire;
            `);
        };

        // Build fence with merged geometry to minimize draw calls
        const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fencePostHeight, 6);
        const postCapGeo = new THREE.SphereGeometry(fencePostRadius * 1.4, 6, 4);
        const metalGeos = [];
        const panelGeos = [];

        function collectFenceSide(startX, startZ, dx, dz, totalLen) {
            const numPosts = Math.floor(totalLen / fenceSpacing) + 1;
            for (let i = 0; i < numPosts; i++) {
                const px = startX + dx * i * fenceSpacing;
                const pz = startZ + dz * i * fenceSpacing;

                const pg = postGeo.clone();
                pg.translate(px, fencePostHeight / 2, pz);
                metalGeos.push(pg);

                const cg = postCapGeo.clone();
                cg.translate(px, fencePostHeight + 0.02, pz);
                metalGeos.push(cg);

                if (i < numPosts - 1) {
                    const nx = startX + dx * (i + 1) * fenceSpacing;
                    const nz = startZ + dz * (i + 1) * fenceSpacing;
                    const mx = (px + nx) / 2;
                    const mz = (pz + nz) / 2;

                    const railGeo = new THREE.CylinderGeometry(topRailRadius, topRailRadius, fenceSpacing, 6);
                    if (Math.abs(dx) > 0) {
                        railGeo.rotateZ(Math.PI / 2);
                    } else {
                        railGeo.rotateX(Math.PI / 2);
                    }
                    railGeo.translate(mx, fencePostHeight, mz);
                    metalGeos.push(railGeo);

                    const panelGeo = new THREE.PlaneGeometry(fenceSpacing, fencePostHeight);
                    if (Math.abs(dz) > 0) {
                        panelGeo.rotateY(Math.PI / 2);
                    }
                    panelGeo.translate(mx, fencePostHeight / 2, mz);
                    panelGeos.push(panelGeo);
                }
            }
        }

        const fenceLen = FENCE_HALF * 2;
        collectFenceSide(-FENCE_HALF, FENCE_HALF, 1, 0, fenceLen);
        collectFenceSide(-FENCE_HALF, -FENCE_HALF, 1, 0, fenceLen);
        collectFenceSide(FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);
        collectFenceSide(-FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);

        const mergedMetalGeo = BufferGeometryUtils.mergeGeometries(metalGeos);
        const fenceMetalMesh = new THREE.Mesh(mergedMetalGeo, fenceMetalMat);
        fenceMetalMesh.castShadow = true;
        fenceMetalMesh.receiveShadow = true;
        scene.add(fenceMetalMesh);

        const mergedPanelGeo = BufferGeometryUtils.mergeGeometries(panelGeos);
        const fencePanelMesh = new THREE.Mesh(mergedPanelGeo, chainLinkMat);
        fencePanelMesh.receiveShadow = true;
        scene.add(fencePanelMesh);

        // Dispose source geos
        metalGeos.forEach(g => g.dispose());
        panelGeos.forEach(g => g.dispose());

        function roundedBox(w, h, d, r, segs) {
            const shape = new THREE.Shape();
            const x = -w / 2, y = -h / 2;
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extSettings = {
                depth: d,
                bevelEnabled: true,
                bevelThickness: r * 0.5,
                bevelSize: r * 0.5,
                bevelSegments: segs || 3,
            };
            const geo = new THREE.ExtrudeGeometry(shape, extSettings);
            geo.center();
            return geo;
        }

        function createDrone() {
            const drone = new THREE.Group();

            const matCarbonFiber = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.4,
                metalness: 0.5,
                envMapIntensity: 1.0,
            });

            const matDuctPlastic = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.5,
                metalness: 0.1,
                envMapIntensity: 0.5,
            });

            const matDuctInner = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide,
            });

            const matAccentOrange = new THREE.MeshStandardMaterial({
                color: 0xff4400,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0xff2200,
                emissiveIntensity: 0.5,
                envMapIntensity: 1.2,
            });

            const matMotorBell = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.9,
                envMapIntensity: 2.5,
            });

            const matMotorStator = new THREE.MeshStandardMaterial({
                color: 0xaa7722,
                roughness: 0.4,
                metalness: 0.7,
            });

            const matPropBlack = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matPropOrange = new THREE.MeshStandardMaterial({
                color: 0xff5500,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matLens = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.0,
                metalness: 1.0,
                envMapIntensity: 3.0,
            });

            const matCamBody = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.6,
                metalness: 0.2,
                envMapIntensity: 0.8,
            });

            const matBattery = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.6,
                metalness: 0.1,
            });

            const matBattLabel = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                roughness: 0.5,
                metalness: 0.3,
            });

            const matRubber = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
            });

            const matPCB = new THREE.MeshStandardMaterial({
                color: 0x1a3322,
                roughness: 0.8,
                metalness: 0.1,
            });

            const matLEDGreen = new THREE.MeshStandardMaterial({
                color: 0x00ff44,
                emissive: 0x00ff44,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDRed = new THREE.MeshStandardMaterial({
                color: 0xff0022,
                emissive: 0xff0022,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDBlue = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0066ff,
                emissiveIntensity: 3.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matWhitePlastic = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.5,
                metalness: 0.0,
            });

            const matSilver = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.95,
                envMapIntensity: 2.0,
            });

            const frameGeo = roundedBox(1.3, 0.12, 1.5, 0.04, 3);
            const frame = new THREE.Mesh(frameGeo, matCarbonFiber);
            frame.castShadow = true;
            drone.add(frame);

            const bottomPlate = new THREE.Mesh(roundedBox(1.2, 0.04, 1.4, 0.03, 2), matCarbonFiber);
            bottomPlate.position.y = -0.08;
            bottomPlate.castShadow = true;
            drone.add(bottomPlate);

            const armPositions = [
                { x: 0.55, z: 0.55, angle: Math.PI / 4 },
                { x: -0.55, z: 0.55, angle: -Math.PI / 4 },
                { x: 0.55, z: -0.55, angle: -Math.PI / 4 },
                { x: -0.55, z: -0.55, angle: Math.PI / 4 },
            ];

            armPositions.forEach(ap => {
                const armGeo = new THREE.BoxGeometry(0.65, 0.08, 0.2);
                const arm = new THREE.Mesh(armGeo, matCarbonFiber);
                arm.position.set(ap.x * 0.6, 0, ap.z * 0.6);
                arm.rotation.y = ap.angle;
                arm.castShadow = true;
                drone.add(arm);
            });

            const fcBoard = new THREE.Mesh(
                roundedBox(0.42, 0.04, 0.42, 0.02, 2),
                matPCB
            );
            fcBoard.position.y = 0.1;
            drone.add(fcBoard);

            for (let sx = -1; sx <= 1; sx += 2) {
                for (let sz = -1; sz <= 1; sz += 2) {
                    const standoff = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8),
                        matSilver
                    );
                    standoff.position.set(sx * 0.16, 0.08, sz * 0.16);
                    drone.add(standoff);
                }
            }

            const escBoard = new THREE.Mesh(
                roundedBox(0.44, 0.03, 0.44, 0.02, 2),
                matPCB
            );
            escBoard.position.y = 0.155;
            drone.add(escBoard);

            const capGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.08, 10);
            const cap = new THREE.Mesh(capGeo, matCarbonFiber);
            cap.position.set(0.1, 0.2, 0.05);
            cap.rotation.z = Math.PI / 2;
            drone.add(cap);

            const ductOuterR = 0.52;
            const ductInnerR = 0.47;
            const ductHeight = 0.32;
            const motorPositions = [
                { x: 0.82, z: 0.82 }, { x: -0.82, z: 0.82 },
                { x: 0.82, z: -0.82 }, { x: -0.82, z: -0.82 }
            ];

            const allProps = [];
            const allMotorBells = [];

            motorPositions.forEach((pos, i) => {
                const motorUnit = new THREE.Group();
                motorUnit.position.set(pos.x, 0, pos.z);

                const ductOuterGeo = new THREE.CylinderGeometry(
                    ductOuterR, ductOuterR + 0.02, ductHeight, 20, 1, true
                );
                const ductOuter = new THREE.Mesh(ductOuterGeo, matDuctPlastic);
                ductOuter.castShadow = true;
                motorUnit.add(ductOuter);

                const ductInnerGeo = new THREE.CylinderGeometry(
                    ductInnerR, ductInnerR, ductHeight, 20, 1, true
                );
                const ductInner = new THREE.Mesh(ductInnerGeo, matDuctInner);
                motorUnit.add(ductInner);

                const lipGeo = new THREE.TorusGeometry(
                    (ductOuterR + ductInnerR) / 2, 0.025, 6, 16
                );
                const lip = new THREE.Mesh(lipGeo, matDuctPlastic);
                lip.rotation.x = Math.PI / 2;
                lip.position.y = ductHeight / 2;
                motorUnit.add(lip);

                const lipBot = lip.clone();
                lipBot.position.y = -ductHeight / 2;
                motorUnit.add(lipBot);

                const stripeGeo = new THREE.TorusGeometry(
                    ductOuterR + 0.005, 0.012, 4, 16
                );
                const stripe = new THREE.Mesh(stripeGeo, matAccentOrange);
                stripe.rotation.x = Math.PI / 2;
                stripe.position.y = ductHeight / 2 - 0.04;
                motorUnit.add(stripe);

                for (let cs = 0; cs < 4; cs++) {
                    const supportGeo = new THREE.BoxGeometry(ductInnerR * 0.85, 0.03, 0.025);
                    const support = new THREE.Mesh(supportGeo, matCarbonFiber);
                    support.rotation.y = (cs * Math.PI) / 4;
                    support.position.y = -0.05;
                    motorUnit.add(support);
                }

                const statorGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.12, 10);
                const stator = new THREE.Mesh(statorGeo, matMotorStator);
                stator.position.y = -0.04;
                motorUnit.add(stator);

                for (let w = 0; w < 6; w++) {
                    const coilGeo = new THREE.TorusGeometry(0.1, 0.012, 4, 6);
                    const coil = new THREE.Mesh(coilGeo, matMotorStator);
                    coil.rotation.x = Math.PI / 2;
                    coil.rotation.z = (w * Math.PI) / 3;
                    coil.position.y = -0.04;
                    motorUnit.add(coil);
                }

                const bellGroup = new THREE.Group();
                bellGroup.position.y = 0.04;

                const bellGeo = new THREE.CylinderGeometry(0.12, 0.11, 0.06, 12);
                const bell = new THREE.Mesh(bellGeo, matMotorBell);
                bellGroup.add(bell);

                const bellCapGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.02, 10);
                const bellCap = new THREE.Mesh(bellCapGeo, matMotorBell);
                bellCap.position.y = 0.04;
                bellGroup.add(bellCap);

                const shaftGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8);
                const shaft = new THREE.Mesh(shaftGeo, matSilver);
                shaft.position.y = 0.06;
                bellGroup.add(shaft);

                motorUnit.add(bellGroup);
                allMotorBells.push(bellGroup);

                const propGroup = new THREE.Group();
                propGroup.position.y = 0.1;

                const hubGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.018, 12);
                const propMatChoice = (i < 2) ? matPropOrange : matPropBlack;
                const hub = new THREE.Mesh(hubGeo, propMatChoice);
                propGroup.add(hub);

                const nutGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 6);
                const nut = new THREE.Mesh(nutGeo, matSilver);
                nut.position.y = 0.014;
                propGroup.add(nut);

                for (let b = 0; b < 3; b++) {
                    const bladeGroup = new THREE.Group();
                    bladeGroup.rotation.y = (b * Math.PI * 2) / 3;

                    const bladeLen = 0.38;
                    const bladeW = 0.055;
                    const bladeShape = new THREE.Shape();
                    bladeShape.moveTo(0, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.3, bladeW * 0.6, bladeLen * 0.75, bladeW);
                    bladeShape.quadraticCurveTo(bladeLen * 0.95, bladeW * 0.8, bladeLen, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.7, -bladeW * 0.15, 0, 0);

                    const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                        depth: 0.008,
                        bevelEnabled: true,
                        bevelThickness: 0.002,
                        bevelSize: 0.002,
                        bevelSegments: 2,
                    });
                    bladeGeo.center();

                    const blade = new THREE.Mesh(bladeGeo, propMatChoice);
                    blade.rotation.x = 0.12;
                    blade.position.x = bladeLen / 2 + 0.02;
                    bladeGroup.add(blade);

                    propGroup.add(bladeGroup);
                }

                motorUnit.add(propGroup);
                allProps.push(propGroup);

                drone.add(motorUnit);
            });

            const camMount = new THREE.Group();
            camMount.position.set(0, 0.22, 0.58);
            camMount.rotation.x = -0.18;

            const camBodyGeo = roundedBox(0.36, 0.26, 0.2, 0.025, 3);
            const camBody = new THREE.Mesh(camBodyGeo, matCamBody);
            camBody.castShadow = true;
            camMount.add(camBody);

            const lensBarrelGeo = new THREE.CylinderGeometry(0.075, 0.08, 0.06, 20);
            const lensBarrel = new THREE.Mesh(lensBarrelGeo, matCarbonFiber);
            lensBarrel.rotation.x = Math.PI / 2;
            lensBarrel.position.z = 0.13;
            camMount.add(lensBarrel);

            const lensGlassGeo = new THREE.CircleGeometry(0.065, 24);
            const lensGlass = new THREE.Mesh(lensGlassGeo, matLens);
            lensGlass.position.z = 0.165;
            camMount.add(lensGlass);

            const lensRingGeo = new THREE.TorusGeometry(0.072, 0.008, 8, 24);
            const lensRing = new THREE.Mesh(lensRingGeo, matSilver);
            lensRing.position.z = 0.16;
            camMount.add(lensRing);

            const innerRingGeo = new THREE.TorusGeometry(0.04, 0.005, 8, 20);
            const innerRing = new THREE.Mesh(innerRingGeo, matSilver);
            innerRing.position.z = 0.167;
            camMount.add(innerRing);

            const recLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                matLEDRed
            );
            recLED.position.set(0.14, 0.08, 0.1);
            camMount.add(recLED);

            for (let side = -1; side <= 1; side += 2) {
                const bracketGeo = new THREE.BoxGeometry(0.015, 0.12, 0.04);
                const bracket = new THREE.Mesh(bracketGeo, matSilver);
                bracket.position.set(side * 0.2, -0.02, 0);
                camMount.add(bracket);
            }

            for (let side = -1; side <= 1; side += 2) {
                const damperGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const damper = new THREE.Mesh(damperGeo, matAccentOrange);
                damper.position.set(side * 0.2, -0.1, 0);
                camMount.add(damper);
            }

            drone.add(camMount);

            const batteryGroup = new THREE.Group();
            batteryGroup.position.set(0, -0.12, -0.1);

            const battGeo = roundedBox(0.58, 0.14, 0.38, 0.02, 2);
            const battBody = new THREE.Mesh(battGeo, matBattery);
            battBody.castShadow = true;
            batteryGroup.add(battBody);

            const labelGeo = new THREE.BoxGeometry(0.4, 0.005, 0.2);
            const label = new THREE.Mesh(labelGeo, matBattLabel);
            label.position.y = 0.072;
            batteryGroup.add(label);

            for (let s = -1; s <= 1; s += 2) {
                const strapGeo = new THREE.BoxGeometry(0.02, 0.18, 0.42);
                const strap = new THREE.Mesh(strapGeo, matAccentOrange);
                strap.position.set(s * 0.15, 0, 0);
                batteryGroup.add(strap);
            }

            const xt60 = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.04, 0.03),
                matBattLabel
            );
            xt60.position.set(0.32, 0, 0);
            batteryGroup.add(xt60);

            for (let w = 0; w < 4; w++) {
                const wireGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.08, 6);
                const wireMat = new THREE.MeshStandardMaterial({
                    color: [0xff0000, 0x000000, 0xff0000, 0x000000][w],
                    roughness: 0.7,
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.set(0.3, -0.02, -0.12 + w * 0.03);
                wire.rotation.z = Math.PI / 2 + 0.3;
                batteryGroup.add(wire);
            }

            drone.add(batteryGroup);

            const antennaGroup = new THREE.Group();
            antennaGroup.position.set(0.08, 0.2, -0.65);

            const smaGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.04, 10);
            const sma = new THREE.Mesh(smaGeo, matSilver);
            antennaGroup.add(sma);

            const antennaStalk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.35, 8),
                matWhitePlastic
            );
            antennaStalk.position.y = 0.2;
            antennaStalk.rotation.x = -0.3;
            antennaGroup.add(antennaStalk);

            const mushroomGeo = new THREE.SphereGeometry(0.04, 12, 12);
            const mushroom = new THREE.Mesh(mushroomGeo, matWhitePlastic);
            mushroom.position.set(0, 0.38, -0.1);
            antennaGroup.add(mushroom);

            for (let cl = 0; cl < 4; cl++) {
                const clWire = new THREE.Mesh(
                    new THREE.TorusGeometry(0.03, 0.003, 6, 8, Math.PI),
                    matSilver
                );
                clWire.rotation.y = (cl * Math.PI) / 2;
                clWire.position.set(0, 0.38, -0.1);
                antennaGroup.add(clWire);
            }

            drone.add(antennaGroup);

            const gpsMount = new THREE.Group();
            gpsMount.position.set(-0.08, 0.2, -0.55);

            const gpsMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.15, 8),
                matCarbonFiber
            );
            gpsMast.position.y = 0.08;
            gpsMount.add(gpsMast);

            const gpsDisk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.015, 16),
                matCarbonFiber
            );
            gpsDisk.position.y = 0.16;
            gpsMount.add(gpsDisk);

            drone.add(gpsMount);

            const skidPositions = [
                { x: 0.35, z: 0.45 }, { x: -0.35, z: 0.45 },
                { x: 0.35, z: -0.45 }, { x: -0.35, z: -0.45 }
            ];

            skidPositions.forEach(sp => {
                const skid = new THREE.Group();
                skid.position.set(sp.x, -0.18, sp.z);

                const legGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.1, 8);
                const leg = new THREE.Mesh(legGeo, matCarbonFiber);
                skid.add(leg);

                const footGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const foot = new THREE.Mesh(footGeo, matRubber);
                foot.position.y = -0.05;
                foot.scale.y = 0.5;
                skid.add(foot);

                drone.add(skid);
            });

            const rearLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                matLEDGreen
            );
            rearLED.position.set(0, 0.05, -0.76);
            drone.add(rearLED);

            const greenGlow = new THREE.PointLight(0x00ff44, 1.0, 2.5);
            greenGlow.position.copy(rearLED.position);
            drone.add(greenGlow);

            const frontLEDs = [];
            for (let side = -1; side <= 1; side += 2) {
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.012, 8, 8),
                    matLEDBlue
                );
                led.position.set(side * 0.5, -0.02, 0.7);
                drone.add(led);
                frontLEDs.push(led);

                const blueGlow = new THREE.PointLight(0x0066ff, 0.5, 1.5);
                blueGlow.position.copy(led.position);
                drone.add(blueGlow);
            }

            const underglowLEDs = [];
            const underglowLights = [];
            const numUnderglow = 6;
            const underglowLedGeo = new THREE.SphereGeometry(0.01, 4, 4);
            for (let u = 0; u < numUnderglow; u++) {
                const angle = (u * Math.PI * 2) / numUnderglow;
                const r = 0.5;
                const ledMat = new THREE.MeshStandardMaterial({
                    color: 0x00ccff,
                    emissive: 0x00ccff,
                    emissiveIntensity: 2.0,
                    roughness: 0.2,
                });
                const led = new THREE.Mesh(underglowLedGeo, ledMat);
                led.position.set(Math.cos(angle) * r, -0.14, Math.sin(angle) * r);
                drone.add(led);
                underglowLEDs.push({ mesh: led, mat: ledMat });
            }

            const underglowMain = new THREE.PointLight(0x00ccff, 2.0, 8);
            underglowMain.position.set(0, -0.4, 0);
            drone.add(underglowMain);
            underglowLights.push(underglowMain);

            const buzzer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.02, 12),
                matCarbonFiber
            );
            buzzer.position.set(0.6, 0, 0);
            buzzer.rotation.z = Math.PI / 2;
            drone.add(buzzer);

            for (let ra = 0; ra < 2; ra++) {
                const rxAntennaGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.25, 6);
                const rxAntenna = new THREE.Mesh(rxAntennaGeo, matCarbonFiber);
                rxAntenna.position.set(-0.15 + ra * 0.3, 0.12, -0.7);
                rxAntenna.rotation.x = -0.6 + ra * 0.15;
                rxAntenna.rotation.z = -0.3 + ra * 0.6;
                drone.add(rxAntenna);
            }

            /* ── Missiles attached to drone underside ── */
            const missiles = [];
            const missileSlots = [
                { x: -0.32, y: 0.12, z: 0.1 },
                { x: 0.32, y: 0.12, z: 0.1 },
            ];

            function createMissileModel() {
                const missile = new THREE.Group();

                // Body tube
                const bodyGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.55, 12);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x556655,
                    roughness: 0.4,
                    metalness: 0.6,
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                missile.add(body);

                // Nose cone
                const noseGeo = new THREE.ConeGeometry(0.035, 0.15, 12);
                const noseMat = new THREE.MeshStandardMaterial({
                    color: 0xcc3300,
                    roughness: 0.3,
                    metalness: 0.5,
                    emissive: 0x881100,
                    emissiveIntensity: 0.3,
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = 0.35;
                missile.add(nose);

                // Orange accent band
                const bandGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.03, 12);
                const bandMat = new THREE.MeshStandardMaterial({
                    color: 0xff6600,
                    roughness: 0.3,
                    metalness: 0.4,
                    emissive: 0xff4400,
                    emissiveIntensity: 0.3,
                });
                const band = new THREE.Mesh(bandGeo, bandMat);
                band.rotation.x = Math.PI / 2;
                band.position.z = 0.22;
                missile.add(band);

                // Rear nozzle
                const nozzleGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.06, 10);
                const nozzleMat = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.2,
                    metalness: 0.9,
                });
                const nozzle = new THREE.Mesh(nozzleGeo, nozzleMat);
                nozzle.rotation.x = Math.PI / 2;
                nozzle.position.z = -0.305;
                missile.add(nozzle);

                // 4 fins
                for (let f = 0; f < 4; f++) {
                    const finShape = new THREE.Shape();
                    finShape.moveTo(0, 0);
                    finShape.lineTo(0.08, 0);
                    finShape.lineTo(0.04, 0.12);
                    finShape.lineTo(0, 0.12);
                    const finGeo = new THREE.ExtrudeGeometry(finShape, {
                        depth: 0.005,
                        bevelEnabled: false,
                    });
                    const finMat = new THREE.MeshStandardMaterial({
                        color: 0x445544,
                        roughness: 0.5,
                        metalness: 0.5,
                    });
                    const fin = new THREE.Mesh(finGeo, finMat);
                    fin.rotation.y = (f * Math.PI) / 2;
                    fin.rotation.x = Math.PI / 2;
                    fin.position.z = -0.28;
                    fin.position.x = -0.0025;
                    fin.position.y = -0.0025;
                    missile.add(fin);
                }

                return missile;
            }

            missileSlots.forEach((slot, i) => {
                const m = createMissileModel();
                m.position.set(slot.x, slot.y, slot.z);
                // missiles point forward along drone's local Z
                m.scale.set(0.8, 0.8, 0.8);
                drone.add(m);
                missiles.push({ mesh: m, attached: true, slotIndex: i });
            });

            drone.scale.set(1.6, 1.6, 1.6);

            drone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return {
                group: drone,
                props: allProps,
                motorBells: allMotorBells,
                underglowLEDs,
                underglowLights,
                recLED,
                greenGlow,
                frontLEDs,
                missiles,
                missileSlots,
            };
        }

        const droneData = createDrone();
        const drone = droneData.group;
        drone.position.set(0, 1.8, 30);
        drone.rotation.order = 'YXZ';  // Apply yaw first so pitch/roll are in local frame
        scene.add(drone);

        /* ── Ammo Crate ── */
        function createAmmoCrate() {
            const group = new THREE.Group();

            // Box (4x larger)
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(10.0, 4.8, 6.0),
                new THREE.MeshStandardMaterial({ color: 0x3d4c3d, roughness: 0.8 })
            );
            box.position.y = 2.4;
            box.castShadow = true;
            box.receiveShadow = true;
            group.add(box);

            // Lid
            const lid = new THREE.Mesh(
                new THREE.BoxGeometry(10.4, 0.8, 6.4),
                new THREE.MeshStandardMaterial({ color: 0x2f3a2f, roughness: 0.9 })
            );
            lid.position.y = 5.0;
            lid.castShadow = true;
            lid.receiveShadow = true;
            group.add(lid);

            // Simple markings
            const markGeo = new THREE.PlaneGeometry(4.0, 1.6);
            const markMat = new THREE.MeshBasicMaterial({ color: 0xcccc00 });
            const mark = new THREE.Mesh(markGeo, markMat);
            mark.rotation.x = -Math.PI / 2;
            mark.position.y = 5.41;
            group.add(mark);

            return group;
        }

        const ammoCrate = createAmmoCrate();
        // Positioned in corner, adjusted for larger size
        ammoCrate.position.set(80, 0, 80);
        scene.add(ammoCrate);

        /* ══════════════════════════════════════════════
           ── Anti-Aircraft Truck with Missile Battery ──
           ══════════════════════════════════════════════ */

        function createAATruck() {
            const truck = new THREE.Group();

            // --- Materials ---
            const matOliveDrab = new THREE.MeshStandardMaterial({
                color: 0x4a5a2a, roughness: 0.8, metalness: 0.2,
            });
            const matDarkGreen = new THREE.MeshStandardMaterial({
                color: 0x2d3a1a, roughness: 0.7, metalness: 0.3,
            });
            const matMetal = new THREE.MeshStandardMaterial({
                color: 0x555555, roughness: 0.3, metalness: 0.9,
            });
            const matDarkMetal = new THREE.MeshStandardMaterial({
                color: 0x333333, roughness: 0.4, metalness: 0.8,
            });
            const matRubber = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a, roughness: 0.95, metalness: 0.0,
            });
            const matGlass = new THREE.MeshStandardMaterial({
                color: 0x88aacc, roughness: 0.0, metalness: 0.5,
                transparent: true, opacity: 0.5,
            });
            const matHeadlight = new THREE.MeshStandardMaterial({
                color: 0xffffdd, emissive: 0xffffaa, emissiveIntensity: 1.0,
                roughness: 0.1, metalness: 0.0,
            });
            const matRedLight = new THREE.MeshStandardMaterial({
                color: 0xff2200, emissive: 0xff2200, emissiveIntensity: 0.8,
                roughness: 0.2,
            });
            const matAmberLight = new THREE.MeshStandardMaterial({
                color: 0xff8800, emissive: 0xff6600, emissiveIntensity: 0.6,
                roughness: 0.2,
            });
            const matChrome = new THREE.MeshStandardMaterial({
                color: 0xdddddd, roughness: 0.1, metalness: 1.0,
                envMapIntensity: 2.5,
            });
            const matCamoLight = new THREE.MeshStandardMaterial({
                color: 0x6b7a3a, roughness: 0.85, metalness: 0.15,
            });
            const matCamoDark = new THREE.MeshStandardMaterial({
                color: 0x3a4a1a, roughness: 0.85, metalness: 0.15,
            });
            const matTan = new THREE.MeshStandardMaterial({
                color: 0x8a7a5a, roughness: 0.85, metalness: 0.15,
            });
            const matExhaust = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a, roughness: 0.6, metalness: 0.7,
            });

            // --- Heavy Steel Chassis / Frame Rails ---
            const chassisRailGeo = new THREE.BoxGeometry(0.25, 0.35, 8.4);
            for (let side = -1; side <= 1; side += 2) {
                const rail = new THREE.Mesh(chassisRailGeo, matDarkMetal);
                rail.position.set(side * 1.2, 0.68, 0);
                rail.castShadow = true;
                rail.receiveShadow = true;
                truck.add(rail);
            }
            // Cross members
            for (let cz = -3; cz <= 3; cz += 1.5) {
                const crossMember = new THREE.Mesh(
                    new THREE.BoxGeometry(2.6, 0.12, 0.2),
                    matDarkMetal
                );
                crossMember.position.set(0, 0.68, cz);
                truck.add(crossMember);
            }

            // --- Cab (more shaped) ---
            // Lower cab body
            const cabLower = new THREE.Mesh(
                new THREE.BoxGeometry(3.0, 1.4, 2.8),
                matOliveDrab
            );
            cabLower.position.set(0, 1.8, 2.4);
            cabLower.castShadow = true;
            cabLower.receiveShadow = true;
            truck.add(cabLower);

            // Upper cab (slightly narrower for realistic shape)
            const cabUpper = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 1.0, 2.6),
                matOliveDrab
            );
            cabUpper.position.set(0, 3.0, 2.4);
            cabUpper.castShadow = true;
            cabUpper.receiveShadow = true;
            truck.add(cabUpper);

            // Cab roof
            const cabRoof = new THREE.Mesh(
                new THREE.BoxGeometry(2.9, 0.12, 2.8),
                matDarkGreen
            );
            cabRoof.position.set(0, 3.56, 2.4);
            cabRoof.castShadow = true;
            truck.add(cabRoof);

            // --- Engine Hood (sloped) ---
            const hoodGeo = new THREE.BoxGeometry(2.8, 0.15, 1.2);
            const hood = new THREE.Mesh(hoodGeo, matCamoLight);
            hood.rotation.x = -0.15;
            hood.position.set(0, 2.0, 3.95);
            hood.castShadow = true;
            truck.add(hood);

            // Hood side panels
            for (let side = -1; side <= 1; side += 2) {
                const hoodSide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.7, 1.2),
                    matOliveDrab
                );
                hoodSide.position.set(side * 1.36, 1.7, 3.95);
                hoodSide.castShadow = true;
                truck.add(hoodSide);
            }

            // --- Front Grille ---
            const grilleFrame = new THREE.Mesh(
                new THREE.BoxGeometry(2.4, 1.0, 0.12),
                matDarkMetal
            );
            grilleFrame.position.set(0, 1.6, 4.56);
            truck.add(grilleFrame);

            // Grille horizontal slats
            for (let gs = 0; gs < 6; gs++) {
                const slat = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.04, 0.14),
                    matChrome
                );
                slat.position.set(0, 1.2 + gs * 0.14, 4.57);
                truck.add(slat);
            }

            // --- Windshield (angled) ---
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(2.4, 1.4),
                matGlass
            );
            windshield.rotation.x = -0.12;
            windshield.position.set(0, 2.9, 3.76);
            truck.add(windshield);

            // Windshield frame pillars
            for (let side = -1; side <= 1; side += 2) {
                const pillar = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 1.5, 0.08),
                    matDarkGreen
                );
                pillar.position.set(side * 1.25, 2.9, 3.72);
                truck.add(pillar);
            }

            // Center windshield divider
            const wsDivider = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 1.4, 0.06),
                matDarkGreen
            );
            wsDivider.position.set(0, 2.9, 3.74);
            truck.add(wsDivider);

            // --- Side windows ---
            for (let side = -1; side <= 1; side += 2) {
                const sideWin = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.8, 0.9),
                    matGlass
                );
                sideWin.rotation.y = side * Math.PI / 2;
                sideWin.position.set(side * 1.41, 2.9, 2.4);
                truck.add(sideWin);
            }

            // --- Side Mirrors ---
            for (let side = -1; side <= 1; side += 2) {
                const mirrorArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.06, 0.06),
                    matDarkMetal
                );
                mirrorArm.position.set(side * 1.7, 2.8, 3.2);
                truck.add(mirrorArm);

                const mirrorHead = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.35, 0.25),
                    matDarkMetal
                );
                mirrorHead.position.set(side * 1.95, 2.75, 3.2);
                truck.add(mirrorHead);

                const mirrorGlass = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.28, 0.18),
                    matGlass
                );
                mirrorGlass.rotation.y = side * Math.PI / 2;
                mirrorGlass.position.set(side * 2.0, 2.75, 3.2);
                truck.add(mirrorGlass);
            }

            // --- Headlights (recessed with bezels) ---
            for (let side = -1; side <= 1; side += 2) {
                // Headlight housing
                const hlHousing = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.12, 12),
                    matDarkMetal
                );
                hlHousing.rotation.x = Math.PI / 2;
                hlHousing.position.set(side * 1.0, 1.7, 4.56);
                truck.add(hlHousing);

                // Headlight lens
                const hl = new THREE.Mesh(
                    new THREE.CircleGeometry(0.22, 16),
                    matHeadlight
                );
                hl.position.set(side * 1.0, 1.7, 4.63);
                truck.add(hl);

                // Chrome bezel ring
                const hlBezel = new THREE.Mesh(
                    new THREE.TorusGeometry(0.24, 0.02, 6, 16),
                    matChrome
                );
                hlBezel.position.set(side * 1.0, 1.7, 4.62);
                truck.add(hlBezel);
            }

            // --- Turn signal / marker lights ---
            for (let side = -1; side <= 1; side += 2) {
                const turnSignal = new THREE.Mesh(
                    new THREE.BoxGeometry(0.18, 0.08, 0.05),
                    matAmberLight
                );
                turnSignal.position.set(side * 1.3, 1.35, 4.58);
                truck.add(turnSignal);
            }

            // --- Front Bumper (heavy duty) ---
            const bumper = new THREE.Mesh(
                new THREE.BoxGeometry(3.4, 0.4, 0.3),
                matChrome
            );
            bumper.position.set(0, 0.95, 4.55);
            bumper.castShadow = true;
            truck.add(bumper);

            // Tow hooks
            for (let side = -1; side <= 1; side += 2) {
                const towHook = new THREE.Mesh(
                    new THREE.TorusGeometry(0.1, 0.03, 6, 8, Math.PI),
                    matDarkMetal
                );
                towHook.rotation.z = Math.PI / 2;
                towHook.position.set(side * 1.3, 0.75, 4.6);
                truck.add(towHook);
            }

            // --- Tail lights (multi-element) ---
            for (let side = -1; side <= 1; side += 2) {
                // Tail light housing
                const tlHousing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.35, 0.08),
                    matDarkMetal
                );
                tlHousing.position.set(side * 1.3, 1.3, -4.04);
                truck.add(tlHousing);

                // Red brake light
                const tl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.15, 0.05),
                    matRedLight
                );
                tl.position.set(side * 1.3, 1.35, -4.09);
                truck.add(tl);

                // Amber turn signal
                const tlAmber = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.1, 0.05),
                    matAmberLight
                );
                tlAmber.position.set(side * 1.3, 1.2, -4.09);
                truck.add(tlAmber);
            }

            // --- Rear bumper ---
            const rearBumper = new THREE.Mesh(
                new THREE.BoxGeometry(3.4, 0.35, 0.25),
                matChrome
            );
            rearBumper.position.set(0, 0.85, -4.12);
            truck.add(rearBumper);

            // --- Flatbed (with reinforced floor) ---
            const flatbed = new THREE.Mesh(
                new THREE.BoxGeometry(3.0, 0.25, 5.0),
                matDarkGreen
            );
            flatbed.position.set(0, 1.25, -1.2);
            flatbed.castShadow = true;
            flatbed.receiveShadow = true;
            truck.add(flatbed);

            // Bed floor planks texture (cross boards)
            for (let bp = -2; bp <= 2; bp++) {
                const plank = new THREE.Mesh(
                    new THREE.BoxGeometry(2.9, 0.02, 0.08),
                    matCamoDark
                );
                plank.position.set(0, 1.39, -1.2 + bp * 1.0);
                truck.add(plank);
            }

            // Bed rails with vertical stakes
            for (let side = -1; side <= 1; side += 2) {
                // Horizontal rail
                const rail = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.7, 5.0),
                    matMetal
                );
                rail.position.set(side * 1.5, 1.75, -1.2);
                rail.castShadow = true;
                truck.add(rail);

                // Vertical stakes
                for (let si = -2; si <= 2; si++) {
                    const stake = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.8, 0.06),
                        matMetal
                    );
                    stake.position.set(side * 1.5, 1.8, -1.2 + si * 1.1);
                    truck.add(stake);
                }
            }

            // Rear rail
            const rearRail = new THREE.Mesh(
                new THREE.BoxGeometry(2.9, 0.7, 0.12),
                matMetal
            );
            rearRail.position.set(0, 1.75, -3.69);
            truck.add(rearRail);

            // --- Side Steps ---
            for (let side = -1; side <= 1; side += 2) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.06, 1.2),
                    matDarkMetal
                );
                step.position.set(side * 1.65, 0.7, 2.4);
                truck.add(step);

                // Step bracket
                const stepBracket = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.35, 0.08),
                    matMetal
                );
                stepBracket.position.set(side * 1.65, 0.85, 2.0);
                truck.add(stepBracket);
                const stepBracket2 = stepBracket.clone();
                stepBracket2.position.z = 2.8;
                truck.add(stepBracket2);
            }

            // --- Fender arches ---
            for (let side = -1; side <= 1; side += 2) {
                // Front fender
                const frontFender = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.5, 1.4),
                    matOliveDrab
                );
                frontFender.position.set(side * 1.65, 1.05, 3.0);
                frontFender.castShadow = true;
                truck.add(frontFender);

                // Front fender top
                const frontFenderTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.1, 1.4),
                    matOliveDrab
                );
                frontFenderTop.position.set(side * 1.42, 1.35, 3.0);
                truck.add(frontFenderTop);

                // Rear fenders (dual wheel area)
                const rearFender = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.5, 3.0),
                    matOliveDrab
                );
                rearFender.position.set(side * 1.65, 1.05, -2.2);
                rearFender.castShadow = true;
                truck.add(rearFender);

                const rearFenderTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.1, 3.0),
                    matOliveDrab
                );
                rearFenderTop.position.set(side * 1.42, 1.35, -2.2);
                truck.add(rearFenderTop);
            }

            // --- Mud Flaps ---
            for (let side = -1; side <= 1; side += 2) {
                // Front mud flap
                const fMudflap = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.35, 0.04),
                    matRubber
                );
                fMudflap.position.set(side * 1.5, 0.4, 2.3);
                truck.add(fMudflap);

                // Rear mud flap
                const rMudflap = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.35, 0.04),
                    matRubber
                );
                rMudflap.position.set(side * 1.5, 0.4, -3.8);
                truck.add(rMudflap);
            }

            // --- Exhaust Stack (vertical pipe on right side) ---
            const exhaustPipe = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 3.5, 8),
                matExhaust
            );
            exhaustPipe.position.set(1.6, 2.8, 1.0);
            truck.add(exhaustPipe);

            // Exhaust cap
            const exhaustCap = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.08, 0.15, 8),
                matExhaust
            );
            exhaustCap.position.set(1.6, 4.6, 1.0);
            truck.add(exhaustCap);

            // --- Fuel Tank (left side) ---
            const fuelTank = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35, 0.35, 1.6, 10),
                matDarkMetal
            );
            fuelTank.rotation.z = Math.PI / 2;
            fuelTank.position.set(-1.65, 0.85, 0.5);
            fuelTank.castShadow = true;
            truck.add(fuelTank);

            // Fuel tank end caps
            for (let fEnd = -1; fEnd <= 1; fEnd += 2) {
                const fuelCap = new THREE.Mesh(
                    new THREE.CircleGeometry(0.35, 10),
                    matDarkMetal
                );
                fuelCap.rotation.y = fEnd * Math.PI / 2;
                fuelCap.position.set(-1.65 + fEnd * 0.8, 0.85, 0.5);
                truck.add(fuelCap);
            }

            // Fuel filler cap
            const fillerCap = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.06, 0.06, 8),
                matChrome
            );
            fillerCap.position.set(-1.65, 1.2, 0.5);
            truck.add(fillerCap);

            // Fuel tank straps
            for (let fs = -1; fs <= 1; fs += 2) {
                const fuelStrap = new THREE.Mesh(
                    new THREE.TorusGeometry(0.36, 0.02, 6, 12, Math.PI),
                    matMetal
                );
                fuelStrap.rotation.z = Math.PI / 2;
                fuelStrap.rotation.y = Math.PI / 2;
                fuelStrap.position.set(-1.65, 0.85, 0.5 + fs * 0.5);
                truck.add(fuelStrap);
            }

            // --- External Toolbox (right side, behind cab) ---
            const toolbox = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.8),
                matDarkMetal
            );
            toolbox.position.set(1.6, 1.45, 0.6);
            toolbox.castShadow = true;
            truck.add(toolbox);

            // Toolbox latch
            const toolboxLatch = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.12, 0.06),
                matChrome
            );
            toolboxLatch.position.set(1.86, 1.5, 0.6);
            truck.add(toolboxLatch);

            // --- Roof Antenna ---
            const antennaBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.08, 8),
                matDarkMetal
            );
            antennaBase.position.set(0.8, 3.65, 2.0);
            truck.add(antennaBase);

            const antennaWhip = new THREE.Mesh(
                new THREE.CylinderGeometry(0.012, 0.008, 1.8, 6),
                matDarkMetal
            );
            antennaWhip.position.set(0.8, 4.55, 2.0);
            antennaWhip.rotation.z = 0.08;
            truck.add(antennaWhip);

            // --- Spare Tire (mounted under bed or at rear) ---
            const spareTire = new THREE.Mesh(
                new THREE.TorusGeometry(0.45, 0.18, 8, 16),
                matRubber
            );
            spareTire.rotation.x = Math.PI / 2;
            spareTire.position.set(0, 0.5, -3.5);
            truck.add(spareTire);

            const spareHub = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.2, 8),
                matMetal
            );
            spareHub.rotation.x = Math.PI / 2;
            spareHub.position.set(0, 0.5, -3.5);
            truck.add(spareHub);

            // --- Camo patches on cab ---
            const camoPatch1 = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 0.6),
                matCamoDark
            );
            camoPatch1.position.set(0.5, 2.5, 1.0);
            camoPatch1.rotation.y = Math.PI / 2;
            truck.add(camoPatch1);

            const camoPatch2 = new THREE.Mesh(
                new THREE.PlaneGeometry(1.0, 0.5),
                matTan
            );
            camoPatch2.position.set(-0.3, 2.0, 3.82);
            truck.add(camoPatch2);

            // --- Detailed Wheels (3 axles: 1 front, 2 rear) ---
            const wheelR = 0.5;
            const wheelW = 0.35;
            const wheelPositions = [
                // Front axle
                { x: 1.7, z: 3.0 }, { x: -1.7, z: 3.0 },
                // Mid axle
                { x: 1.7, z: -1.5 }, { x: -1.7, z: -1.5 },
                // Rear axle
                { x: 1.7, z: -3.2 }, { x: -1.7, z: -3.2 },
            ];

            wheelPositions.forEach(wp => {
                // Tire (with tread rings)
                const tireGeo = new THREE.TorusGeometry(wheelR, 0.18, 8, 20);
                const tire = new THREE.Mesh(tireGeo, matRubber);
                tire.rotation.y = Math.PI / 2;
                tire.position.set(wp.x, wheelR, wp.z);
                tire.castShadow = true;
                truck.add(tire);

                // Tread grooves
                for (let tg = 0; tg < 12; tg++) {
                    const grooveAngle = (tg / 12) * Math.PI * 2;
                    const grooveGeo = new THREE.BoxGeometry(0.04, 0.02, 0.38);
                    const groove = new THREE.Mesh(grooveGeo, matRubber);
                    groove.position.set(
                        wp.x,
                        wheelR + Math.sin(grooveAngle) * wheelR,
                        wp.z + Math.cos(grooveAngle) * wheelR
                    );
                    groove.rotation.x = grooveAngle;
                    truck.add(groove);
                }

                // Rim / Hub
                const rimGeo = new THREE.CylinderGeometry(0.32, 0.32, wheelW - 0.05, 12);
                const rim = new THREE.Mesh(rimGeo, matMetal);
                rim.rotation.z = Math.PI / 2;
                rim.position.set(wp.x, wheelR, wp.z);
                truck.add(rim);

                // Hub center cap
                const hubCap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.12, wheelW + 0.02, 10),
                    matChrome
                );
                hubCap.rotation.z = Math.PI / 2;
                hubCap.position.set(wp.x, wheelR, wp.z);
                truck.add(hubCap);

                // Lug bolts
                for (let lb = 0; lb < 6; lb++) {
                    const lugAngle = (lb / 6) * Math.PI * 2;
                    const lug = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.06, 6),
                        matChrome
                    );
                    lug.rotation.z = Math.PI / 2;
                    lug.position.set(
                        wp.x + (wp.x > 0 ? 0.19 : -0.19),
                        wheelR + Math.sin(lugAngle) * 0.2,
                        wp.z + Math.cos(lugAngle) * 0.2
                    );
                    truck.add(lug);
                }

                // Axle shaft visible between wheels
                if (wp.x > 0) {
                    const axle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.06, 3.4, 8),
                        matDarkMetal
                    );
                    axle.rotation.z = Math.PI / 2;
                    axle.position.set(0, wheelR, wp.z);
                    truck.add(axle);
                }
            });

            // --- Missile Launcher Turret (rotates to track drone) ---
            const turret = new THREE.Group();
            turret.position.set(0, 1.5, -1.2);

            // Turret base ring (larger, more solid)
            const turretBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.95, 1.05, 0.45, 20),
                matDarkMetal
            );
            turretBase.castShadow = true;
            turret.add(turretBase);

            // Base rotation ring detail
            const baseRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.0, 0.04, 6, 20),
                matMetal
            );
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = 0.22;
            turret.add(baseRing);

            // Rotating part
            const turretRotator = new THREE.Group();
            turretRotator.position.y = 0.3;

            // Turret housing (more shaped - trapezoidal)
            const turretHousingLower = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.5, 2.2),
                matOliveDrab
            );
            turretHousingLower.position.y = 0.25;
            turretHousingLower.castShadow = true;
            turretRotator.add(turretHousingLower);

            const turretHousingUpper = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.45, 1.8),
                matCamoLight
            );
            turretHousingUpper.position.y = 0.72;
            turretHousingUpper.castShadow = true;
            turretRotator.add(turretHousingUpper);

            // Turret access hatch
            const hatch = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25, 0.25, 0.06, 12),
                matDarkMetal
            );
            hatch.position.set(-0.4, 0.97, -0.5);
            turretRotator.add(hatch);

            // Hatch handle
            const hatchHandle = new THREE.Mesh(
                new THREE.BoxGeometry(0.18, 0.04, 0.04),
                matMetal
            );
            hatchHandle.position.set(-0.4, 1.02, -0.5);
            turretRotator.add(hatchHandle);

            // --- Cable Conduits along turret sides ---
            for (let side = -1; side <= 1; side += 2) {
                const conduit = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 1.8, 6),
                    matDarkMetal
                );
                conduit.rotation.x = Math.PI / 2;
                conduit.position.set(side * 0.85, 0.4, 0);
                turretRotator.add(conduit);

                // Conduit clamps
                for (let cc = -1; cc <= 1; cc++) {
                    const clamp = new THREE.Mesh(
                        new THREE.TorusGeometry(0.04, 0.01, 4, 8),
                        matMetal
                    );
                    clamp.position.set(side * 0.85, 0.4, cc * 0.6);
                    turretRotator.add(clamp);
                }
            }

            // Elevation arm
            const elevationArm = new THREE.Group();
            elevationArm.position.set(0, 0.9, 0);

            // --- Hydraulic Elevation Cylinders ---
            for (let side = -1; side <= 1; side += 2) {
                // Outer cylinder
                const hydCylinder = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.06, 1.2, 8),
                    matChrome
                );
                hydCylinder.rotation.x = Math.PI / 4;
                hydCylinder.position.set(side * 0.7, -0.2, -0.6);
                turretRotator.add(hydCylinder);

                // Inner piston rod
                const hydPiston = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.035, 0.035, 0.8, 8),
                    matChrome
                );
                hydPiston.rotation.x = Math.PI / 4;
                hydPiston.position.set(side * 0.7, 0.2, -0.2);
                turretRotator.add(hydPiston);

                // Pivot mount
                const pivot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    matDarkMetal
                );
                pivot.position.set(side * 0.7, -0.55, -0.95);
                turretRotator.add(pivot);
            }

            // 4-tube launcher rack (2x2 grid)
            const launcherRack = new THREE.Group();
            const tubeRadius = 0.22;
            const tubeLength = 3.8;
            const tubePositions = [
                { x: -0.38, y: 0.38 },
                { x: 0.38, y: 0.38 },
                { x: -0.38, y: -0.38 },
                { x: 0.38, y: -0.38 },
            ];

            tubePositions.forEach((tp, ti) => {
                // Outer tube shell
                const tube = new THREE.Mesh(
                    new THREE.CylinderGeometry(tubeRadius, tubeRadius, tubeLength, 12, 1, true),
                    matDarkGreen
                );
                tube.rotation.x = Math.PI / 2;
                tube.position.set(tp.x, tp.y, tubeLength / 2 - 0.5);
                tube.castShadow = true;
                launcherRack.add(tube);

                // Inner tube lining (slightly darker)
                const innerTube = new THREE.Mesh(
                    new THREE.CylinderGeometry(tubeRadius - 0.02, tubeRadius - 0.02, tubeLength - 0.1, 10, 1, true),
                    matDarkMetal
                );
                innerTube.rotation.x = Math.PI / 2;
                innerTube.position.set(tp.x, tp.y, tubeLength / 2 - 0.5);
                launcherRack.add(innerTube);

                // Tube cap ring at front (reinforced)
                const capRing = new THREE.Mesh(
                    new THREE.TorusGeometry(tubeRadius, 0.03, 8, 14),
                    matMetal
                );
                capRing.position.set(tp.x, tp.y, tubeLength - 0.5);
                launcherRack.add(capRing);

                // Tube cap ring at rear
                const rearRing = new THREE.Mesh(
                    new THREE.TorusGeometry(tubeRadius, 0.03, 8, 14),
                    matMetal
                );
                rearRing.position.set(tp.x, tp.y, -0.5);
                launcherRack.add(rearRing);

                // Blast deflector lip at rear of tube
                const blastDeflector = new THREE.Mesh(
                    new THREE.CylinderGeometry(tubeRadius + 0.05, tubeRadius, 0.15, 12, 1, true),
                    matDarkMetal
                );
                blastDeflector.rotation.x = Math.PI / 2;
                blastDeflector.position.set(tp.x, tp.y, -0.55);
                launcherRack.add(blastDeflector);

                // Ammo status indicator on side of each tube
                const indicatorLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 6, 6),
                    new THREE.MeshStandardMaterial({
                        color: 0x00ff44, emissive: 0x00ff44,
                        emissiveIntensity: 2.0, roughness: 0.1,
                    })
                );
                indicatorLight.position.set(
                    tp.x + (tp.x > 0 ? 0.25 : -0.25),
                    tp.y,
                    tubeLength * 0.7
                );
                launcherRack.add(indicatorLight);

                // Tube number stencil (small marking)
                const tubeLabel = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.1, 0.08),
                    new THREE.MeshBasicMaterial({ color: 0xcccc88 })
                );
                tubeLabel.position.set(tp.x, tp.y - tubeRadius - 0.01, tubeLength * 0.4);
                tubeLabel.rotation.x = -Math.PI / 2;
                launcherRack.add(tubeLabel);
            });

            // Cross brace between tubes (beefier)
            const braceGeo = new THREE.BoxGeometry(1.4, 0.1, 0.1);
            const brace1 = new THREE.Mesh(braceGeo, matMetal);
            brace1.position.set(0, 0, 0.5);
            launcherRack.add(brace1);
            const brace2 = new THREE.Mesh(braceGeo.clone(), matMetal);
            brace2.position.set(0, 0, 2.0);
            launcherRack.add(brace2);
            const brace3 = new THREE.Mesh(braceGeo.clone(), matMetal);
            brace3.position.set(0, 0, tubeLength - 1.0);
            launcherRack.add(brace3);

            // Vertical braces
            const vBraceGeo = new THREE.BoxGeometry(0.1, 1.4, 0.1);
            const vBrace1 = new THREE.Mesh(vBraceGeo, matMetal);
            vBrace1.position.set(0, 0, 0.5);
            launcherRack.add(vBrace1);
            const vBrace2 = new THREE.Mesh(vBraceGeo.clone(), matMetal);
            vBrace2.position.set(0, 0, 2.0);
            launcherRack.add(vBrace2);
            const vBrace3 = new THREE.Mesh(vBraceGeo.clone(), matMetal);
            vBrace3.position.set(0, 0, tubeLength - 1.0);
            launcherRack.add(vBrace3);

            // Diagonal support struts
            for (let ds = 0; ds < 2; ds++) {
                const diagStrut = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.05, 2.0),
                    matMetal
                );
                diagStrut.rotation.y = ds === 0 ? 0.3 : -0.3;
                diagStrut.position.set(ds === 0 ? 0.5 : -0.5, 0, 1.2);
                launcherRack.add(diagStrut);
            }

            elevationArm.add(launcherRack);
            turretRotator.add(elevationArm);

            // --- Radar Dish (mounted on turret side) ---
            const radarGroup = new THREE.Group();
            radarGroup.position.set(0.95, 0.9, -0.3);

            const radarDish = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                matMetal
            );
            radarDish.rotation.x = Math.PI / 2;
            radarGroup.add(radarDish);

            const radarFeed = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6),
                matDarkMetal
            );
            radarFeed.position.set(0, 0, 0.2);
            radarFeed.rotation.x = Math.PI / 2;
            radarGroup.add(radarFeed);

            const radarFeedHead = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.03, 0.08, 6),
                matDarkMetal
            );
            radarFeedHead.position.set(0, 0, 0.35);
            radarFeedHead.rotation.x = Math.PI / 2;
            radarGroup.add(radarFeedHead);

            // Radar mount arm
            const radarArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.5, 0.06),
                matMetal
            );
            radarArm.position.set(0, -0.3, 0);
            radarGroup.add(radarArm);

            turretRotator.add(radarGroup);

            // --- Multi-Optics Sighting System ---
            const sightGroup = new THREE.Group();
            sightGroup.position.set(0, 1.1, -0.5);

            // Main sight housing
            const sightHousing = new THREE.Mesh(
                new THREE.BoxGeometry(0.35, 0.35, 0.5),
                matDarkMetal
            );
            sightGroup.add(sightHousing);

            // Primary targeting lens (red)
            const sightLens = new THREE.Mesh(
                new THREE.CircleGeometry(0.1, 14),
                new THREE.MeshStandardMaterial({
                    color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2.0,
                    roughness: 0.0,
                })
            );
            sightLens.position.set(0, 0.05, 0.26);
            sightGroup.add(sightLens);

            // Lens bezel
            const sightBezel = new THREE.Mesh(
                new THREE.TorusGeometry(0.11, 0.015, 6, 14),
                matChrome
            );
            sightBezel.position.set(0, 0.05, 0.25);
            sightGroup.add(sightBezel);

            // Secondary IR sensor (smaller, below main lens)
            const irSensor = new THREE.Mesh(
                new THREE.CircleGeometry(0.05, 10),
                new THREE.MeshStandardMaterial({
                    color: 0x220000, emissive: 0x440000, emissiveIntensity: 1.0,
                    roughness: 0.0,
                })
            );
            irSensor.position.set(0, -0.1, 0.26);
            sightGroup.add(irSensor);

            // IR sensor bezel
            const irBezel = new THREE.Mesh(
                new THREE.TorusGeometry(0.055, 0.01, 6, 10),
                matMetal
            );
            irBezel.position.set(0, -0.1, 0.25);
            sightGroup.add(irBezel);

            // Laser rangefinder (small box on top)
            const laserRangefinder = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 0.08, 0.15),
                matDarkMetal
            );
            laserRangefinder.position.set(0, 0.22, -0.1);
            sightGroup.add(laserRangefinder);

            const laserAperture = new THREE.Mesh(
                new THREE.CircleGeometry(0.025, 8),
                new THREE.MeshStandardMaterial({
                    color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.5,
                    roughness: 0.0,
                })
            );
            laserAperture.position.set(0, 0.22, 0.0);
            sightGroup.add(laserAperture);

            turretRotator.add(sightGroup);

            turret.add(turretRotator);
            truck.add(turret);

            truck.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return {
                group: truck,
                turretRotator,
                elevationArm,
                sightLens,
                radarGroup,
            };
        }

        /* ── Enemy Missile System Constants ── */
        const ENEMY_FIRE_INTERVAL = 5.0;  // seconds between shots
        const ENEMY_MISSILE_SPEED = 18.0; // units per second (straight line)
        const ENEMY_MISSILE_MAX_RANGE = 250;
        const BLAST_RADIUS = 4.0;  // how close a missile must be to destroy drone
        const TRUCK_HIT_RADIUS = 8.0; // how close a drone missile must land to damage the truck
        const TRUCK_MAX_HP = 3;

        const trucks = [];
        let totalTrucksSpawned = 0;

        function spawnTruck(x, z) {
            const data = createAATruck();
            data.group.position.set(x, 0, z);
            data.group.scale.set(1.2, 1.2, 1.2);
            data.hp = TRUCK_MAX_HP;
            data.destroyed = false;
            data.fireTimer = Math.random() * ENEMY_FIRE_INTERVAL; // Stagger firing
            data.currentTubeIndex = 0;
            scene.add(data.group);
            trucks.push(data);
            totalTrucksSpawned++;
            return data;
        }

        // Initial truck spawn
        spawnTruck(0, 0);

        /* ── Enemy Missile System State ── */
        const enemyMissiles = [];
        let gameOver = false;
        let surviveTime = 0; // Keeping variable as it might be used for logic, but removing UI update

        const gameOverOverlay = document.getElementById('game-over-overlay');
        const restartBtn = document.getElementById('restart-btn');
        const warningText = document.getElementById('warning-text');

        function createEnemyMissile() {
            const missile = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.12, 0.15, 2.0, 10);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x556655, roughness: 0.4, metalness: 0.6,
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            missile.add(body);

            // Nose cone
            const noseGeo = new THREE.ConeGeometry(0.12, 0.5, 10);
            const noseMat = new THREE.MeshStandardMaterial({
                color: 0xcc3300, roughness: 0.3, metalness: 0.5,
                emissive: 0x881100, emissiveIntensity: 0.3,
            });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.rotation.x = -Math.PI / 2;
            nose.position.z = 1.25;
            missile.add(nose);

            // Band
            const bandGeo = new THREE.CylinderGeometry(0.16, 0.16, 0.08, 10);
            const bandMat = new THREE.MeshStandardMaterial({
                color: 0xff6600, roughness: 0.3, metalness: 0.4,
                emissive: 0xff4400, emissiveIntensity: 0.3,
            });
            const band = new THREE.Mesh(bandGeo, bandMat);
            band.rotation.x = Math.PI / 2;
            band.position.z = 0.7;
            missile.add(band);

            // Nozzle
            const nozzleGeo = new THREE.CylinderGeometry(0.1, 0.14, 0.2, 8);
            const nozzleMat = new THREE.MeshStandardMaterial({
                color: 0x222222, roughness: 0.2, metalness: 0.9,
            });
            const nozzle = new THREE.Mesh(nozzleGeo, nozzleMat);
            nozzle.rotation.x = Math.PI / 2;
            nozzle.position.z = -1.1;
            missile.add(nozzle);

            // Exhaust flame
            const flameGeo = new THREE.ConeGeometry(0.1, 0.8, 8);
            const flameMat = new THREE.MeshBasicMaterial({
                color: 0xff8800, transparent: true, opacity: 0.7,
                blending: THREE.AdditiveBlending,
            });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.rotation.x = Math.PI / 2;
            flame.position.z = -1.5;
            missile.add(flame);

            // Fins
            for (let f = 0; f < 4; f++) {
                const finShape = new THREE.Shape();
                finShape.moveTo(0, 0);
                finShape.lineTo(0.25, 0);
                finShape.lineTo(0.12, 0.4);
                finShape.lineTo(0, 0.4);
                const finGeo = new THREE.ExtrudeGeometry(finShape, {
                    depth: 0.015, bevelEnabled: false,
                });
                const finMat = new THREE.MeshStandardMaterial({
                    color: 0x445544, roughness: 0.5, metalness: 0.5,
                });
                const fin = new THREE.Mesh(finGeo, finMat);
                fin.rotation.y = (f * Math.PI) / 2;
                fin.rotation.x = Math.PI / 2;
                fin.position.z = -1.0;
                fin.position.x = -0.0075;
                fin.position.y = -0.0075;
                missile.add(fin);
            }

            missile.traverse(c => { if (c.isMesh) { c.castShadow = true; } });
            return { group: missile, flame };
        }

        function fireEnemyMissile(truckData) {
            if (gameOver || truckData.destroyed) return;

            // Get the turret world position (origin of launchers)
            const turretWorldPos = new THREE.Vector3();
            truckData.turretRotator.getWorldPosition(turretWorldPos);

            // Direction toward drone
            const targetPos = drone.position.clone();
            const direction = new THREE.Vector3().subVectors(targetPos, turretWorldPos).normalize();

            // Create the missile
            const missileData = createEnemyMissile();
            const missile = missileData.group;

            // Start at turret position offset forward
            const startPos = turretWorldPos.clone().add(direction.clone().multiplyScalar(3.0));
            missile.position.copy(startPos);
            missile.lookAt(targetPos);
            missile.scale.set(0.8, 0.8, 0.8);
            scene.add(missile);

            // Smoke trail
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(500 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeo.setDrawRange(0, 0);
            const trailMat = new THREE.PointsMaterial({
                color: 0xaaaaaa, size: 0.25,
                transparent: true, opacity: 0.5, depthWrite: false,
            });
            const trail = new THREE.Points(trailGeo, trailMat);
            scene.add(trail);

            enemyMissiles.push({
                mesh: missile,
                flame: missileData.flame,
                direction: direction.clone(),
                startPos: startPos.clone(),
                distanceTraveled: 0,
                trail, trailIndex: 0,
            });

            truckData.currentTubeIndex = (truckData.currentTubeIndex + 1) % 4;

            // Flash warning
            warningText.style.opacity = '1';
            setTimeout(() => { warningText.style.opacity = '0'; }, 1500);
        }

        function gameOverHandler() {
            if (gameOver) return;
            gameOver = true;
            gameOverOverlay.classList.add('active');

            // Create explosion at drone position
            createExplosion(drone.position.clone());
            drone.visible = false;
        }

        function destroyTruck(truckData) {
            truckData.destroyed = true;
            // Big explosion at truck
            createExplosion(truckData.group.position.clone());
            createExplosion(truckData.group.position.clone().add(new THREE.Vector3(2, 1, 0)));
            createExplosion(truckData.group.position.clone().add(new THREE.Vector3(-1, 2, 1)));
            truckData.group.visible = false;

            // Spawn 2 more after 10 seconds, but ONLY if this was the first truck (totalSpawned == 1)
            if (totalTrucksSpawned === 1) {
                setTimeout(() => {
                    // Spawn one to the left and one to the right, or somewhere else
                    const spawnDist = 40 + Math.random() * 40;
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = angle1 + Math.PI + (Math.random() - 0.5) * 1.0;

                    spawnTruck(Math.cos(angle1) * spawnDist, Math.sin(angle1) * spawnDist);
                    spawnTruck(Math.cos(angle2) * spawnDist, Math.sin(angle2) * spawnDist);
                }, 10000);
            }

            // Clean up any remaining enemy missiles if NO active trucks remains? 
            // Or just leave them? Usually they should keep flying.
            // If all trucks are destroyed, we could clear them, but reinforcements are coming.
            const anyTrucksLeft = trucks.some(t => !t.destroyed);
            if (!anyTrucksLeft) {
                // Option: clear missiles? Or just let them fly to target.
            }
        }

        function restartGame() {
            gameOver = false;
            gameOverOverlay.classList.remove('active');
            drone.visible = true;
            drone.position.set(0, 1.8, 30);
            baseHeight = 1.8;
            droneYaw = Math.PI;
            cameraYaw = droneYaw;
            currentVelocity.set(0, 0, 0);
            smoothInput.set(0, 0);
            smoothLeft.set(0, 0);
            surviveTime = 0;

            // Restore truck
            // Clean up existing trucks
            trucks.forEach(t => {
                scene.remove(t.group);
                // Dispose geometries/materials if needed, but for restart simple remove is okay
            });
            trucks.length = 0;
            totalTrucksSpawned = 0; // Reset counter
            spawnTruck(0, 0);

            // Clean up enemy missiles
            for (let i = enemyMissiles.length - 1; i >= 0; i--) {
                scene.remove(enemyMissiles[i].mesh);
                scene.remove(enemyMissiles[i].trail);
                enemyMissiles[i].trail.geometry.dispose();
                enemyMissiles[i].trail.material.dispose();
            }
            enemyMissiles.length = 0;

            // Reload drone missiles
            droneData.missiles.forEach(slot => {
                if (!slot.attached) {
                    respawnMissile(slot);
                }
            });
        }

        restartBtn.addEventListener('click', restartGame);

        /* ── Missile Launch System ── */
        const activeMissiles = [];     // in-flight missiles
        const explosions = [];         // active explosion particle systems
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let missileReloadTimer = 0;

        function launchMissile(targetPoint) {
            // Find an attached missile
            const slot = droneData.missiles.find(m => m.attached);
            if (!slot) return;

            slot.attached = false;

            // Get the missile's world position before detaching
            const worldPos = new THREE.Vector3();
            slot.mesh.getWorldPosition(worldPos);
            const worldQuat = new THREE.Quaternion();
            slot.mesh.getWorldQuaternion(worldQuat);

            // Remove from drone, add to scene
            drone.remove(slot.mesh);
            slot.mesh.position.copy(worldPos);
            slot.mesh.quaternion.copy(worldQuat);
            slot.mesh.scale.set(1.28, 1.28, 1.28); // 0.8 * 1.6 drone scale
            scene.add(slot.mesh);

            // Direction and flight params
            const direction = new THREE.Vector3().subVectors(targetPoint, worldPos);
            const totalDist = direction.length();
            const flightDuration = Math.min(Math.max(totalDist / 18, 0.4), 3.0);

            activeMissiles.push({
                mesh: slot.mesh,
                slotData: slot,
                startPos: worldPos.clone(),
                targetPos: targetPoint.clone(),
                elapsed: 0,
                duration: flightDuration,
                arcHeight: Math.max(totalDist * 0.15, 1.0),
            });

            // Create a smoke trail
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(300 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeo.setDrawRange(0, 0);
            const trailMat = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 0.15,
                transparent: true,
                opacity: 0.5,
                depthWrite: false,
            });
            const trail = new THREE.Points(trailGeo, trailMat);
            scene.add(trail);
            activeMissiles[activeMissiles.length - 1].trail = trail;
            activeMissiles[activeMissiles.length - 1].trailIndex = 0;
        }

        function createExplosion(position) {
            const particleCount = 40;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const fireColors = [
                new THREE.Color(0xff4400),
                new THREE.Color(0xff8800),
                new THREE.Color(0xffcc00),
                new THREE.Color(0xff2200),
                new THREE.Color(0xffaa00),
            ];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y + 0.1;
                positions[i * 3 + 2] = position.z;

                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 3 + Math.random() * 8;
                velocities.push({
                    x: Math.sin(phi) * Math.cos(theta) * speed,
                    y: Math.abs(Math.cos(phi)) * speed * 1.2 + 2,
                    z: Math.sin(phi) * Math.sin(theta) * speed,
                });

                const c = fireColors[Math.floor(Math.random() * fireColors.length)];
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;

                sizes[i] = 0.2 + Math.random() * 0.5;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            const particles = new THREE.Points(geo, mat);
            scene.add(particles);

            // Explosion flash light
            const flash = new THREE.PointLight(0xff6600, 20, 15);
            flash.position.copy(position);
            flash.position.y += 0.5;
            scene.add(flash);

            // Shockwave ring
            const ringGeo = new THREE.RingGeometry(0.1, 0.3, 16);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.position.y += 0.05;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);

            // Smoke cloud (secondary particles)
            const smokeCount = 15;
            const smokeGeo = new THREE.BufferGeometry();
            const smokePos = new Float32Array(smokeCount * 3);
            const smokeVels = [];
            for (let i = 0; i < smokeCount; i++) {
                smokePos[i * 3] = position.x;
                smokePos[i * 3 + 1] = position.y + 0.3;
                smokePos[i * 3 + 2] = position.z;
                const theta = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                smokeVels.push({
                    x: Math.cos(theta) * speed,
                    y: 1 + Math.random() * 3,
                    z: Math.sin(theta) * speed,
                });
            }
            smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
            const smokeMat = new THREE.PointsMaterial({
                color: 0x444444,
                size: 0.8,
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
            });
            const smokeParticles = new THREE.Points(smokeGeo, smokeMat);
            scene.add(smokeParticles);

            explosions.push({
                particles, velocities, mat,
                flash, ring, ringMat,
                smokeParticles, smokeVels, smokeMat,
                elapsed: 0,
                duration: 2.0,
            });
        }

        function respawnMissile(slotData) {
            const slot = droneData.missileSlots[slotData.slotIndex];
            // Do not remove old mesh here, as it might be currently flying (activeMissile)
            // scene.remove(slotData.mesh); 

            // Create a fresh missile and re-attach
            const freshGroup = new THREE.Group();

            // Re-build missile body pieces
            const bodyGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.55, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x556655, roughness: 0.4, metalness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            freshGroup.add(body);

            const noseGeo = new THREE.ConeGeometry(0.035, 0.15, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xcc3300, roughness: 0.3, metalness: 0.5, emissive: 0x881100, emissiveIntensity: 0.3 });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.rotation.x = -Math.PI / 2;
            nose.position.z = 0.35;
            freshGroup.add(nose);

            const bandGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.03, 12);
            const bandMat = new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.3, metalness: 0.4, emissive: 0xff4400, emissiveIntensity: 0.3 });
            const band = new THREE.Mesh(bandGeo, bandMat);
            band.rotation.x = Math.PI / 2;
            band.position.z = 0.22;
            freshGroup.add(band);

            const nozzleGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.06, 10);
            const nozzleMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.9 });
            const nozzle = new THREE.Mesh(nozzleGeo, nozzleMat);
            nozzle.rotation.x = Math.PI / 2;
            nozzle.position.z = -0.305;
            freshGroup.add(nozzle);

            for (let f = 0; f < 4; f++) {
                const finShape = new THREE.Shape();
                finShape.moveTo(0, 0);
                finShape.lineTo(0.08, 0);
                finShape.lineTo(0.04, 0.12);
                finShape.lineTo(0, 0.12);
                const finGeo = new THREE.ExtrudeGeometry(finShape, { depth: 0.005, bevelEnabled: false });
                const finMat = new THREE.MeshStandardMaterial({ color: 0x445544, roughness: 0.5, metalness: 0.5 });
                const fin = new THREE.Mesh(finGeo, finMat);
                fin.rotation.y = (f * Math.PI) / 2;
                fin.rotation.x = Math.PI / 2;
                fin.position.z = -0.28;
                fin.position.x = -0.0025;
                fin.position.y = -0.0025;
                freshGroup.add(fin);
            }

            freshGroup.position.set(slot.x, slot.y, slot.z);
            // freshGroup.rotation.x = -Math.PI / 2; // REMOVED: Match initial orientation
            freshGroup.scale.set(0.8, 0.8, 0.8);
            drone.add(freshGroup);

            freshGroup.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            slotData.mesh = freshGroup;
            slotData.attached = true;
        }

        // Click/tap handler — only fires on the ground plane
        function onPointerDown(event) {
            // Ignore if clicking joystick zones
            const target = event.target;
            if (target && target.closest && (target.closest('.joystick-zone') || target.closest('.joystick-knob'))) return;

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                launchMissile(intersects[0].point);
            }
        }

        // Use pointerdown to handle both mouse and touch without double-firing
        renderer.domElement.addEventListener('pointerdown', onPointerDown);


        /* ── Joystick Helper Factory ── */
        function createJoystickController(zoneId, knobId) {
            const zone = document.getElementById(zoneId);
            const knob = document.getElementById(knobId);
            const joySize = 120;
            const knobSize = 40;
            const maxDist = (joySize - knobSize) / 2;
            const state = { x: 0, y: 0 };
            let dragging = false;
            let startX, startY;
            let activeTouchId = null;

            const update = (dx, dy) => {
                const dist = Math.sqrt(dx * dx + dy * dy);
                let cx = dx, cy = dy;
                if (dist > maxDist) {
                    const a = Math.atan2(dy, dx);
                    cx = Math.cos(a) * maxDist;
                    cy = Math.sin(a) * maxDist;
                }
                knob.style.transform = `translate(${cx}px, ${cy}px)`;
                state.x = cx / maxDist;
                state.y = cy / maxDist;
            };

            const reset = () => {
                dragging = false;
                activeTouchId = null;
                state.x = 0;
                state.y = 0;
                knob.style.transform = `translate(0px, 0px)`;
            };

            /* Mouse events */
            zone.addEventListener('mousedown', (e) => {
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mouseup', () => { if (dragging) reset(); });

            /* Touch events – track a specific touch ID so both sticks work independently */
            zone.addEventListener('touchstart', (e) => {
                if (activeTouchId !== null) return; // already tracking
                const touch = e.changedTouches[0];
                activeTouchId = touch.identifier;
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(touch.clientX - startX, touch.clientY - startY);
            }, { passive: true });

            window.addEventListener('touchmove', (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        const t = e.changedTouches[i];
                        update(t.clientX - startX, t.clientY - startY);
                        break;
                    }
                }
            }, { passive: true });

            const touchEnd = (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        reset();
                        break;
                    }
                }
            };
            window.addEventListener('touchend', touchEnd);
            window.addEventListener('touchcancel', touchEnd);

            return state;
        }

        /* Right stick  → forward / backward / strafe */
        const inputVector = createJoystickController('joystick-zone-right', 'joystick-knob-right');
        /* Left stick   → yaw (x) & altitude (y) */
        const inputLeft = createJoystickController('joystick-zone-left', 'joystick-knob-left');

        /* ── Keyboard input (WASD = left stick, Arrows = right stick) ── */
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function getKeyboardInput() {
            // WASD → left stick (A/D = yaw X, W/S = altitude Y)
            let leftX = 0, leftY = 0;
            if (keys['KeyA']) leftX -= 1;
            if (keys['KeyD']) leftX += 1;
            if (keys['KeyW']) leftY -= 1;   // W = up (stick up = negative Y)
            if (keys['KeyS']) leftY += 1;   // S = down

            // Arrow keys → right stick (Left/Right = strafe X, Up/Down = fwd/back Y)
            let rightX = 0, rightY = 0;
            if (keys['ArrowLeft']) rightX -= 1;
            if (keys['ArrowRight']) rightX += 1;
            if (keys['ArrowUp']) rightY -= 1;   // forward = stick up = negative Y
            if (keys['ArrowDown']) rightY += 1;

            return { leftX, leftY, rightX, rightY };
        }

        const clock = new THREE.Clock();
        let lastTime = 0;

        /* ── FPS Counter ── */
        const fpsEl = document.getElementById('fps-counter');
        let fpsFrames = 0;
        let fpsAccum = 0;

        /* ── Trail fade list (replaces setInterval) ── */
        const fadingTrails = [];
        const droneSpeed = 0.28;
        const yawSpeed = 0.04;      // radians per frame at full deflection
        const altSpeed = 0.08;      // units per frame at full deflection
        const smoothInput = new THREE.Vector2();   // right stick smoothed
        const smoothLeft = new THREE.Vector2();   // left stick smoothed
        const currentVelocity = new THREE.Vector3();

        let baseHeight = 1.8;
        let droneYaw = Math.PI;     // current heading (initial = facing camera)
        let cameraYaw = droneYaw;   // smoothed camera heading that follows drone yaw
        const camDist = 14;         // how far behind the drone the camera orbits
        const camHeight = 6;        // camera height offset above drone


        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const dt = Math.min(t - lastTime, 0.05);
            lastTime = t;

            /* ── FPS Counter update ── */
            fpsFrames++;
            fpsAccum += dt;
            if (fpsAccum >= 0.5) {
                const fps = Math.round(fpsFrames / fpsAccum);
                fpsEl.textContent = `FPS: ${fps}`;
                fpsEl.style.color = fps >= 50 ? '#0f0' : fps >= 30 ? '#ff0' : '#f33';
                fpsFrames = 0;
                fpsAccum = 0;
            }

            if (grassMat.userData.shader) {
                grassMat.userData.shader.uniforms.uTime.value = t;
                grassMat.userData.shader.uniforms.uDronePos.value.copy(drone.position);
            }

            /* ── Blend keyboard + joystick, then smooth ── */
            const kb = getKeyboardInput();
            // Clamp combined input to [-1, 1]
            const clamp = (v) => Math.max(-1, Math.min(1, v));
            const combinedRightX = clamp(inputVector.x + kb.rightX);
            const combinedRightY = clamp(inputVector.y + kb.rightY);
            const combinedLeftX = clamp(inputLeft.x + kb.leftX);
            const combinedLeftY = clamp(inputLeft.y + kb.leftY);

            smoothInput.x = THREE.MathUtils.lerp(smoothInput.x, combinedRightX, 0.06);
            smoothInput.y = THREE.MathUtils.lerp(smoothInput.y, combinedRightY, 0.06);
            smoothLeft.x = THREE.MathUtils.lerp(smoothLeft.x, combinedLeftX, 0.08);
            smoothLeft.y = THREE.MathUtils.lerp(smoothLeft.y, combinedLeftY, 0.08);

            /* ── Left stick: yaw & altitude ── */
            droneYaw -= smoothLeft.x * yawSpeed;            // left → positive yaw
            baseHeight -= smoothLeft.y * altSpeed;           // stick up (negative y) → go up
            baseHeight = Math.max(0.4, baseHeight);          // clamp above ground

            /* ── Right stick: movement in the drone's local heading ── */
            const sinY = Math.sin(droneYaw);
            const cosY = Math.cos(droneYaw);
            // forward/back from stick Y, strafe from stick X – glide to a stop
            const targetVelX = (-smoothInput.x * cosY - smoothInput.y * sinY) * droneSpeed;
            const targetVelZ = (smoothInput.x * sinY - smoothInput.y * cosY) * droneSpeed;
            currentVelocity.x = THREE.MathUtils.lerp(currentVelocity.x, targetVelX, 0.02);
            currentVelocity.z = THREE.MathUtils.lerp(currentVelocity.z, targetVelZ, 0.02);

            drone.position.x += currentVelocity.x;
            drone.position.z += currentVelocity.z;

            /* ── Ammo Crate collision & landing ── */
            // Crate AABB: centered at (80,0,80), box 10 wide (X), 6 deep (Z), lid top at y=5.4
            const crateHalfW = 5.2;   // half-width X (with small margin)
            const crateHalfD = 3.2;   // half-depth Z (with small margin)
            const crateTopY = 5.4;   // top of the lid
            const cx = ammoCrate.position.x;
            const cz = ammoCrate.position.z;
            const onCrateXZ = (drone.position.x > cx - crateHalfW && drone.position.x < cx + crateHalfW &&
                drone.position.z > cz - crateHalfD && drone.position.z < cz + crateHalfD);

            // If the drone is above the crate footprint, enforce the crate top as a floor
            if (onCrateXZ) {
                const minAboveCrate = crateTopY + 0.4; // small offset so drone sits on lid
                if (baseHeight < minAboveCrate) {
                    baseHeight = minAboveCrate;
                }
            }

            // Reload missiles when landed on the crate (touching lid surface)
            const landedOnCrate = onCrateXZ && baseHeight <= crateTopY + 0.5;
            if (landedOnCrate) {
                droneData.missiles.forEach(slot => {
                    if (!slot.attached) {
                        respawnMissile(slot);
                    }
                });
            }

            // Clamp drone inside fence boundary
            const FENCE_LIMIT = FENCE_HALF - 1.5;
            if (drone.position.x > FENCE_LIMIT) { drone.position.x = FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.x < -FENCE_LIMIT) { drone.position.x = -FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.z > FENCE_LIMIT) { drone.position.z = FENCE_LIMIT; currentVelocity.z = 0; }
            if (drone.position.z < -FENCE_LIMIT) { drone.position.z = -FENCE_LIMIT; currentVelocity.z = 0; }

            /* ── Update shadow light to follow drone ── */
            moonLight.position.set(
                drone.position.x - 10,
                drone.position.y + 20,
                drone.position.z - 10
            );
            moonLight.target.position.copy(drone.position);

            /* ── Camera orbits behind drone based on yaw ── */
            cameraYaw = droneYaw;
            camera.position.x = drone.position.x - Math.sin(cameraYaw) * camDist;
            camera.position.z = drone.position.z - Math.cos(cameraYaw) * camDist;
            camera.position.y = drone.position.y + camHeight;
            controls.target.copy(drone.position);
            controls.update();

            // Use stick inputs (local frame) for tilt, not world-space velocity
            const targetPitch = -smoothInput.y * 0.18;
            const targetRoll = smoothInput.x * 0.18;

            const totalSpeed = smoothInput.length() + Math.abs(smoothLeft.x);
            const speedFactor = 1.0 - Math.min(totalSpeed, 1.0) * 0.8;

            const idlePitch = Math.cos(t * 1.0) * 0.02 * speedFactor;
            const idleRoll = Math.sin(t * 1.2) * 0.03 * speedFactor;
            const idleYaw = Math.sin(t * 0.3) * 0.02;

            drone.position.y = baseHeight + Math.sin(t * 1.5) * 0.08 * speedFactor + Math.sin(t * 3.7) * 0.02;

            // Smoothly lerp rotation for fluid motion
            const goalPitch = idlePitch + targetPitch;
            const goalRoll = idleRoll + targetRoll;
            const goalYaw = droneYaw + idleYaw;
            drone.rotation.x = THREE.MathUtils.lerp(drone.rotation.x, goalPitch, 0.08);
            drone.rotation.z = THREE.MathUtils.lerp(drone.rotation.z, goalRoll, 0.08);
            drone.rotation.y = THREE.MathUtils.lerp(drone.rotation.y, goalYaw, 0.1);

            const propSpeed = 0.7 + smoothInput.length() * 0.5;
            droneData.props.forEach((prop, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                prop.rotation.y += propSpeed * dir;
            });
            droneData.motorBells.forEach((bell, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                bell.rotation.y += propSpeed * dir;
            });

            const glowIntensity = 1.5 + Math.sin(t * 2) * 0.5;
            droneData.underglowLEDs.forEach((led, i) => {
                const phase = t * 3 + (i / droneData.underglowLEDs.length) * Math.PI * 2;
                led.mat.emissiveIntensity = 2.0 + Math.sin(phase) * 1.0;
            });
            droneData.underglowLights.forEach(l => {
                l.intensity = glowIntensity;
            });

            if (droneData.recLED) {
                droneData.recLED.material.emissiveIntensity = Math.sin(t * 4) > 0 ? 5.0 : 0.2;
            }

            droneData.greenGlow.intensity = 0.5 + Math.sin(t * 2.5) * 0.3;

            /* ── Update AA Truck turret tracking ── */
            if (!gameOver) {
                trucks.forEach(tData => {
                    if (tData.destroyed) return;

                    const truckObj = tData.group;
                    const truckWorldPos = new THREE.Vector3();
                    truckObj.getWorldPosition(truckWorldPos);
                    const toDrone = new THREE.Vector3().subVectors(drone.position, truckWorldPos);

                    // Yaw rotation (turretRotator rotates around Y)
                    const targetYaw = Math.atan2(toDrone.x, toDrone.z);
                    const truckYaw = truckObj.rotation.y;
                    let relYaw = targetYaw - truckYaw;
                    relYaw = relYaw - Math.PI * 2 * Math.round(relYaw / (Math.PI * 2));

                    let currentYaw = tData.turretRotator.rotation.y;
                    let yawDiff = relYaw - currentYaw;
                    yawDiff = yawDiff - Math.PI * 2 * Math.round(yawDiff / (Math.PI * 2));
                    tData.turretRotator.rotation.y += yawDiff * 0.05;

                    // Elevation
                    const horizDist = Math.sqrt(toDrone.x * toDrone.x + toDrone.z * toDrone.z);
                    const targetPitchAngle = Math.atan2(toDrone.y - 2.5, horizDist);
                    const clampedPitch = Math.max(-0.1, Math.min(Math.PI * 0.4, targetPitchAngle));
                    tData.elevationArm.rotation.x = THREE.MathUtils.lerp(
                        tData.elevationArm.rotation.x, -clampedPitch, 0.05
                    );

                    // Sight lens blink
                    tData.sightLens.material.emissiveIntensity = 1.5 + Math.sin(t * 6) * 1.0;

                    // Fire timer
                    tData.fireTimer += dt;
                    if (tData.fireTimer >= ENEMY_FIRE_INTERVAL) {
                        tData.fireTimer = 0;
                        fireEnemyMissile(tData);
                    }
                });

                surviveTime += dt;
            }

            /* ── Update enemy missiles ── */
            for (let i = enemyMissiles.length - 1; i >= 0; i--) {
                const em = enemyMissiles[i];
                const moveAmount = ENEMY_MISSILE_SPEED * dt;
                em.mesh.position.add(em.direction.clone().multiplyScalar(moveAmount));
                em.distanceTraveled += moveAmount;

                // Flicker the flame
                if (em.flame) {
                    em.flame.material.opacity = 0.5 + Math.random() * 0.5;
                    em.flame.scale.set(
                        0.8 + Math.random() * 0.4,
                        0.8 + Math.random() * 0.6,
                        0.8 + Math.random() * 0.4
                    );
                }

                // Trail
                if (em.trail && em.trailIndex < 500) {
                    const tp = em.trail.geometry.attributes.position.array;
                    const idx = em.trailIndex * 3;
                    tp[idx] = em.mesh.position.x + (Math.random() - 0.5) * 0.15;
                    tp[idx + 1] = em.mesh.position.y + (Math.random() - 0.5) * 0.15;
                    tp[idx + 2] = em.mesh.position.z + (Math.random() - 0.5) * 0.15;
                    em.trailIndex++;
                    em.trail.geometry.setDrawRange(0, em.trailIndex);
                    em.trail.geometry.attributes.position.needsUpdate = true;
                }

                // Proximity check to drone
                if (!gameOver) {
                    const distToDrone = em.mesh.position.distanceTo(drone.position);
                    if (distToDrone < BLAST_RADIUS) {
                        // BOOM - drone destroyed!
                        createExplosion(em.mesh.position.clone());
                        scene.remove(em.mesh);
                        fadingTrails.push({ trail: em.trail, elapsed: 0, duration: 1.5 });
                        enemyMissiles.splice(i, 1);
                        gameOverHandler();
                        continue;
                    }
                }

                // Ground hit or max range
                if (em.mesh.position.y <= 0.2 || em.distanceTraveled >= ENEMY_MISSILE_MAX_RANGE) {
                    createExplosion(em.mesh.position.clone());
                    scene.remove(em.mesh);
                    fadingTrails.push({ trail: em.trail, elapsed: 0, duration: 1.5 });
                    enemyMissiles.splice(i, 1);
                }
            }

            /* ── Update in-flight missiles ── */
            for (let i = activeMissiles.length - 1; i >= 0; i--) {
                const m = activeMissiles[i];
                m.elapsed += dt;
                const progress = Math.min(m.elapsed / m.duration, 1.0);

                // Smooth ease-in-out arc
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Lerp XZ position
                const newX = THREE.MathUtils.lerp(m.startPos.x, m.targetPos.x, eased);
                const newZ = THREE.MathUtils.lerp(m.startPos.z, m.targetPos.z, eased);

                // Parabolic arc for Y
                const baseY = THREE.MathUtils.lerp(m.startPos.y, m.targetPos.y, eased);
                const arcY = m.arcHeight * Math.sin(progress * Math.PI);
                const newY = baseY + arcY;

                m.mesh.position.set(newX, newY, newZ);

                // Point missile in flight direction
                if (progress < 0.98) {
                    const nextProgress = Math.min((m.elapsed + 0.016) / m.duration, 1.0);
                    const nextEased = nextProgress < 0.5
                        ? 2 * nextProgress * nextProgress
                        : 1 - Math.pow(-2 * nextProgress + 2, 2) / 2;
                    const lookX = THREE.MathUtils.lerp(m.startPos.x, m.targetPos.x, nextEased);
                    const lookZ = THREE.MathUtils.lerp(m.startPos.z, m.targetPos.z, nextEased);
                    const lookBaseY = THREE.MathUtils.lerp(m.startPos.y, m.targetPos.y, nextEased);
                    const lookArcY = m.arcHeight * Math.sin(nextProgress * Math.PI);
                    const lookY = lookBaseY + lookArcY;
                    m.mesh.lookAt(lookX, lookY, lookZ);
                }

                // Smoke trail
                if (m.trail && m.trailIndex < 300) {
                    const positions = m.trail.geometry.attributes.position.array;
                    const idx = m.trailIndex * 3;
                    positions[idx] = newX + (Math.random() - 0.5) * 0.1;
                    positions[idx + 1] = newY + (Math.random() - 0.5) * 0.1;
                    positions[idx + 2] = newZ + (Math.random() - 0.5) * 0.1;
                    m.trailIndex++;
                    m.trail.geometry.setDrawRange(0, m.trailIndex);
                    m.trail.geometry.attributes.position.needsUpdate = true;
                }

                // Impact!
                if (progress >= 1.0) {
                    scene.remove(m.mesh);
                    if (m.trail) {
                        fadingTrails.push({ trail: m.trail, elapsed: 0, duration: 1.5 });
                    }
                    createExplosion(m.targetPos);

                    // Check if this hit an AA truck
                    trucks.forEach(tData => {
                        if (!tData.destroyed) {
                            const distToTruck = m.targetPos.distanceTo(tData.group.position);
                            if (distToTruck < TRUCK_HIT_RADIUS) {
                                tData.hp--;
                                if (tData.hp <= 0) {
                                    destroyTruck(tData);
                                }
                            }
                        }
                    });

                    activeMissiles.splice(i, 1);
                }
            }

            /* ── Update explosions ── */
            for (let i = explosions.length - 1; i >= 0; i--) {
                const e = explosions[i];
                e.elapsed += dt;
                const progress = e.elapsed / e.duration;

                // Fire particles
                const pos = e.particles.geometry.attributes.position.array;
                for (let p = 0; p < e.velocities.length; p++) {
                    const v = e.velocities[p];
                    pos[p * 3] += v.x * dt;
                    pos[p * 3 + 1] += v.y * dt;
                    pos[p * 3 + 2] += v.z * dt;
                    v.y -= 12 * dt; // gravity
                    v.x *= 0.97;
                    v.z *= 0.97;
                    // bounce off ground
                    if (pos[p * 3 + 1] < 0.05) {
                        pos[p * 3 + 1] = 0.05;
                        v.y = Math.abs(v.y) * 0.3;
                    }
                }
                e.particles.geometry.attributes.position.needsUpdate = true;
                e.mat.opacity = Math.max(0, 1.0 - progress);

                // Flash fades
                e.flash.intensity = Math.max(0, 20 * (1 - progress * 3));

                // Shockwave ring expands
                const ringScale = 1 + progress * 15;
                e.ring.scale.set(ringScale, ringScale, 1);
                e.ringMat.opacity = Math.max(0, 0.8 * (1 - progress * 1.5));

                // Smoke particles drift up
                const sPos = e.smokeParticles.geometry.attributes.position.array;
                for (let s = 0; s < e.smokeVels.length; s++) {
                    const sv = e.smokeVels[s];
                    sPos[s * 3] += sv.x * dt * 0.3;
                    sPos[s * 3 + 1] += sv.y * dt * 0.5;
                    sPos[s * 3 + 2] += sv.z * dt * 0.3;
                    sv.x *= 0.98;
                    sv.z *= 0.98;
                }
                e.smokeParticles.geometry.attributes.position.needsUpdate = true;
                e.smokeMat.opacity = Math.max(0, 0.6 * (1 - progress * 0.8));

                // Cleanup
                if (e.elapsed >= e.duration) {
                    scene.remove(e.particles);
                    scene.remove(e.flash);
                    scene.remove(e.ring);
                    scene.remove(e.smokeParticles);
                    e.particles.geometry.dispose();
                    e.mat.dispose();
                    e.ring.geometry.dispose();
                    e.ringMat.dispose();
                    e.smokeParticles.geometry.dispose();
                    e.smokeMat.dispose();
                    explosions.splice(i, 1);
                }
            }

            /* ── Fade out missile trails ── */
            for (let i = fadingTrails.length - 1; i >= 0; i--) {
                const ft = fadingTrails[i];
                ft.elapsed += dt;
                ft.trail.material.opacity = Math.max(0, 0.5 * (1 - ft.elapsed / ft.duration));
                if (ft.elapsed >= ft.duration) {
                    scene.remove(ft.trail);
                    ft.trail.geometry.dispose();
                    ft.trail.material.dispose();
                    fadingTrails.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
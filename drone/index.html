<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinewhoop Drone Game</title>
    <meta name="description" content="A Three.js cinewhoop drone model with interactive grass physics.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://rookeryphysics.github.io/drone">
    <meta property="og:title" content="Cinewhoop Drone Game">
    <meta property="og:description" content="A Three.js cinewhoop drone model with interactive grass physics.">
    <meta property="og:image" content="https://rookeryphysics.github.io/drone/drone.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://rookeryphysics.github.io/drone">
    <meta property="twitter:title" content="Cinewhoop Drone Game">
    <meta property="twitter:description" content="A Three.js cinewhoop drone model with interactive grass physics.">
    <meta property="twitter:image" content="https://rookeryphysics.github.io/drone/drone.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #87CEEB;
        }

        canvas {
            display: block;
        }

        .joystick-zone {
            position: fixed;
            bottom: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(4px);
            transition: opacity 0.3s, background 0.3s;
        }

        .joystick-zone:active {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        #joystick-zone-right {
            right: 40px;
        }

        #joystick-zone-left {
            left: 40px;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }



        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: sans-serif;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>
    <div id="loading">Generating Grass...</div>

    <div id="joystick-zone-left" class="joystick-zone">
        <div id="joystick-knob-left" class="joystick-knob"></div>
    </div>

    <div id="joystick-zone-right" class="joystick-zone">
        <div id="joystick-knob-right" class="joystick-knob"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x9DD5F0, 0.004);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 600);
        camera.position.set(0, 8.0, 16.0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloom = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.2,
            0.4,
            0.85
        );
        composer.addPass(bloom);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.minDistance = 2;
        controls.maxDistance = 20;
        controls.target.set(0, 1.5, 0);
        controls.maxPolarAngle = Math.PI * 0.85;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envScene = new THREE.Scene();
        envScene.background = new THREE.Color(0x87CEEB);

        const envGeo = new THREE.SphereGeometry(50, 32, 32);
        const envMat = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            uniforms: {
                colorTop: { value: new THREE.Color(0x4A90D9) },
                colorBottom: { value: new THREE.Color(0xC8E6FF) },
            },
            vertexShader: `
                varying vec3 vWorldPos;
                void main() {
                    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 colorTop;
                uniform vec3 colorBottom;
                varying vec3 vWorldPos;
                void main() {
                    float t = clamp(normalize(vWorldPos).y * 0.5 + 0.5, 0.0, 1.0);
                    gl_FragColor = vec4(mix(colorBottom, colorTop, t), 1.0);
                }
            `,
        });
        envScene.add(new THREE.Mesh(envGeo, envMat));
        const envMap = pmremGenerator.fromScene(envScene, 0.04).texture;
        scene.environment = envMap;

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const hemi = new THREE.HemisphereLight(0x87CEEB, 0x44aa44, 0.8);
        scene.add(hemi);

        const moonLight = new THREE.DirectionalLight(0xFFF5E0, 1.8);
        moonLight.position.set(-10, 20, -10);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.set(4096, 4096);
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 200;
        moonLight.shadow.camera.left = -60;
        moonLight.shadow.camera.right = 60;
        moonLight.shadow.camera.top = 60;
        moonLight.shadow.camera.bottom = -60;
        moonLight.shadow.bias = -0.0001;
        moonLight.shadow.normalBias = 0.02;
        scene.add(moonLight);
        scene.add(moonLight.target);

        const rimLight = new THREE.DirectionalLight(0xFFE8C0, 0.8);
        rimLight.position.set(15, 10, 5);
        scene.add(rimLight);

        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({
            color: 0x3A7D2A,
            roughness: 0.8,
            metalness: 0.1,
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const grassCount = 40000;

        const grassGeo = new THREE.PlaneGeometry(0.12, 0.8, 1, 4);
        grassGeo.translate(0, 0.4, 0);

        const positions = grassGeo.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            if (y > 0.6) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.1);
            } else if (y > 0.4) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.5);
            }
        }
        grassGeo.computeVertexNormals();

        const grassMat = new THREE.MeshStandardMaterial({
            color: 0x4CAF50,
            emissive: 0x1B5E20,
            roughness: 0.7,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        grassMat.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = { value: 0 };
            shader.uniforms.uDronePos = { value: new THREE.Vector3(0, 10, 0) };

            grassMat.userData.shader = shader;

            shader.vertexShader = `
                uniform float uTime;
                uniform vec3 uDronePos;
                ${shader.vertexShader}
            `;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                
                vec4 worldInstancePos = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                
                float dist = distance(worldInstancePos.xz, uDronePos.xz);
                float radius = 3.0;
                
                float bendStrength = 0.0;
                
                if(dist < radius){
                    bendStrength = (1.0 - dist/radius) * (1.0 - dist/radius);
                }
                
                vec2 pushDir = normalize(worldInstancePos.xz - uDronePos.xz);
                
                float heightFactor = smoothstep(0.0, 0.8, position.y);
                
                float wind = sin(uTime * 1.5 + worldInstancePos.x * 0.5 + worldInstancePos.z * 0.3) * 0.1;
                
                transformed.x += wind * heightFactor;
                
                float pushForce = 2.5;
                transformed.x += pushDir.x * bendStrength * pushForce * heightFactor;
                transformed.z += pushDir.y * bendStrength * pushForce * heightFactor;
                
                transformed.y -= bendStrength * heightFactor * 0.5;
                `
            );
        };

        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        grassMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const dummy = new THREE.Object3D();
        const spread = 200;

        for (let i = 0; i < grassCount; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * spread,
                0,
                (Math.random() - 0.5) * spread
            );

            dummy.rotation.y = Math.random() * Math.PI * 2;

            const scale = 0.8 + Math.random() * 0.5;
            dummy.scale.set(scale, scale, scale);

            dummy.rotation.x = (Math.random() - 0.5) * 0.2;
            dummy.rotation.z = (Math.random() - 0.5) * 0.2;

            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);
        }

        scene.add(grassMesh);
        document.getElementById('loading').style.opacity = 0;

        /* ── Chain-link baseball fence around the map boundary ── */
        const FENCE_HALF = 98;          // boundary half-size (drone is clamped here)
        const fencePostHeight = 6.0;    // tall like a baseball backstop
        const fencePostRadius = 0.06;
        const fenceSpacing = 5;         // distance between posts
        const topRailRadius = 0.05;

        // Galvanized steel material for posts & top rail
        const fenceMetalMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.35,
            metalness: 0.9,
            envMapIntensity: 1.5,
        });

        // Chain-link mesh material – semi-transparent with diamond pattern via shader
        const chainLinkMat = new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.4,
            metalness: 0.85,
            transparent: true,
            opacity: 0.45,
            side: THREE.DoubleSide,
            depthWrite: false,
        });
        chainLinkMat.onBeforeCompile = (shader) => {
            shader.vertexShader = `
                varying vec2 vUvMesh;
                ${shader.vertexShader}
            `.replace('#include <uv_vertex>', `
                #include <uv_vertex>
                vUvMesh = uv;
            `);
            shader.fragmentShader = `
                varying vec2 vUvMesh;
                ${shader.fragmentShader}
            `.replace('#include <color_fragment>', `
                #include <color_fragment>
                // Diamond chain-link pattern
                float scaleU = 12.0;
                float scaleV = 24.0;
                vec2 st = vec2(vUvMesh.x * scaleU, vUvMesh.y * scaleV);
                float diamond = abs(fract(st.x) - 0.5) + abs(fract(st.y + st.x * 0.5) - 0.5);
                float wire = 1.0 - smoothstep(0.06, 0.12, abs(diamond - 0.5));
                if (wire < 0.1) discard;
                diffuseColor.a *= wire;
            `);
        };

        const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fencePostHeight, 8);
        // Cap on top of each post
        const postCapGeo = new THREE.SphereGeometry(fencePostRadius * 1.4, 8, 6);

        function addFenceSide(startX, startZ, dx, dz, totalLen) {
            const numPosts = Math.floor(totalLen / fenceSpacing) + 1;
            for (let i = 0; i < numPosts; i++) {
                const px = startX + dx * i * fenceSpacing;
                const pz = startZ + dz * i * fenceSpacing;

                // Steel post
                const post = new THREE.Mesh(postGeo, fenceMetalMat);
                post.position.set(px, fencePostHeight / 2, pz);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);

                // Rounded cap on post top
                const cap = new THREE.Mesh(postCapGeo, fenceMetalMat);
                cap.position.set(px, fencePostHeight + 0.02, pz);
                scene.add(cap);

                // Chain-link panel + top rail between posts
                if (i < numPosts - 1) {
                    const nx = startX + dx * (i + 1) * fenceSpacing;
                    const nz = startZ + dz * (i + 1) * fenceSpacing;
                    const mx = (px + nx) / 2;
                    const mz = (pz + nz) / 2;

                    // Top rail (horizontal pipe)
                    const railGeo = new THREE.CylinderGeometry(topRailRadius, topRailRadius, fenceSpacing, 8);
                    const rail = new THREE.Mesh(railGeo, fenceMetalMat);
                    rail.position.set(mx, fencePostHeight, mz);
                    if (Math.abs(dx) > 0) {
                        rail.rotation.z = Math.PI / 2;
                    } else {
                        rail.rotation.x = Math.PI / 2;
                    }
                    rail.castShadow = true;
                    scene.add(rail);

                    // Chain-link mesh panel
                    const panelGeo = new THREE.PlaneGeometry(fenceSpacing, fencePostHeight);
                    const panel = new THREE.Mesh(panelGeo, chainLinkMat);
                    panel.position.set(mx, fencePostHeight / 2, mz);
                    // Rotate panel to face outward
                    if (Math.abs(dx) > 0) {
                        // fence runs along X → panel faces Z
                        // default PlaneGeometry already faces +Z, no Y rotation needed
                    } else {
                        // fence runs along Z → panel faces X
                        panel.rotation.y = Math.PI / 2;
                    }
                    panel.receiveShadow = true;
                    scene.add(panel);
                }
            }
        }

        const fenceLen = FENCE_HALF * 2;
        // +Z side (front)
        addFenceSide(-FENCE_HALF, FENCE_HALF, 1, 0, fenceLen);
        // -Z side (back)
        addFenceSide(-FENCE_HALF, -FENCE_HALF, 1, 0, fenceLen);
        // +X side (right)
        addFenceSide(FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);
        // -X side (left)
        addFenceSide(-FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);

        function roundedBox(w, h, d, r, segs) {
            const shape = new THREE.Shape();
            const x = -w / 2, y = -h / 2;
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extSettings = {
                depth: d,
                bevelEnabled: true,
                bevelThickness: r * 0.5,
                bevelSize: r * 0.5,
                bevelSegments: segs || 3,
            };
            const geo = new THREE.ExtrudeGeometry(shape, extSettings);
            geo.center();
            return geo;
        }

        function createDrone() {
            const drone = new THREE.Group();

            const matCarbonFiber = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.4,
                metalness: 0.5,
                envMapIntensity: 1.0,
            });

            const matDuctPlastic = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.5,
                metalness: 0.1,
                envMapIntensity: 0.5,
            });

            const matDuctInner = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide,
            });

            const matAccentOrange = new THREE.MeshStandardMaterial({
                color: 0xff4400,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0xff2200,
                emissiveIntensity: 0.5,
                envMapIntensity: 1.2,
            });

            const matMotorBell = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.9,
                envMapIntensity: 2.5,
            });

            const matMotorStator = new THREE.MeshStandardMaterial({
                color: 0xaa7722,
                roughness: 0.4,
                metalness: 0.7,
            });

            const matPropBlack = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matPropOrange = new THREE.MeshStandardMaterial({
                color: 0xff5500,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matLens = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.0,
                metalness: 1.0,
                envMapIntensity: 3.0,
            });

            const matCamBody = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.6,
                metalness: 0.2,
                envMapIntensity: 0.8,
            });

            const matBattery = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.6,
                metalness: 0.1,
            });

            const matBattLabel = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                roughness: 0.5,
                metalness: 0.3,
            });

            const matRubber = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
            });

            const matPCB = new THREE.MeshStandardMaterial({
                color: 0x1a3322,
                roughness: 0.8,
                metalness: 0.1,
            });

            const matLEDGreen = new THREE.MeshStandardMaterial({
                color: 0x00ff44,
                emissive: 0x00ff44,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDRed = new THREE.MeshStandardMaterial({
                color: 0xff0022,
                emissive: 0xff0022,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDBlue = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0066ff,
                emissiveIntensity: 3.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matWhitePlastic = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.5,
                metalness: 0.0,
            });

            const matSilver = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.95,
                envMapIntensity: 2.0,
            });

            const frameGeo = roundedBox(1.3, 0.12, 1.5, 0.04, 3);
            const frame = new THREE.Mesh(frameGeo, matCarbonFiber);
            frame.castShadow = true;
            drone.add(frame);

            const bottomPlate = new THREE.Mesh(roundedBox(1.2, 0.04, 1.4, 0.03, 2), matCarbonFiber);
            bottomPlate.position.y = -0.08;
            bottomPlate.castShadow = true;
            drone.add(bottomPlate);

            const armPositions = [
                { x: 0.55, z: 0.55, angle: Math.PI / 4 },
                { x: -0.55, z: 0.55, angle: -Math.PI / 4 },
                { x: 0.55, z: -0.55, angle: -Math.PI / 4 },
                { x: -0.55, z: -0.55, angle: Math.PI / 4 },
            ];

            armPositions.forEach(ap => {
                const armGeo = new THREE.BoxGeometry(0.65, 0.08, 0.2);
                const arm = new THREE.Mesh(armGeo, matCarbonFiber);
                arm.position.set(ap.x * 0.6, 0, ap.z * 0.6);
                arm.rotation.y = ap.angle;
                arm.castShadow = true;
                drone.add(arm);
            });

            const fcBoard = new THREE.Mesh(
                roundedBox(0.42, 0.04, 0.42, 0.02, 2),
                matPCB
            );
            fcBoard.position.y = 0.1;
            drone.add(fcBoard);

            for (let sx = -1; sx <= 1; sx += 2) {
                for (let sz = -1; sz <= 1; sz += 2) {
                    const standoff = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8),
                        matSilver
                    );
                    standoff.position.set(sx * 0.16, 0.08, sz * 0.16);
                    drone.add(standoff);
                }
            }

            const escBoard = new THREE.Mesh(
                roundedBox(0.44, 0.03, 0.44, 0.02, 2),
                matPCB
            );
            escBoard.position.y = 0.155;
            drone.add(escBoard);

            const capGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.08, 10);
            const cap = new THREE.Mesh(capGeo, matCarbonFiber);
            cap.position.set(0.1, 0.2, 0.05);
            cap.rotation.z = Math.PI / 2;
            drone.add(cap);

            const ductOuterR = 0.52;
            const ductInnerR = 0.47;
            const ductHeight = 0.32;
            const motorPositions = [
                { x: 0.82, z: 0.82 }, { x: -0.82, z: 0.82 },
                { x: 0.82, z: -0.82 }, { x: -0.82, z: -0.82 }
            ];

            const allProps = [];
            const allMotorBells = [];

            motorPositions.forEach((pos, i) => {
                const motorUnit = new THREE.Group();
                motorUnit.position.set(pos.x, 0, pos.z);

                const ductOuterGeo = new THREE.CylinderGeometry(
                    ductOuterR, ductOuterR + 0.02, ductHeight, 32, 1, true
                );
                const ductOuter = new THREE.Mesh(ductOuterGeo, matDuctPlastic);
                ductOuter.castShadow = true;
                motorUnit.add(ductOuter);

                const ductInnerGeo = new THREE.CylinderGeometry(
                    ductInnerR, ductInnerR, ductHeight, 32, 1, true
                );
                const ductInner = new THREE.Mesh(ductInnerGeo, matDuctInner);
                motorUnit.add(ductInner);

                const lipGeo = new THREE.TorusGeometry(
                    (ductOuterR + ductInnerR) / 2, 0.025, 8, 32
                );
                const lip = new THREE.Mesh(lipGeo, matDuctPlastic);
                lip.rotation.x = Math.PI / 2;
                lip.position.y = ductHeight / 2;
                motorUnit.add(lip);

                const lipBot = lip.clone();
                lipBot.position.y = -ductHeight / 2;
                motorUnit.add(lipBot);

                const stripeGeo = new THREE.TorusGeometry(
                    ductOuterR + 0.005, 0.012, 6, 32
                );
                const stripe = new THREE.Mesh(stripeGeo, matAccentOrange);
                stripe.rotation.x = Math.PI / 2;
                stripe.position.y = ductHeight / 2 - 0.04;
                motorUnit.add(stripe);

                for (let cs = 0; cs < 4; cs++) {
                    const supportGeo = new THREE.BoxGeometry(ductInnerR * 0.85, 0.03, 0.025);
                    const support = new THREE.Mesh(supportGeo, matCarbonFiber);
                    support.rotation.y = (cs * Math.PI) / 4;
                    support.position.y = -0.05;
                    motorUnit.add(support);
                }

                const statorGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.12, 16);
                const stator = new THREE.Mesh(statorGeo, matMotorStator);
                stator.position.y = -0.04;
                motorUnit.add(stator);

                for (let w = 0; w < 6; w++) {
                    const coilGeo = new THREE.TorusGeometry(0.1, 0.012, 4, 6);
                    const coil = new THREE.Mesh(coilGeo, matMotorStator);
                    coil.rotation.x = Math.PI / 2;
                    coil.rotation.z = (w * Math.PI) / 3;
                    coil.position.y = -0.04;
                    motorUnit.add(coil);
                }

                const bellGroup = new THREE.Group();
                bellGroup.position.y = 0.04;

                const bellGeo = new THREE.CylinderGeometry(0.12, 0.11, 0.06, 20);
                const bell = new THREE.Mesh(bellGeo, matMotorBell);
                bellGroup.add(bell);

                const bellCapGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.02, 16);
                const bellCap = new THREE.Mesh(bellCapGeo, matMotorBell);
                bellCap.position.y = 0.04;
                bellGroup.add(bellCap);

                const shaftGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8);
                const shaft = new THREE.Mesh(shaftGeo, matSilver);
                shaft.position.y = 0.06;
                bellGroup.add(shaft);

                motorUnit.add(bellGroup);
                allMotorBells.push(bellGroup);

                const propGroup = new THREE.Group();
                propGroup.position.y = 0.1;

                const hubGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.018, 12);
                const propMatChoice = (i < 2) ? matPropOrange : matPropBlack;
                const hub = new THREE.Mesh(hubGeo, propMatChoice);
                propGroup.add(hub);

                const nutGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 6);
                const nut = new THREE.Mesh(nutGeo, matSilver);
                nut.position.y = 0.014;
                propGroup.add(nut);

                for (let b = 0; b < 3; b++) {
                    const bladeGroup = new THREE.Group();
                    bladeGroup.rotation.y = (b * Math.PI * 2) / 3;

                    const bladeLen = 0.38;
                    const bladeW = 0.055;
                    const bladeShape = new THREE.Shape();
                    bladeShape.moveTo(0, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.3, bladeW * 0.6, bladeLen * 0.75, bladeW);
                    bladeShape.quadraticCurveTo(bladeLen * 0.95, bladeW * 0.8, bladeLen, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.7, -bladeW * 0.15, 0, 0);

                    const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                        depth: 0.008,
                        bevelEnabled: true,
                        bevelThickness: 0.002,
                        bevelSize: 0.002,
                        bevelSegments: 2,
                    });
                    bladeGeo.center();

                    const blade = new THREE.Mesh(bladeGeo, propMatChoice);
                    blade.rotation.x = 0.12;
                    blade.position.x = bladeLen / 2 + 0.02;
                    bladeGroup.add(blade);

                    propGroup.add(bladeGroup);
                }

                motorUnit.add(propGroup);
                allProps.push(propGroup);

                drone.add(motorUnit);
            });

            const camMount = new THREE.Group();
            camMount.position.set(0, 0.22, 0.58);
            camMount.rotation.x = -0.18;

            const camBodyGeo = roundedBox(0.36, 0.26, 0.2, 0.025, 3);
            const camBody = new THREE.Mesh(camBodyGeo, matCamBody);
            camBody.castShadow = true;
            camMount.add(camBody);

            const lensBarrelGeo = new THREE.CylinderGeometry(0.075, 0.08, 0.06, 20);
            const lensBarrel = new THREE.Mesh(lensBarrelGeo, matCarbonFiber);
            lensBarrel.rotation.x = Math.PI / 2;
            lensBarrel.position.z = 0.13;
            camMount.add(lensBarrel);

            const lensGlassGeo = new THREE.CircleGeometry(0.065, 24);
            const lensGlass = new THREE.Mesh(lensGlassGeo, matLens);
            lensGlass.position.z = 0.165;
            camMount.add(lensGlass);

            const lensRingGeo = new THREE.TorusGeometry(0.072, 0.008, 8, 24);
            const lensRing = new THREE.Mesh(lensRingGeo, matSilver);
            lensRing.position.z = 0.16;
            camMount.add(lensRing);

            const innerRingGeo = new THREE.TorusGeometry(0.04, 0.005, 8, 20);
            const innerRing = new THREE.Mesh(innerRingGeo, matSilver);
            innerRing.position.z = 0.167;
            camMount.add(innerRing);

            const recLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                matLEDRed
            );
            recLED.position.set(0.14, 0.08, 0.1);
            camMount.add(recLED);

            for (let side = -1; side <= 1; side += 2) {
                const bracketGeo = new THREE.BoxGeometry(0.015, 0.12, 0.04);
                const bracket = new THREE.Mesh(bracketGeo, matSilver);
                bracket.position.set(side * 0.2, -0.02, 0);
                camMount.add(bracket);
            }

            for (let side = -1; side <= 1; side += 2) {
                const damperGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const damper = new THREE.Mesh(damperGeo, matAccentOrange);
                damper.position.set(side * 0.2, -0.1, 0);
                camMount.add(damper);
            }

            drone.add(camMount);

            const batteryGroup = new THREE.Group();
            batteryGroup.position.set(0, -0.12, -0.1);

            const battGeo = roundedBox(0.58, 0.14, 0.38, 0.02, 2);
            const battBody = new THREE.Mesh(battGeo, matBattery);
            battBody.castShadow = true;
            batteryGroup.add(battBody);

            const labelGeo = new THREE.BoxGeometry(0.4, 0.005, 0.2);
            const label = new THREE.Mesh(labelGeo, matBattLabel);
            label.position.y = 0.072;
            batteryGroup.add(label);

            for (let s = -1; s <= 1; s += 2) {
                const strapGeo = new THREE.BoxGeometry(0.02, 0.18, 0.42);
                const strap = new THREE.Mesh(strapGeo, matAccentOrange);
                strap.position.set(s * 0.15, 0, 0);
                batteryGroup.add(strap);
            }

            const xt60 = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.04, 0.03),
                matBattLabel
            );
            xt60.position.set(0.32, 0, 0);
            batteryGroup.add(xt60);

            for (let w = 0; w < 4; w++) {
                const wireGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.08, 6);
                const wireMat = new THREE.MeshStandardMaterial({
                    color: [0xff0000, 0x000000, 0xff0000, 0x000000][w],
                    roughness: 0.7,
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.set(0.3, -0.02, -0.12 + w * 0.03);
                wire.rotation.z = Math.PI / 2 + 0.3;
                batteryGroup.add(wire);
            }

            drone.add(batteryGroup);

            const antennaGroup = new THREE.Group();
            antennaGroup.position.set(0.08, 0.2, -0.65);

            const smaGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.04, 10);
            const sma = new THREE.Mesh(smaGeo, matSilver);
            antennaGroup.add(sma);

            const antennaStalk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.35, 8),
                matWhitePlastic
            );
            antennaStalk.position.y = 0.2;
            antennaStalk.rotation.x = -0.3;
            antennaGroup.add(antennaStalk);

            const mushroomGeo = new THREE.SphereGeometry(0.04, 12, 12);
            const mushroom = new THREE.Mesh(mushroomGeo, matWhitePlastic);
            mushroom.position.set(0, 0.38, -0.1);
            antennaGroup.add(mushroom);

            for (let cl = 0; cl < 4; cl++) {
                const clWire = new THREE.Mesh(
                    new THREE.TorusGeometry(0.03, 0.003, 6, 8, Math.PI),
                    matSilver
                );
                clWire.rotation.y = (cl * Math.PI) / 2;
                clWire.position.set(0, 0.38, -0.1);
                antennaGroup.add(clWire);
            }

            drone.add(antennaGroup);

            const gpsMount = new THREE.Group();
            gpsMount.position.set(-0.08, 0.2, -0.55);

            const gpsMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.15, 8),
                matCarbonFiber
            );
            gpsMast.position.y = 0.08;
            gpsMount.add(gpsMast);

            const gpsDisk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.015, 16),
                matCarbonFiber
            );
            gpsDisk.position.y = 0.16;
            gpsMount.add(gpsDisk);

            drone.add(gpsMount);

            const skidPositions = [
                { x: 0.35, z: 0.45 }, { x: -0.35, z: 0.45 },
                { x: 0.35, z: -0.45 }, { x: -0.35, z: -0.45 }
            ];

            skidPositions.forEach(sp => {
                const skid = new THREE.Group();
                skid.position.set(sp.x, -0.18, sp.z);

                const legGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.1, 8);
                const leg = new THREE.Mesh(legGeo, matCarbonFiber);
                skid.add(leg);

                const footGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const foot = new THREE.Mesh(footGeo, matRubber);
                foot.position.y = -0.05;
                foot.scale.y = 0.5;
                skid.add(foot);

                drone.add(skid);
            });

            const rearLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                matLEDGreen
            );
            rearLED.position.set(0, 0.05, -0.76);
            drone.add(rearLED);

            const greenGlow = new THREE.PointLight(0x00ff44, 1.0, 2.5);
            greenGlow.position.copy(rearLED.position);
            drone.add(greenGlow);

            const frontLEDs = [];
            for (let side = -1; side <= 1; side += 2) {
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.012, 8, 8),
                    matLEDBlue
                );
                led.position.set(side * 0.5, -0.02, 0.7);
                drone.add(led);
                frontLEDs.push(led);

                const blueGlow = new THREE.PointLight(0x0066ff, 0.5, 1.5);
                blueGlow.position.copy(led.position);
                drone.add(blueGlow);
            }

            const underglowLEDs = [];
            const underglowLights = [];
            const numUnderglow = 12;
            for (let u = 0; u < numUnderglow; u++) {
                const angle = (u * Math.PI * 2) / numUnderglow;
                const r = 0.5;
                const ledMat = new THREE.MeshStandardMaterial({
                    color: 0x00ccff,
                    emissive: 0x00ccff,
                    emissiveIntensity: 2.0,
                    roughness: 0.2,
                });
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.01, 6, 6),
                    ledMat
                );
                led.position.set(Math.cos(angle) * r, -0.14, Math.sin(angle) * r);
                drone.add(led);
                underglowLEDs.push({ mesh: led, mat: ledMat });
            }

            const underglowMain = new THREE.PointLight(0x00ccff, 2.0, 8);
            underglowMain.position.set(0, -0.4, 0);
            drone.add(underglowMain);
            underglowLights.push(underglowMain);

            const buzzer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.02, 12),
                matCarbonFiber
            );
            buzzer.position.set(0.6, 0, 0);
            buzzer.rotation.z = Math.PI / 2;
            drone.add(buzzer);

            for (let ra = 0; ra < 2; ra++) {
                const rxAntennaGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.25, 6);
                const rxAntenna = new THREE.Mesh(rxAntennaGeo, matCarbonFiber);
                rxAntenna.position.set(-0.15 + ra * 0.3, 0.12, -0.7);
                rxAntenna.rotation.x = -0.6 + ra * 0.15;
                rxAntenna.rotation.z = -0.3 + ra * 0.6;
                drone.add(rxAntenna);
            }

            /* ── Missiles attached to drone underside ── */
            const missiles = [];
            const missileSlots = [
                { x: -0.32, y: 0.12, z: 0.1 },
                { x: 0.32, y: 0.12, z: 0.1 },
            ];

            function createMissileModel() {
                const missile = new THREE.Group();

                // Body tube
                const bodyGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.55, 12);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x556655,
                    roughness: 0.4,
                    metalness: 0.6,
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                missile.add(body);

                // Nose cone
                const noseGeo = new THREE.ConeGeometry(0.035, 0.15, 12);
                const noseMat = new THREE.MeshStandardMaterial({
                    color: 0xcc3300,
                    roughness: 0.3,
                    metalness: 0.5,
                    emissive: 0x881100,
                    emissiveIntensity: 0.3,
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = 0.35;
                missile.add(nose);

                // Orange accent band
                const bandGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.03, 12);
                const bandMat = new THREE.MeshStandardMaterial({
                    color: 0xff6600,
                    roughness: 0.3,
                    metalness: 0.4,
                    emissive: 0xff4400,
                    emissiveIntensity: 0.3,
                });
                const band = new THREE.Mesh(bandGeo, bandMat);
                band.rotation.x = Math.PI / 2;
                band.position.z = 0.22;
                missile.add(band);

                // Rear nozzle
                const nozzleGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.06, 10);
                const nozzleMat = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.2,
                    metalness: 0.9,
                });
                const nozzle = new THREE.Mesh(nozzleGeo, nozzleMat);
                nozzle.rotation.x = Math.PI / 2;
                nozzle.position.z = -0.305;
                missile.add(nozzle);

                // 4 fins
                for (let f = 0; f < 4; f++) {
                    const finShape = new THREE.Shape();
                    finShape.moveTo(0, 0);
                    finShape.lineTo(0.08, 0);
                    finShape.lineTo(0.04, 0.12);
                    finShape.lineTo(0, 0.12);
                    const finGeo = new THREE.ExtrudeGeometry(finShape, {
                        depth: 0.005,
                        bevelEnabled: false,
                    });
                    const finMat = new THREE.MeshStandardMaterial({
                        color: 0x445544,
                        roughness: 0.5,
                        metalness: 0.5,
                    });
                    const fin = new THREE.Mesh(finGeo, finMat);
                    fin.rotation.y = (f * Math.PI) / 2;
                    fin.rotation.x = Math.PI / 2;
                    fin.position.z = -0.28;
                    fin.position.x = -0.0025;
                    fin.position.y = -0.0025;
                    missile.add(fin);
                }

                return missile;
            }

            missileSlots.forEach((slot, i) => {
                const m = createMissileModel();
                m.position.set(slot.x, slot.y, slot.z);
                // missiles point forward along drone's local Z
                m.scale.set(0.8, 0.8, 0.8);
                drone.add(m);
                missiles.push({ mesh: m, attached: true, slotIndex: i });
            });

            drone.scale.set(1.6, 1.6, 1.6);

            drone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return {
                group: drone,
                props: allProps,
                motorBells: allMotorBells,
                underglowLEDs,
                underglowLights,
                recLED,
                greenGlow,
                frontLEDs,
                missiles,
                missileSlots,
            };
        }

        const droneData = createDrone();
        const drone = droneData.group;
        drone.position.set(0, 1.8, 0);
        drone.rotation.order = 'YXZ';  // Apply yaw first so pitch/roll are in local frame
        scene.add(drone);

        /* ── Ammo Crate ── */
        function createAmmoCrate() {
            const group = new THREE.Group();

            // Box (4x larger)
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(10.0, 4.8, 6.0),
                new THREE.MeshStandardMaterial({ color: 0x3d4c3d, roughness: 0.8 })
            );
            box.position.y = 2.4;
            box.castShadow = true;
            box.receiveShadow = true;
            group.add(box);

            // Lid
            const lid = new THREE.Mesh(
                new THREE.BoxGeometry(10.4, 0.8, 6.4),
                new THREE.MeshStandardMaterial({ color: 0x2f3a2f, roughness: 0.9 })
            );
            lid.position.y = 5.0;
            lid.castShadow = true;
            lid.receiveShadow = true;
            group.add(lid);

            // Simple markings
            const markGeo = new THREE.PlaneGeometry(4.0, 1.6);
            const markMat = new THREE.MeshBasicMaterial({ color: 0xcccc00 });
            const mark = new THREE.Mesh(markGeo, markMat);
            mark.rotation.x = -Math.PI / 2;
            mark.position.y = 5.41;
            group.add(mark);

            return group;
        }

        const ammoCrate = createAmmoCrate();
        // Positioned in corner, adjusted for larger size
        ammoCrate.position.set(80, 0, 80);
        scene.add(ammoCrate);

        /* ── Missile Launch System ── */
        const activeMissiles = [];     // in-flight missiles
        const explosions = [];         // active explosion particle systems
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let missileReloadTimer = 0;

        function launchMissile(targetPoint) {
            // Find an attached missile
            const slot = droneData.missiles.find(m => m.attached);
            if (!slot) return;

            slot.attached = false;

            // Get the missile's world position before detaching
            const worldPos = new THREE.Vector3();
            slot.mesh.getWorldPosition(worldPos);
            const worldQuat = new THREE.Quaternion();
            slot.mesh.getWorldQuaternion(worldQuat);

            // Remove from drone, add to scene
            drone.remove(slot.mesh);
            slot.mesh.position.copy(worldPos);
            slot.mesh.quaternion.copy(worldQuat);
            slot.mesh.scale.set(1.28, 1.28, 1.28); // 0.8 * 1.6 drone scale
            scene.add(slot.mesh);

            // Direction and flight params
            const direction = new THREE.Vector3().subVectors(targetPoint, worldPos);
            const totalDist = direction.length();
            const flightDuration = Math.min(Math.max(totalDist / 18, 0.4), 3.0);

            activeMissiles.push({
                mesh: slot.mesh,
                slotData: slot,
                startPos: worldPos.clone(),
                targetPos: targetPoint.clone(),
                elapsed: 0,
                duration: flightDuration,
                arcHeight: Math.max(totalDist * 0.15, 1.0),
            });

            // Create a smoke trail
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(300 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeo.setDrawRange(0, 0);
            const trailMat = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 0.15,
                transparent: true,
                opacity: 0.5,
                depthWrite: false,
            });
            const trail = new THREE.Points(trailGeo, trailMat);
            scene.add(trail);
            activeMissiles[activeMissiles.length - 1].trail = trail;
            activeMissiles[activeMissiles.length - 1].trailIndex = 0;
        }

        function createExplosion(position) {
            const particleCount = 40;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const fireColors = [
                new THREE.Color(0xff4400),
                new THREE.Color(0xff8800),
                new THREE.Color(0xffcc00),
                new THREE.Color(0xff2200),
                new THREE.Color(0xffaa00),
            ];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y + 0.1;
                positions[i * 3 + 2] = position.z;

                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 3 + Math.random() * 8;
                velocities.push({
                    x: Math.sin(phi) * Math.cos(theta) * speed,
                    y: Math.abs(Math.cos(phi)) * speed * 1.2 + 2,
                    z: Math.sin(phi) * Math.sin(theta) * speed,
                });

                const c = fireColors[Math.floor(Math.random() * fireColors.length)];
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;

                sizes[i] = 0.2 + Math.random() * 0.5;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            const particles = new THREE.Points(geo, mat);
            scene.add(particles);

            // Explosion flash light
            const flash = new THREE.PointLight(0xff6600, 20, 15);
            flash.position.copy(position);
            flash.position.y += 0.5;
            scene.add(flash);

            // Shockwave ring
            const ringGeo = new THREE.RingGeometry(0.1, 0.3, 16);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.position.y += 0.05;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);

            // Smoke cloud (secondary particles)
            const smokeCount = 15;
            const smokeGeo = new THREE.BufferGeometry();
            const smokePos = new Float32Array(smokeCount * 3);
            const smokeVels = [];
            for (let i = 0; i < smokeCount; i++) {
                smokePos[i * 3] = position.x;
                smokePos[i * 3 + 1] = position.y + 0.3;
                smokePos[i * 3 + 2] = position.z;
                const theta = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                smokeVels.push({
                    x: Math.cos(theta) * speed,
                    y: 1 + Math.random() * 3,
                    z: Math.sin(theta) * speed,
                });
            }
            smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
            const smokeMat = new THREE.PointsMaterial({
                color: 0x444444,
                size: 0.8,
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
            });
            const smokeParticles = new THREE.Points(smokeGeo, smokeMat);
            scene.add(smokeParticles);

            explosions.push({
                particles, velocities, mat,
                flash, ring, ringMat,
                smokeParticles, smokeVels, smokeMat,
                elapsed: 0,
                duration: 2.0,
            });
        }

        function respawnMissile(slotData) {
            const slot = droneData.missileSlots[slotData.slotIndex];
            // Do not remove old mesh here, as it might be currently flying (activeMissile)
            // scene.remove(slotData.mesh); 

            // Create a fresh missile and re-attach
            const freshGroup = new THREE.Group();

            // Re-build missile body pieces
            const bodyGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.55, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x556655, roughness: 0.4, metalness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            freshGroup.add(body);

            const noseGeo = new THREE.ConeGeometry(0.035, 0.15, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xcc3300, roughness: 0.3, metalness: 0.5, emissive: 0x881100, emissiveIntensity: 0.3 });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.rotation.x = -Math.PI / 2;
            nose.position.z = 0.35;
            freshGroup.add(nose);

            const bandGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.03, 12);
            const bandMat = new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.3, metalness: 0.4, emissive: 0xff4400, emissiveIntensity: 0.3 });
            const band = new THREE.Mesh(bandGeo, bandMat);
            band.rotation.x = Math.PI / 2;
            band.position.z = 0.22;
            freshGroup.add(band);

            const nozzleGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.06, 10);
            const nozzleMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.9 });
            const nozzle = new THREE.Mesh(nozzleGeo, nozzleMat);
            nozzle.rotation.x = Math.PI / 2;
            nozzle.position.z = -0.305;
            freshGroup.add(nozzle);

            for (let f = 0; f < 4; f++) {
                const finShape = new THREE.Shape();
                finShape.moveTo(0, 0);
                finShape.lineTo(0.08, 0);
                finShape.lineTo(0.04, 0.12);
                finShape.lineTo(0, 0.12);
                const finGeo = new THREE.ExtrudeGeometry(finShape, { depth: 0.005, bevelEnabled: false });
                const finMat = new THREE.MeshStandardMaterial({ color: 0x445544, roughness: 0.5, metalness: 0.5 });
                const fin = new THREE.Mesh(finGeo, finMat);
                fin.rotation.y = (f * Math.PI) / 2;
                fin.rotation.x = Math.PI / 2;
                fin.position.z = -0.28;
                fin.position.x = -0.0025;
                fin.position.y = -0.0025;
                freshGroup.add(fin);
            }

            freshGroup.position.set(slot.x, slot.y, slot.z);
            // freshGroup.rotation.x = -Math.PI / 2; // REMOVED: Match initial orientation
            freshGroup.scale.set(0.8, 0.8, 0.8);
            drone.add(freshGroup);

            freshGroup.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            slotData.mesh = freshGroup;
            slotData.attached = true;
        }

        // Click/tap handler — only fires on the ground plane
        function onPointerDown(event) {
            // Ignore if clicking joystick zones
            const target = event.target;
            if (target && target.closest && (target.closest('.joystick-zone') || target.closest('.joystick-knob'))) return;

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                launchMissile(intersects[0].point);
            }
        }

        // Use pointerdown to handle both mouse and touch without double-firing
        renderer.domElement.addEventListener('pointerdown', onPointerDown);


        /* ── Joystick Helper Factory ── */
        function createJoystickController(zoneId, knobId) {
            const zone = document.getElementById(zoneId);
            const knob = document.getElementById(knobId);
            const joySize = 120;
            const knobSize = 40;
            const maxDist = (joySize - knobSize) / 2;
            const state = { x: 0, y: 0 };
            let dragging = false;
            let startX, startY;
            let activeTouchId = null;

            const update = (dx, dy) => {
                const dist = Math.sqrt(dx * dx + dy * dy);
                let cx = dx, cy = dy;
                if (dist > maxDist) {
                    const a = Math.atan2(dy, dx);
                    cx = Math.cos(a) * maxDist;
                    cy = Math.sin(a) * maxDist;
                }
                knob.style.transform = `translate(${cx}px, ${cy}px)`;
                state.x = cx / maxDist;
                state.y = cy / maxDist;
            };

            const reset = () => {
                dragging = false;
                activeTouchId = null;
                state.x = 0;
                state.y = 0;
                knob.style.transform = `translate(0px, 0px)`;
            };

            /* Mouse events */
            zone.addEventListener('mousedown', (e) => {
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mouseup', () => { if (dragging) reset(); });

            /* Touch events – track a specific touch ID so both sticks work independently */
            zone.addEventListener('touchstart', (e) => {
                if (activeTouchId !== null) return; // already tracking
                const touch = e.changedTouches[0];
                activeTouchId = touch.identifier;
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(touch.clientX - startX, touch.clientY - startY);
            }, { passive: true });

            window.addEventListener('touchmove', (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        const t = e.changedTouches[i];
                        update(t.clientX - startX, t.clientY - startY);
                        break;
                    }
                }
            }, { passive: true });

            const touchEnd = (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        reset();
                        break;
                    }
                }
            };
            window.addEventListener('touchend', touchEnd);
            window.addEventListener('touchcancel', touchEnd);

            return state;
        }

        /* Right stick  → forward / backward / strafe */
        const inputVector = createJoystickController('joystick-zone-right', 'joystick-knob-right');
        /* Left stick   → yaw (x) & altitude (y) */
        const inputLeft = createJoystickController('joystick-zone-left', 'joystick-knob-left');

        /* ── Keyboard input (WASD = left stick, Arrows = right stick) ── */
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function getKeyboardInput() {
            // WASD → left stick (A/D = yaw X, W/S = altitude Y)
            let leftX = 0, leftY = 0;
            if (keys['KeyA']) leftX -= 1;
            if (keys['KeyD']) leftX += 1;
            if (keys['KeyW']) leftY -= 1;   // W = up (stick up = negative Y)
            if (keys['KeyS']) leftY += 1;   // S = down

            // Arrow keys → right stick (Left/Right = strafe X, Up/Down = fwd/back Y)
            let rightX = 0, rightY = 0;
            if (keys['ArrowLeft']) rightX -= 1;
            if (keys['ArrowRight']) rightX += 1;
            if (keys['ArrowUp']) rightY -= 1;   // forward = stick up = negative Y
            if (keys['ArrowDown']) rightY += 1;

            return { leftX, leftY, rightX, rightY };
        }

        const clock = new THREE.Clock();
        let lastTime = 0;
        const droneSpeed = 0.28;
        const yawSpeed = 0.04;      // radians per frame at full deflection
        const altSpeed = 0.08;      // units per frame at full deflection
        const smoothInput = new THREE.Vector2();   // right stick smoothed
        const smoothLeft = new THREE.Vector2();   // left stick smoothed
        const currentVelocity = new THREE.Vector3();

        let baseHeight = 1.8;
        let droneYaw = Math.PI;     // current heading (initial = facing camera)
        let cameraYaw = droneYaw;   // smoothed camera heading that follows drone yaw
        const camDist = 14;         // how far behind the drone the camera orbits
        const camHeight = 6;        // camera height offset above drone


        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const dt = Math.min(t - lastTime, 0.05); // capped to avoid huge jumps
            lastTime = t;

            if (grassMat.userData.shader) {
                grassMat.userData.shader.uniforms.uTime.value = t;
                grassMat.userData.shader.uniforms.uDronePos.value.copy(drone.position);
            }

            /* ── Blend keyboard + joystick, then smooth ── */
            const kb = getKeyboardInput();
            // Clamp combined input to [-1, 1]
            const clamp = (v) => Math.max(-1, Math.min(1, v));
            const combinedRightX = clamp(inputVector.x + kb.rightX);
            const combinedRightY = clamp(inputVector.y + kb.rightY);
            const combinedLeftX = clamp(inputLeft.x + kb.leftX);
            const combinedLeftY = clamp(inputLeft.y + kb.leftY);

            smoothInput.x = THREE.MathUtils.lerp(smoothInput.x, combinedRightX, 0.06);
            smoothInput.y = THREE.MathUtils.lerp(smoothInput.y, combinedRightY, 0.06);
            smoothLeft.x = THREE.MathUtils.lerp(smoothLeft.x, combinedLeftX, 0.08);
            smoothLeft.y = THREE.MathUtils.lerp(smoothLeft.y, combinedLeftY, 0.08);

            /* ── Left stick: yaw & altitude ── */
            droneYaw -= smoothLeft.x * yawSpeed;            // left → positive yaw
            baseHeight -= smoothLeft.y * altSpeed;           // stick up (negative y) → go up
            baseHeight = Math.max(0.4, baseHeight);          // clamp above ground

            /* ── Right stick: movement in the drone's local heading ── */
            const sinY = Math.sin(droneYaw);
            const cosY = Math.cos(droneYaw);
            // forward/back from stick Y, strafe from stick X – glide to a stop
            const targetVelX = (-smoothInput.x * cosY - smoothInput.y * sinY) * droneSpeed;
            const targetVelZ = (smoothInput.x * sinY - smoothInput.y * cosY) * droneSpeed;
            currentVelocity.x = THREE.MathUtils.lerp(currentVelocity.x, targetVelX, 0.02);
            currentVelocity.z = THREE.MathUtils.lerp(currentVelocity.z, targetVelZ, 0.02);

            drone.position.x += currentVelocity.x;
            drone.position.z += currentVelocity.z;

            /* ── Ammo Crate collision & landing ── */
            // Crate AABB: centered at (80,0,80), box 10 wide (X), 6 deep (Z), lid top at y=5.4
            const crateHalfW = 5.2;   // half-width X (with small margin)
            const crateHalfD = 3.2;   // half-depth Z (with small margin)
            const crateTopY = 5.4;   // top of the lid
            const cx = ammoCrate.position.x;
            const cz = ammoCrate.position.z;
            const onCrateXZ = (drone.position.x > cx - crateHalfW && drone.position.x < cx + crateHalfW &&
                drone.position.z > cz - crateHalfD && drone.position.z < cz + crateHalfD);

            // If the drone is above the crate footprint, enforce the crate top as a floor
            if (onCrateXZ) {
                const minAboveCrate = crateTopY + 0.4; // small offset so drone sits on lid
                if (baseHeight < minAboveCrate) {
                    baseHeight = minAboveCrate;
                }
            }

            // Reload missiles when landed on the crate (touching lid surface)
            const landedOnCrate = onCrateXZ && baseHeight <= crateTopY + 0.5;
            if (landedOnCrate) {
                droneData.missiles.forEach(slot => {
                    if (!slot.attached) {
                        respawnMissile(slot);
                    }
                });
            }

            // Clamp drone inside fence boundary
            const FENCE_LIMIT = FENCE_HALF - 1.5;
            if (drone.position.x > FENCE_LIMIT) { drone.position.x = FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.x < -FENCE_LIMIT) { drone.position.x = -FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.z > FENCE_LIMIT) { drone.position.z = FENCE_LIMIT; currentVelocity.z = 0; }
            if (drone.position.z < -FENCE_LIMIT) { drone.position.z = -FENCE_LIMIT; currentVelocity.z = 0; }

            /* ── Update shadow light to follow drone ── */
            moonLight.position.set(
                drone.position.x - 10,
                drone.position.y + 20,
                drone.position.z - 10
            );
            moonLight.target.position.copy(drone.position);

            /* ── Camera orbits behind drone based on yaw ── */
            cameraYaw = cameraYaw + (droneYaw - cameraYaw) * 0.05; // smooth follow

            const camTargetX = drone.position.x - Math.sin(cameraYaw) * camDist;
            const camTargetZ = drone.position.z - Math.cos(cameraYaw) * camDist;
            const camTargetY = drone.position.y + camHeight;

            camera.position.x = THREE.MathUtils.lerp(camera.position.x, camTargetX, 0.06);
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, camTargetZ, 0.06);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, camTargetY, 0.06);

            controls.target.x = THREE.MathUtils.lerp(controls.target.x, drone.position.x, 0.08);
            controls.target.z = THREE.MathUtils.lerp(controls.target.z, drone.position.z, 0.08);
            controls.target.y = THREE.MathUtils.lerp(controls.target.y, drone.position.y, 0.08);

            // Use stick inputs (local frame) for tilt, not world-space velocity
            const targetPitch = -smoothInput.y * 0.18;
            const targetRoll = smoothInput.x * 0.18;

            const totalSpeed = smoothInput.length() + Math.abs(smoothLeft.x);
            const speedFactor = 1.0 - Math.min(totalSpeed, 1.0) * 0.8;

            const idlePitch = Math.cos(t * 1.0) * 0.02 * speedFactor;
            const idleRoll = Math.sin(t * 1.2) * 0.03 * speedFactor;
            const idleYaw = Math.sin(t * 0.3) * 0.02;

            drone.position.y = baseHeight + Math.sin(t * 1.5) * 0.08 * speedFactor + Math.sin(t * 3.7) * 0.02;

            // Smoothly lerp rotation for fluid motion
            const goalPitch = idlePitch + targetPitch;
            const goalRoll = idleRoll + targetRoll;
            const goalYaw = droneYaw + idleYaw;
            drone.rotation.x = THREE.MathUtils.lerp(drone.rotation.x, goalPitch, 0.08);
            drone.rotation.z = THREE.MathUtils.lerp(drone.rotation.z, goalRoll, 0.08);
            drone.rotation.y = THREE.MathUtils.lerp(drone.rotation.y, goalYaw, 0.1);

            const propSpeed = 0.7 + smoothInput.length() * 0.5;
            droneData.props.forEach((prop, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                prop.rotation.y += propSpeed * dir;
            });
            droneData.motorBells.forEach((bell, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                bell.rotation.y += propSpeed * dir;
            });

            const glowIntensity = 1.5 + Math.sin(t * 2) * 0.5;
            droneData.underglowLEDs.forEach((led, i) => {
                const phase = t * 3 + (i / droneData.underglowLEDs.length) * Math.PI * 2;
                led.mat.emissiveIntensity = 2.0 + Math.sin(phase) * 1.0;
            });
            droneData.underglowLights.forEach(l => {
                l.intensity = glowIntensity;
            });

            if (droneData.recLED) {
                droneData.recLED.material.emissiveIntensity = Math.sin(t * 4) > 0 ? 5.0 : 0.2;
            }

            droneData.greenGlow.intensity = 0.5 + Math.sin(t * 2.5) * 0.3;

            /* ── Update in-flight missiles ── */
            for (let i = activeMissiles.length - 1; i >= 0; i--) {
                const m = activeMissiles[i];
                m.elapsed += dt;
                const progress = Math.min(m.elapsed / m.duration, 1.0);

                // Smooth ease-in-out arc
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Lerp XZ position
                const newX = THREE.MathUtils.lerp(m.startPos.x, m.targetPos.x, eased);
                const newZ = THREE.MathUtils.lerp(m.startPos.z, m.targetPos.z, eased);

                // Parabolic arc for Y
                const baseY = THREE.MathUtils.lerp(m.startPos.y, m.targetPos.y, eased);
                const arcY = m.arcHeight * Math.sin(progress * Math.PI);
                const newY = baseY + arcY;

                m.mesh.position.set(newX, newY, newZ);

                // Point missile in flight direction
                if (progress < 0.98) {
                    const nextProgress = Math.min((m.elapsed + 0.016) / m.duration, 1.0);
                    const nextEased = nextProgress < 0.5
                        ? 2 * nextProgress * nextProgress
                        : 1 - Math.pow(-2 * nextProgress + 2, 2) / 2;
                    const lookX = THREE.MathUtils.lerp(m.startPos.x, m.targetPos.x, nextEased);
                    const lookZ = THREE.MathUtils.lerp(m.startPos.z, m.targetPos.z, nextEased);
                    const lookBaseY = THREE.MathUtils.lerp(m.startPos.y, m.targetPos.y, nextEased);
                    const lookArcY = m.arcHeight * Math.sin(nextProgress * Math.PI);
                    const lookY = lookBaseY + lookArcY;
                    m.mesh.lookAt(lookX, lookY, lookZ);
                }

                // Smoke trail
                if (m.trail && m.trailIndex < 300) {
                    const positions = m.trail.geometry.attributes.position.array;
                    const idx = m.trailIndex * 3;
                    positions[idx] = newX + (Math.random() - 0.5) * 0.1;
                    positions[idx + 1] = newY + (Math.random() - 0.5) * 0.1;
                    positions[idx + 2] = newZ + (Math.random() - 0.5) * 0.1;
                    m.trailIndex++;
                    m.trail.geometry.setDrawRange(0, m.trailIndex);
                    m.trail.geometry.attributes.position.needsUpdate = true;
                }

                // Impact!
                if (progress >= 1.0) {
                    scene.remove(m.mesh);
                    if (m.trail) {
                        // Fade trail out gradually
                        const trail = m.trail;
                        const fadeDuration = 1.5;
                        let fadeElapsed = 0;
                        const fadeInterval = setInterval(() => {
                            fadeElapsed += 0.05;
                            trail.material.opacity = Math.max(0, 0.5 * (1 - fadeElapsed / fadeDuration));
                            if (fadeElapsed >= fadeDuration) {
                                scene.remove(trail);
                                trail.geometry.dispose();
                                trail.material.dispose();
                                clearInterval(fadeInterval);
                            }
                        }, 50);
                    }
                    createExplosion(m.targetPos);
                    activeMissiles.splice(i, 1);
                }
            }

            /* ── Update explosions ── */
            for (let i = explosions.length - 1; i >= 0; i--) {
                const e = explosions[i];
                e.elapsed += dt;
                const progress = e.elapsed / e.duration;

                // Fire particles
                const pos = e.particles.geometry.attributes.position.array;
                for (let p = 0; p < e.velocities.length; p++) {
                    const v = e.velocities[p];
                    pos[p * 3] += v.x * dt;
                    pos[p * 3 + 1] += v.y * dt;
                    pos[p * 3 + 2] += v.z * dt;
                    v.y -= 12 * dt; // gravity
                    v.x *= 0.97;
                    v.z *= 0.97;
                    // bounce off ground
                    if (pos[p * 3 + 1] < 0.05) {
                        pos[p * 3 + 1] = 0.05;
                        v.y = Math.abs(v.y) * 0.3;
                    }
                }
                e.particles.geometry.attributes.position.needsUpdate = true;
                e.mat.opacity = Math.max(0, 1.0 - progress);

                // Flash fades
                e.flash.intensity = Math.max(0, 20 * (1 - progress * 3));

                // Shockwave ring expands
                const ringScale = 1 + progress * 15;
                e.ring.scale.set(ringScale, ringScale, 1);
                e.ringMat.opacity = Math.max(0, 0.8 * (1 - progress * 1.5));

                // Smoke particles drift up
                const sPos = e.smokeParticles.geometry.attributes.position.array;
                for (let s = 0; s < e.smokeVels.length; s++) {
                    const sv = e.smokeVels[s];
                    sPos[s * 3] += sv.x * dt * 0.3;
                    sPos[s * 3 + 1] += sv.y * dt * 0.5;
                    sPos[s * 3 + 2] += sv.z * dt * 0.3;
                    sv.x *= 0.98;
                    sv.z *= 0.98;
                }
                e.smokeParticles.geometry.attributes.position.needsUpdate = true;
                e.smokeMat.opacity = Math.max(0, 0.6 * (1 - progress * 0.8));

                // Cleanup
                if (e.elapsed >= e.duration) {
                    scene.remove(e.particles);
                    scene.remove(e.flash);
                    scene.remove(e.ring);
                    scene.remove(e.smokeParticles);
                    e.particles.geometry.dispose();
                    e.mat.dispose();
                    e.ring.geometry.dispose();
                    e.ringMat.dispose();
                    e.smokeParticles.geometry.dispose();
                    e.smokeMat.dispose();
                    explosions.splice(i, 1);
                }
            }



            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
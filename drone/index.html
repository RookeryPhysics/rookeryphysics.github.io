<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinewhoop Drone Game</title>
    <meta name="description" content="A Three.js cinewhoop drone model with interactive grass physics.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://rookeryphysics.github.io/drone">
    <meta property="og:title" content="Cinewhoop Drone Game">
    <meta property="og:description" content="A Three.js cinewhoop drone model with interactive grass physics.">
    <meta property="og:image" content="https://rookeryphysics.github.io/drone/drone.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://rookeryphysics.github.io/drone">
    <meta property="twitter:title" content="Cinewhoop Drone Game">
    <meta property="twitter:description" content="A Three.js cinewhoop drone model with interactive grass physics.">
    <meta property="twitter:image" content="https://rookeryphysics.github.io/drone/drone.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #87CEEB;
        }

        canvas {
            display: block;
        }

        .joystick-zone {
            position: fixed;
            bottom: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(4px);
            transition: opacity 0.3s, background 0.3s;
        }

        .joystick-zone:active {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        #joystick-zone-right {
            right: 40px;
        }

        #joystick-zone-left {
            left: 40px;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .joystick-hint {
            position: absolute;
            bottom: 130px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        #joystick-hint-right {
            right: 65px;
            transform: translateX(50%);
        }

        #joystick-hint-left {
            left: 65px;
            transform: translateX(-50%);
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: sans-serif;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>
    <div id="loading">Generating Grass...</div>
    <div id="joystick-hint-left" class="joystick-hint">Yaw / Altitude</div>
    <div id="joystick-zone-left" class="joystick-zone">
        <div id="joystick-knob-left" class="joystick-knob"></div>
    </div>
    <div id="joystick-hint-right" class="joystick-hint">Flight Control</div>
    <div id="joystick-zone-right" class="joystick-zone">
        <div id="joystick-knob-right" class="joystick-knob"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x9DD5F0, 0.004);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 600);
        camera.position.set(0, 8.0, 16.0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloom = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.2,
            0.4,
            0.85
        );
        composer.addPass(bloom);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.minDistance = 2;
        controls.maxDistance = 20;
        controls.target.set(0, 1.5, 0);
        controls.maxPolarAngle = Math.PI * 0.85;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envScene = new THREE.Scene();
        envScene.background = new THREE.Color(0x87CEEB);

        const envGeo = new THREE.SphereGeometry(50, 32, 32);
        const envMat = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            uniforms: {
                colorTop: { value: new THREE.Color(0x4A90D9) },
                colorBottom: { value: new THREE.Color(0xC8E6FF) },
            },
            vertexShader: `
                varying vec3 vWorldPos;
                void main() {
                    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 colorTop;
                uniform vec3 colorBottom;
                varying vec3 vWorldPos;
                void main() {
                    float t = clamp(normalize(vWorldPos).y * 0.5 + 0.5, 0.0, 1.0);
                    gl_FragColor = vec4(mix(colorBottom, colorTop, t), 1.0);
                }
            `,
        });
        envScene.add(new THREE.Mesh(envGeo, envMat));
        const envMap = pmremGenerator.fromScene(envScene, 0.04).texture;
        scene.environment = envMap;

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const hemi = new THREE.HemisphereLight(0x87CEEB, 0x44aa44, 0.8);
        scene.add(hemi);

        const moonLight = new THREE.DirectionalLight(0xFFF5E0, 1.8);
        moonLight.position.set(-10, 20, -10);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.set(4096, 4096);
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 200;
        moonLight.shadow.camera.left = -60;
        moonLight.shadow.camera.right = 60;
        moonLight.shadow.camera.top = 60;
        moonLight.shadow.camera.bottom = -60;
        moonLight.shadow.bias = -0.0001;
        moonLight.shadow.normalBias = 0.02;
        scene.add(moonLight);

        const rimLight = new THREE.DirectionalLight(0xFFE8C0, 0.8);
        rimLight.position.set(15, 10, 5);
        scene.add(rimLight);

        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({
            color: 0x3A7D2A,
            roughness: 0.8,
            metalness: 0.1,
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const grassCount = 40000;

        const grassGeo = new THREE.PlaneGeometry(0.12, 0.8, 1, 4);
        grassGeo.translate(0, 0.4, 0);

        const positions = grassGeo.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            if (y > 0.6) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.1);
            } else if (y > 0.4) {
                const x = positions.getX(i);
                positions.setX(i, x * 0.5);
            }
        }
        grassGeo.computeVertexNormals();

        const grassMat = new THREE.MeshStandardMaterial({
            color: 0x4CAF50,
            emissive: 0x1B5E20,
            roughness: 0.7,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        grassMat.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = { value: 0 };
            shader.uniforms.uDronePos = { value: new THREE.Vector3(0, 10, 0) };

            grassMat.userData.shader = shader;

            shader.vertexShader = `
                uniform float uTime;
                uniform vec3 uDronePos;
                ${shader.vertexShader}
            `;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                
                vec4 worldInstancePos = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                
                float dist = distance(worldInstancePos.xz, uDronePos.xz);
                float radius = 3.0;
                
                float bendStrength = 0.0;
                
                if(dist < radius){
                    bendStrength = (1.0 - dist/radius) * (1.0 - dist/radius);
                }
                
                vec2 pushDir = normalize(worldInstancePos.xz - uDronePos.xz);
                
                float heightFactor = smoothstep(0.0, 0.8, position.y);
                
                float wind = sin(uTime * 1.5 + worldInstancePos.x * 0.5 + worldInstancePos.z * 0.3) * 0.1;
                
                transformed.x += wind * heightFactor;
                
                float pushForce = 2.5;
                transformed.x += pushDir.x * bendStrength * pushForce * heightFactor;
                transformed.z += pushDir.y * bendStrength * pushForce * heightFactor;
                
                transformed.y -= bendStrength * heightFactor * 0.5;
                `
            );
        };

        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        grassMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const dummy = new THREE.Object3D();
        const spread = 200;

        for (let i = 0; i < grassCount; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * spread,
                0,
                (Math.random() - 0.5) * spread
            );

            dummy.rotation.y = Math.random() * Math.PI * 2;

            const scale = 0.8 + Math.random() * 0.5;
            dummy.scale.set(scale, scale, scale);

            dummy.rotation.x = (Math.random() - 0.5) * 0.2;
            dummy.rotation.z = (Math.random() - 0.5) * 0.2;

            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);
        }

        scene.add(grassMesh);
        document.getElementById('loading').style.opacity = 0;

        /* ── Chain-link baseball fence around the map boundary ── */
        const FENCE_HALF = 98;          // boundary half-size (drone is clamped here)
        const fencePostHeight = 6.0;    // tall like a baseball backstop
        const fencePostRadius = 0.06;
        const fenceSpacing = 5;         // distance between posts
        const topRailRadius = 0.05;

        // Galvanized steel material for posts & top rail
        const fenceMetalMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.35,
            metalness: 0.9,
            envMapIntensity: 1.5,
        });

        // Chain-link mesh material – semi-transparent with diamond pattern via shader
        const chainLinkMat = new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.4,
            metalness: 0.85,
            transparent: true,
            opacity: 0.45,
            side: THREE.DoubleSide,
            depthWrite: false,
        });
        chainLinkMat.onBeforeCompile = (shader) => {
            shader.vertexShader = `
                varying vec2 vUvMesh;
                ${shader.vertexShader}
            `.replace('#include <uv_vertex>', `
                #include <uv_vertex>
                vUvMesh = uv;
            `);
            shader.fragmentShader = `
                varying vec2 vUvMesh;
                ${shader.fragmentShader}
            `.replace('#include <color_fragment>', `
                #include <color_fragment>
                // Diamond chain-link pattern
                float scaleU = 12.0;
                float scaleV = 24.0;
                vec2 st = vec2(vUvMesh.x * scaleU, vUvMesh.y * scaleV);
                float diamond = abs(fract(st.x) - 0.5) + abs(fract(st.y + st.x * 0.5) - 0.5);
                float wire = 1.0 - smoothstep(0.06, 0.12, abs(diamond - 0.5));
                if (wire < 0.1) discard;
                diffuseColor.a *= wire;
            `);
        };

        const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fencePostHeight, 8);
        // Cap on top of each post
        const postCapGeo = new THREE.SphereGeometry(fencePostRadius * 1.4, 8, 6);

        function addFenceSide(startX, startZ, dx, dz, totalLen) {
            const numPosts = Math.floor(totalLen / fenceSpacing) + 1;
            for (let i = 0; i < numPosts; i++) {
                const px = startX + dx * i * fenceSpacing;
                const pz = startZ + dz * i * fenceSpacing;

                // Steel post
                const post = new THREE.Mesh(postGeo, fenceMetalMat);
                post.position.set(px, fencePostHeight / 2, pz);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);

                // Rounded cap on post top
                const cap = new THREE.Mesh(postCapGeo, fenceMetalMat);
                cap.position.set(px, fencePostHeight + 0.02, pz);
                scene.add(cap);

                // Chain-link panel + top rail between posts
                if (i < numPosts - 1) {
                    const nx = startX + dx * (i + 1) * fenceSpacing;
                    const nz = startZ + dz * (i + 1) * fenceSpacing;
                    const mx = (px + nx) / 2;
                    const mz = (pz + nz) / 2;

                    // Top rail (horizontal pipe)
                    const railGeo = new THREE.CylinderGeometry(topRailRadius, topRailRadius, fenceSpacing, 8);
                    const rail = new THREE.Mesh(railGeo, fenceMetalMat);
                    rail.position.set(mx, fencePostHeight, mz);
                    if (Math.abs(dx) > 0) {
                        rail.rotation.z = Math.PI / 2;
                    } else {
                        rail.rotation.x = Math.PI / 2;
                    }
                    rail.castShadow = true;
                    scene.add(rail);

                    // Chain-link mesh panel
                    const panelGeo = new THREE.PlaneGeometry(fenceSpacing, fencePostHeight);
                    const panel = new THREE.Mesh(panelGeo, chainLinkMat);
                    panel.position.set(mx, fencePostHeight / 2, mz);
                    // Rotate panel to face outward
                    if (Math.abs(dx) > 0) {
                        // fence runs along X → panel faces Z
                        // default PlaneGeometry already faces +Z, no Y rotation needed
                    } else {
                        // fence runs along Z → panel faces X
                        panel.rotation.y = Math.PI / 2;
                    }
                    panel.receiveShadow = true;
                    scene.add(panel);
                }
            }
        }

        const fenceLen = FENCE_HALF * 2;
        // +Z side (front)
        addFenceSide(-FENCE_HALF, FENCE_HALF, 1, 0, fenceLen);
        // -Z side (back)
        addFenceSide(-FENCE_HALF, -FENCE_HALF, 1, 0, fenceLen);
        // +X side (right)
        addFenceSide(FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);
        // -X side (left)
        addFenceSide(-FENCE_HALF, -FENCE_HALF, 0, 1, fenceLen);

        function roundedBox(w, h, d, r, segs) {
            const shape = new THREE.Shape();
            const x = -w / 2, y = -h / 2;
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extSettings = {
                depth: d,
                bevelEnabled: true,
                bevelThickness: r * 0.5,
                bevelSize: r * 0.5,
                bevelSegments: segs || 3,
            };
            const geo = new THREE.ExtrudeGeometry(shape, extSettings);
            geo.center();
            return geo;
        }

        function createDrone() {
            const drone = new THREE.Group();

            const matCarbonFiber = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.4,
                metalness: 0.5,
                envMapIntensity: 1.0,
            });

            const matDuctPlastic = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.5,
                metalness: 0.1,
                envMapIntensity: 0.5,
            });

            const matDuctInner = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide,
            });

            const matAccentOrange = new THREE.MeshStandardMaterial({
                color: 0xff4400,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0xff2200,
                emissiveIntensity: 0.5,
                envMapIntensity: 1.2,
            });

            const matMotorBell = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.9,
                envMapIntensity: 2.5,
            });

            const matMotorStator = new THREE.MeshStandardMaterial({
                color: 0xaa7722,
                roughness: 0.4,
                metalness: 0.7,
            });

            const matPropBlack = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matPropOrange = new THREE.MeshStandardMaterial({
                color: 0xff5500,
                roughness: 0.3,
                metalness: 0.2,
                transparent: true,
                opacity: 0.9,
            });

            const matLens = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.0,
                metalness: 1.0,
                envMapIntensity: 3.0,
            });

            const matCamBody = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.6,
                metalness: 0.2,
                envMapIntensity: 0.8,
            });

            const matBattery = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.6,
                metalness: 0.1,
            });

            const matBattLabel = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                roughness: 0.5,
                metalness: 0.3,
            });

            const matRubber = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.9,
                metalness: 0.0,
            });

            const matPCB = new THREE.MeshStandardMaterial({
                color: 0x1a3322,
                roughness: 0.8,
                metalness: 0.1,
            });

            const matLEDGreen = new THREE.MeshStandardMaterial({
                color: 0x00ff44,
                emissive: 0x00ff44,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDRed = new THREE.MeshStandardMaterial({
                color: 0xff0022,
                emissive: 0xff0022,
                emissiveIntensity: 4.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matLEDBlue = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0066ff,
                emissiveIntensity: 3.0,
                roughness: 0.1,
                metalness: 0.0,
            });

            const matWhitePlastic = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.5,
                metalness: 0.0,
            });

            const matSilver = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.95,
                envMapIntensity: 2.0,
            });

            const frameGeo = roundedBox(1.3, 0.12, 1.5, 0.04, 3);
            const frame = new THREE.Mesh(frameGeo, matCarbonFiber);
            frame.castShadow = true;
            drone.add(frame);

            const bottomPlate = new THREE.Mesh(roundedBox(1.2, 0.04, 1.4, 0.03, 2), matCarbonFiber);
            bottomPlate.position.y = -0.08;
            bottomPlate.castShadow = true;
            drone.add(bottomPlate);

            const armPositions = [
                { x: 0.55, z: 0.55, angle: Math.PI / 4 },
                { x: -0.55, z: 0.55, angle: -Math.PI / 4 },
                { x: 0.55, z: -0.55, angle: -Math.PI / 4 },
                { x: -0.55, z: -0.55, angle: Math.PI / 4 },
            ];

            armPositions.forEach(ap => {
                const armGeo = new THREE.BoxGeometry(0.65, 0.08, 0.2);
                const arm = new THREE.Mesh(armGeo, matCarbonFiber);
                arm.position.set(ap.x * 0.6, 0, ap.z * 0.6);
                arm.rotation.y = ap.angle;
                arm.castShadow = true;
                drone.add(arm);
            });

            const fcBoard = new THREE.Mesh(
                roundedBox(0.42, 0.04, 0.42, 0.02, 2),
                matPCB
            );
            fcBoard.position.y = 0.1;
            drone.add(fcBoard);

            for (let sx = -1; sx <= 1; sx += 2) {
                for (let sz = -1; sz <= 1; sz += 2) {
                    const standoff = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8),
                        matSilver
                    );
                    standoff.position.set(sx * 0.16, 0.08, sz * 0.16);
                    drone.add(standoff);
                }
            }

            const escBoard = new THREE.Mesh(
                roundedBox(0.44, 0.03, 0.44, 0.02, 2),
                matPCB
            );
            escBoard.position.y = 0.155;
            drone.add(escBoard);

            const capGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.08, 10);
            const cap = new THREE.Mesh(capGeo, matCarbonFiber);
            cap.position.set(0.1, 0.2, 0.05);
            cap.rotation.z = Math.PI / 2;
            drone.add(cap);

            const ductOuterR = 0.52;
            const ductInnerR = 0.47;
            const ductHeight = 0.32;
            const motorPositions = [
                { x: 0.82, z: 0.82 }, { x: -0.82, z: 0.82 },
                { x: 0.82, z: -0.82 }, { x: -0.82, z: -0.82 }
            ];

            const allProps = [];
            const allMotorBells = [];

            motorPositions.forEach((pos, i) => {
                const motorUnit = new THREE.Group();
                motorUnit.position.set(pos.x, 0, pos.z);

                const ductOuterGeo = new THREE.CylinderGeometry(
                    ductOuterR, ductOuterR + 0.02, ductHeight, 32, 1, true
                );
                const ductOuter = new THREE.Mesh(ductOuterGeo, matDuctPlastic);
                ductOuter.castShadow = true;
                motorUnit.add(ductOuter);

                const ductInnerGeo = new THREE.CylinderGeometry(
                    ductInnerR, ductInnerR, ductHeight, 32, 1, true
                );
                const ductInner = new THREE.Mesh(ductInnerGeo, matDuctInner);
                motorUnit.add(ductInner);

                const lipGeo = new THREE.TorusGeometry(
                    (ductOuterR + ductInnerR) / 2, 0.025, 8, 32
                );
                const lip = new THREE.Mesh(lipGeo, matDuctPlastic);
                lip.rotation.x = Math.PI / 2;
                lip.position.y = ductHeight / 2;
                motorUnit.add(lip);

                const lipBot = lip.clone();
                lipBot.position.y = -ductHeight / 2;
                motorUnit.add(lipBot);

                const stripeGeo = new THREE.TorusGeometry(
                    ductOuterR + 0.005, 0.012, 6, 32
                );
                const stripe = new THREE.Mesh(stripeGeo, matAccentOrange);
                stripe.rotation.x = Math.PI / 2;
                stripe.position.y = ductHeight / 2 - 0.04;
                motorUnit.add(stripe);

                for (let cs = 0; cs < 4; cs++) {
                    const supportGeo = new THREE.BoxGeometry(ductInnerR * 0.85, 0.03, 0.025);
                    const support = new THREE.Mesh(supportGeo, matCarbonFiber);
                    support.rotation.y = (cs * Math.PI) / 4;
                    support.position.y = -0.05;
                    motorUnit.add(support);
                }

                const statorGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.12, 16);
                const stator = new THREE.Mesh(statorGeo, matMotorStator);
                stator.position.y = -0.04;
                motorUnit.add(stator);

                for (let w = 0; w < 6; w++) {
                    const coilGeo = new THREE.TorusGeometry(0.1, 0.012, 4, 6);
                    const coil = new THREE.Mesh(coilGeo, matMotorStator);
                    coil.rotation.x = Math.PI / 2;
                    coil.rotation.z = (w * Math.PI) / 3;
                    coil.position.y = -0.04;
                    motorUnit.add(coil);
                }

                const bellGroup = new THREE.Group();
                bellGroup.position.y = 0.04;

                const bellGeo = new THREE.CylinderGeometry(0.12, 0.11, 0.06, 20);
                const bell = new THREE.Mesh(bellGeo, matMotorBell);
                bellGroup.add(bell);

                const bellCapGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.02, 16);
                const bellCap = new THREE.Mesh(bellCapGeo, matMotorBell);
                bellCap.position.y = 0.04;
                bellGroup.add(bellCap);

                const shaftGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8);
                const shaft = new THREE.Mesh(shaftGeo, matSilver);
                shaft.position.y = 0.06;
                bellGroup.add(shaft);

                motorUnit.add(bellGroup);
                allMotorBells.push(bellGroup);

                const propGroup = new THREE.Group();
                propGroup.position.y = 0.1;

                const hubGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.018, 12);
                const propMatChoice = (i < 2) ? matPropOrange : matPropBlack;
                const hub = new THREE.Mesh(hubGeo, propMatChoice);
                propGroup.add(hub);

                const nutGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 6);
                const nut = new THREE.Mesh(nutGeo, matSilver);
                nut.position.y = 0.014;
                propGroup.add(nut);

                for (let b = 0; b < 3; b++) {
                    const bladeGroup = new THREE.Group();
                    bladeGroup.rotation.y = (b * Math.PI * 2) / 3;

                    const bladeLen = 0.38;
                    const bladeW = 0.055;
                    const bladeShape = new THREE.Shape();
                    bladeShape.moveTo(0, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.3, bladeW * 0.6, bladeLen * 0.75, bladeW);
                    bladeShape.quadraticCurveTo(bladeLen * 0.95, bladeW * 0.8, bladeLen, 0);
                    bladeShape.quadraticCurveTo(bladeLen * 0.7, -bladeW * 0.15, 0, 0);

                    const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                        depth: 0.008,
                        bevelEnabled: true,
                        bevelThickness: 0.002,
                        bevelSize: 0.002,
                        bevelSegments: 2,
                    });
                    bladeGeo.center();

                    const blade = new THREE.Mesh(bladeGeo, propMatChoice);
                    blade.rotation.x = 0.12;
                    blade.position.x = bladeLen / 2 + 0.02;
                    bladeGroup.add(blade);

                    propGroup.add(bladeGroup);
                }

                motorUnit.add(propGroup);
                allProps.push(propGroup);

                drone.add(motorUnit);
            });

            const camMount = new THREE.Group();
            camMount.position.set(0, 0.22, 0.58);
            camMount.rotation.x = -0.18;

            const camBodyGeo = roundedBox(0.36, 0.26, 0.2, 0.025, 3);
            const camBody = new THREE.Mesh(camBodyGeo, matCamBody);
            camBody.castShadow = true;
            camMount.add(camBody);

            const lensBarrelGeo = new THREE.CylinderGeometry(0.075, 0.08, 0.06, 20);
            const lensBarrel = new THREE.Mesh(lensBarrelGeo, matCarbonFiber);
            lensBarrel.rotation.x = Math.PI / 2;
            lensBarrel.position.z = 0.13;
            camMount.add(lensBarrel);

            const lensGlassGeo = new THREE.CircleGeometry(0.065, 24);
            const lensGlass = new THREE.Mesh(lensGlassGeo, matLens);
            lensGlass.position.z = 0.165;
            camMount.add(lensGlass);

            const lensRingGeo = new THREE.TorusGeometry(0.072, 0.008, 8, 24);
            const lensRing = new THREE.Mesh(lensRingGeo, matSilver);
            lensRing.position.z = 0.16;
            camMount.add(lensRing);

            const innerRingGeo = new THREE.TorusGeometry(0.04, 0.005, 8, 20);
            const innerRing = new THREE.Mesh(innerRingGeo, matSilver);
            innerRing.position.z = 0.167;
            camMount.add(innerRing);

            const recLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                matLEDRed
            );
            recLED.position.set(0.14, 0.08, 0.1);
            camMount.add(recLED);

            for (let side = -1; side <= 1; side += 2) {
                const bracketGeo = new THREE.BoxGeometry(0.015, 0.12, 0.04);
                const bracket = new THREE.Mesh(bracketGeo, matSilver);
                bracket.position.set(side * 0.2, -0.02, 0);
                camMount.add(bracket);
            }

            for (let side = -1; side <= 1; side += 2) {
                const damperGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const damper = new THREE.Mesh(damperGeo, matAccentOrange);
                damper.position.set(side * 0.2, -0.1, 0);
                camMount.add(damper);
            }

            drone.add(camMount);

            const batteryGroup = new THREE.Group();
            batteryGroup.position.set(0, -0.12, -0.1);

            const battGeo = roundedBox(0.58, 0.14, 0.38, 0.02, 2);
            const battBody = new THREE.Mesh(battGeo, matBattery);
            battBody.castShadow = true;
            batteryGroup.add(battBody);

            const labelGeo = new THREE.BoxGeometry(0.4, 0.005, 0.2);
            const label = new THREE.Mesh(labelGeo, matBattLabel);
            label.position.y = 0.072;
            batteryGroup.add(label);

            for (let s = -1; s <= 1; s += 2) {
                const strapGeo = new THREE.BoxGeometry(0.02, 0.18, 0.42);
                const strap = new THREE.Mesh(strapGeo, matAccentOrange);
                strap.position.set(s * 0.15, 0, 0);
                batteryGroup.add(strap);
            }

            const xt60 = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.04, 0.03),
                matBattLabel
            );
            xt60.position.set(0.32, 0, 0);
            batteryGroup.add(xt60);

            for (let w = 0; w < 4; w++) {
                const wireGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.08, 6);
                const wireMat = new THREE.MeshStandardMaterial({
                    color: [0xff0000, 0x000000, 0xff0000, 0x000000][w],
                    roughness: 0.7,
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.set(0.3, -0.02, -0.12 + w * 0.03);
                wire.rotation.z = Math.PI / 2 + 0.3;
                batteryGroup.add(wire);
            }

            drone.add(batteryGroup);

            const antennaGroup = new THREE.Group();
            antennaGroup.position.set(0.08, 0.2, -0.65);

            const smaGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.04, 10);
            const sma = new THREE.Mesh(smaGeo, matSilver);
            antennaGroup.add(sma);

            const antennaStalk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.35, 8),
                matWhitePlastic
            );
            antennaStalk.position.y = 0.2;
            antennaStalk.rotation.x = -0.3;
            antennaGroup.add(antennaStalk);

            const mushroomGeo = new THREE.SphereGeometry(0.04, 12, 12);
            const mushroom = new THREE.Mesh(mushroomGeo, matWhitePlastic);
            mushroom.position.set(0, 0.38, -0.1);
            antennaGroup.add(mushroom);

            for (let cl = 0; cl < 4; cl++) {
                const clWire = new THREE.Mesh(
                    new THREE.TorusGeometry(0.03, 0.003, 6, 8, Math.PI),
                    matSilver
                );
                clWire.rotation.y = (cl * Math.PI) / 2;
                clWire.position.set(0, 0.38, -0.1);
                antennaGroup.add(clWire);
            }

            drone.add(antennaGroup);

            const gpsMount = new THREE.Group();
            gpsMount.position.set(-0.08, 0.2, -0.55);

            const gpsMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.15, 8),
                matCarbonFiber
            );
            gpsMast.position.y = 0.08;
            gpsMount.add(gpsMast);

            const gpsDisk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.015, 16),
                matCarbonFiber
            );
            gpsDisk.position.y = 0.16;
            gpsMount.add(gpsDisk);

            drone.add(gpsMount);

            const skidPositions = [
                { x: 0.35, z: 0.45 }, { x: -0.35, z: 0.45 },
                { x: 0.35, z: -0.45 }, { x: -0.35, z: -0.45 }
            ];

            skidPositions.forEach(sp => {
                const skid = new THREE.Group();
                skid.position.set(sp.x, -0.18, sp.z);

                const legGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.1, 8);
                const leg = new THREE.Mesh(legGeo, matCarbonFiber);
                skid.add(leg);

                const footGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const foot = new THREE.Mesh(footGeo, matRubber);
                foot.position.y = -0.05;
                foot.scale.y = 0.5;
                skid.add(foot);

                drone.add(skid);
            });

            const rearLED = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                matLEDGreen
            );
            rearLED.position.set(0, 0.05, -0.76);
            drone.add(rearLED);

            const greenGlow = new THREE.PointLight(0x00ff44, 1.0, 2.5);
            greenGlow.position.copy(rearLED.position);
            drone.add(greenGlow);

            const frontLEDs = [];
            for (let side = -1; side <= 1; side += 2) {
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.012, 8, 8),
                    matLEDBlue
                );
                led.position.set(side * 0.5, -0.02, 0.7);
                drone.add(led);
                frontLEDs.push(led);

                const blueGlow = new THREE.PointLight(0x0066ff, 0.5, 1.5);
                blueGlow.position.copy(led.position);
                drone.add(blueGlow);
            }

            const underglowLEDs = [];
            const underglowLights = [];
            const numUnderglow = 12;
            for (let u = 0; u < numUnderglow; u++) {
                const angle = (u * Math.PI * 2) / numUnderglow;
                const r = 0.5;
                const ledMat = new THREE.MeshStandardMaterial({
                    color: 0x00ccff,
                    emissive: 0x00ccff,
                    emissiveIntensity: 2.0,
                    roughness: 0.2,
                });
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.01, 6, 6),
                    ledMat
                );
                led.position.set(Math.cos(angle) * r, -0.14, Math.sin(angle) * r);
                drone.add(led);
                underglowLEDs.push({ mesh: led, mat: ledMat });
            }

            const underglowMain = new THREE.PointLight(0x00ccff, 2.0, 8);
            underglowMain.position.set(0, -0.4, 0);
            drone.add(underglowMain);
            underglowLights.push(underglowMain);

            const buzzer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.02, 12),
                matCarbonFiber
            );
            buzzer.position.set(0.6, 0, 0);
            buzzer.rotation.z = Math.PI / 2;
            drone.add(buzzer);

            for (let ra = 0; ra < 2; ra++) {
                const rxAntennaGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.25, 6);
                const rxAntenna = new THREE.Mesh(rxAntennaGeo, matCarbonFiber);
                rxAntenna.position.set(-0.15 + ra * 0.3, 0.12, -0.7);
                rxAntenna.rotation.x = -0.6 + ra * 0.15;
                rxAntenna.rotation.z = -0.3 + ra * 0.6;
                drone.add(rxAntenna);
            }

            drone.scale.set(1.6, 1.6, 1.6);

            drone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return {
                group: drone,
                props: allProps,
                motorBells: allMotorBells,
                underglowLEDs,
                underglowLights,
                recLED,
                greenGlow,
                frontLEDs,
            };
        }

        const droneData = createDrone();
        const drone = droneData.group;
        drone.position.set(0, 1.8, 0);
        drone.rotation.order = 'YXZ';  // Apply yaw first so pitch/roll are in local frame
        scene.add(drone);


        /* ── Joystick Helper Factory ── */
        function createJoystickController(zoneId, knobId) {
            const zone = document.getElementById(zoneId);
            const knob = document.getElementById(knobId);
            const joySize = 120;
            const knobSize = 40;
            const maxDist = (joySize - knobSize) / 2;
            const state = { x: 0, y: 0 };
            let dragging = false;
            let startX, startY;
            let activeTouchId = null;

            const update = (dx, dy) => {
                const dist = Math.sqrt(dx * dx + dy * dy);
                let cx = dx, cy = dy;
                if (dist > maxDist) {
                    const a = Math.atan2(dy, dx);
                    cx = Math.cos(a) * maxDist;
                    cy = Math.sin(a) * maxDist;
                }
                knob.style.transform = `translate(${cx}px, ${cy}px)`;
                state.x = cx / maxDist;
                state.y = cy / maxDist;
            };

            const reset = () => {
                dragging = false;
                activeTouchId = null;
                state.x = 0;
                state.y = 0;
                knob.style.transform = `translate(0px, 0px)`;
            };

            /* Mouse events */
            zone.addEventListener('mousedown', (e) => {
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                update(e.clientX - startX, e.clientY - startY);
            });
            window.addEventListener('mouseup', () => { if (dragging) reset(); });

            /* Touch events – track a specific touch ID so both sticks work independently */
            zone.addEventListener('touchstart', (e) => {
                if (activeTouchId !== null) return; // already tracking
                const touch = e.changedTouches[0];
                activeTouchId = touch.identifier;
                dragging = true;
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;
                update(touch.clientX - startX, touch.clientY - startY);
            }, { passive: true });

            window.addEventListener('touchmove', (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        const t = e.changedTouches[i];
                        update(t.clientX - startX, t.clientY - startY);
                        break;
                    }
                }
            }, { passive: true });

            const touchEnd = (e) => {
                if (activeTouchId === null) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        reset();
                        break;
                    }
                }
            };
            window.addEventListener('touchend', touchEnd);
            window.addEventListener('touchcancel', touchEnd);

            return state;
        }

        /* Right stick  → forward / backward / strafe */
        const inputVector = createJoystickController('joystick-zone-right', 'joystick-knob-right');
        /* Left stick   → yaw (x) & altitude (y) */
        const inputLeft = createJoystickController('joystick-zone-left', 'joystick-knob-left');

        /* ── Keyboard input (WASD = left stick, Arrows = right stick) ── */
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function getKeyboardInput() {
            // WASD → left stick (A/D = yaw X, W/S = altitude Y)
            let leftX = 0, leftY = 0;
            if (keys['KeyA']) leftX -= 1;
            if (keys['KeyD']) leftX += 1;
            if (keys['KeyW']) leftY -= 1;   // W = up (stick up = negative Y)
            if (keys['KeyS']) leftY += 1;   // S = down

            // Arrow keys → right stick (Left/Right = strafe X, Up/Down = fwd/back Y)
            let rightX = 0, rightY = 0;
            if (keys['ArrowLeft']) rightX -= 1;
            if (keys['ArrowRight']) rightX += 1;
            if (keys['ArrowUp']) rightY -= 1;   // forward = stick up = negative Y
            if (keys['ArrowDown']) rightY += 1;

            return { leftX, leftY, rightX, rightY };
        }

        const clock = new THREE.Clock();
        const droneSpeed = 0.15;
        const yawSpeed = 0.04;      // radians per frame at full deflection
        const altSpeed = 0.08;      // units per frame at full deflection
        const smoothInput = new THREE.Vector2();   // right stick smoothed
        const smoothLeft = new THREE.Vector2();   // left stick smoothed
        const currentVelocity = new THREE.Vector3();

        let baseHeight = 1.8;
        let droneYaw = Math.PI;     // current heading (initial = facing camera)
        let cameraYaw = droneYaw;   // smoothed camera heading that follows drone yaw
        const camDist = 14;         // how far behind the drone the camera orbits
        const camHeight = 6;        // camera height offset above drone


        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            if (grassMat.userData.shader) {
                grassMat.userData.shader.uniforms.uTime.value = t;
                grassMat.userData.shader.uniforms.uDronePos.value.copy(drone.position);
            }

            /* ── Blend keyboard + joystick, then smooth ── */
            const kb = getKeyboardInput();
            // Clamp combined input to [-1, 1]
            const clamp = (v) => Math.max(-1, Math.min(1, v));
            const combinedRightX = clamp(inputVector.x + kb.rightX);
            const combinedRightY = clamp(inputVector.y + kb.rightY);
            const combinedLeftX = clamp(inputLeft.x + kb.leftX);
            const combinedLeftY = clamp(inputLeft.y + kb.leftY);

            smoothInput.x = THREE.MathUtils.lerp(smoothInput.x, combinedRightX, 0.1);
            smoothInput.y = THREE.MathUtils.lerp(smoothInput.y, combinedRightY, 0.1);
            smoothLeft.x = THREE.MathUtils.lerp(smoothLeft.x, combinedLeftX, 0.1);
            smoothLeft.y = THREE.MathUtils.lerp(smoothLeft.y, combinedLeftY, 0.1);

            /* ── Left stick: yaw & altitude ── */
            droneYaw -= smoothLeft.x * yawSpeed;            // left → positive yaw
            baseHeight -= smoothLeft.y * altSpeed;           // stick up (negative y) → go up
            baseHeight = Math.max(0.4, baseHeight);          // clamp above ground

            /* ── Right stick: movement in the drone's local heading ── */
            const sinY = Math.sin(droneYaw);
            const cosY = Math.cos(droneYaw);
            // forward/back from stick Y, strafe from stick X – glide to a stop
            const targetVelX = (-smoothInput.x * cosY - smoothInput.y * sinY) * droneSpeed;
            const targetVelZ = (smoothInput.x * sinY - smoothInput.y * cosY) * droneSpeed;
            currentVelocity.x = THREE.MathUtils.lerp(currentVelocity.x, targetVelX, 0.06);
            currentVelocity.z = THREE.MathUtils.lerp(currentVelocity.z, targetVelZ, 0.06);

            drone.position.x += currentVelocity.x;
            drone.position.z += currentVelocity.z;

            // Clamp drone inside fence boundary
            const FENCE_LIMIT = FENCE_HALF - 1.5;
            if (drone.position.x > FENCE_LIMIT) { drone.position.x = FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.x < -FENCE_LIMIT) { drone.position.x = -FENCE_LIMIT; currentVelocity.x = 0; }
            if (drone.position.z > FENCE_LIMIT) { drone.position.z = FENCE_LIMIT; currentVelocity.z = 0; }
            if (drone.position.z < -FENCE_LIMIT) { drone.position.z = -FENCE_LIMIT; currentVelocity.z = 0; }

            /* ── Camera orbits behind drone based on yaw ── */
            cameraYaw = cameraYaw + (droneYaw - cameraYaw) * 0.05; // smooth follow

            const camTargetX = drone.position.x - Math.sin(cameraYaw) * camDist;
            const camTargetZ = drone.position.z - Math.cos(cameraYaw) * camDist;
            const camTargetY = drone.position.y + camHeight;

            camera.position.x = THREE.MathUtils.lerp(camera.position.x, camTargetX, 0.06);
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, camTargetZ, 0.06);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, camTargetY, 0.06);

            controls.target.x = THREE.MathUtils.lerp(controls.target.x, drone.position.x, 0.08);
            controls.target.z = THREE.MathUtils.lerp(controls.target.z, drone.position.z, 0.08);
            controls.target.y = THREE.MathUtils.lerp(controls.target.y, drone.position.y, 0.08);

            // Use stick inputs (local frame) for tilt, not world-space velocity
            const targetPitch = -smoothInput.y * 0.35;
            const targetRoll = smoothInput.x * 0.35;

            const totalSpeed = smoothInput.length() + Math.abs(smoothLeft.x);
            const speedFactor = 1.0 - Math.min(totalSpeed, 1.0) * 0.8;

            const idlePitch = Math.cos(t * 1.0) * 0.02 * speedFactor;
            const idleRoll = Math.sin(t * 1.2) * 0.03 * speedFactor;
            const idleYaw = Math.sin(t * 0.3) * 0.02;

            drone.position.y = baseHeight + Math.sin(t * 1.5) * 0.08 * speedFactor + Math.sin(t * 3.7) * 0.02;

            drone.rotation.x = idlePitch + targetPitch;
            drone.rotation.z = idleRoll + targetRoll;
            drone.rotation.y = droneYaw + idleYaw;

            const propSpeed = 0.7 + smoothInput.length() * 0.5;
            droneData.props.forEach((prop, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                prop.rotation.y += propSpeed * dir;
            });
            droneData.motorBells.forEach((bell, i) => {
                const dir = (i % 2 === 0) ? 1 : -1;
                bell.rotation.y += propSpeed * dir;
            });

            const glowIntensity = 1.5 + Math.sin(t * 2) * 0.5;
            droneData.underglowLEDs.forEach((led, i) => {
                const phase = t * 3 + (i / droneData.underglowLEDs.length) * Math.PI * 2;
                led.mat.emissiveIntensity = 2.0 + Math.sin(phase) * 1.0;
            });
            droneData.underglowLights.forEach(l => {
                l.intensity = glowIntensity;
            });

            if (droneData.recLED) {
                droneData.recLED.material.emissiveIntensity = Math.sin(t * 4) > 0 ? 5.0 : 0.2;
            }

            droneData.greenGlow.intensity = 0.5 + Math.sin(t * 2.5) * 0.3;



            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>